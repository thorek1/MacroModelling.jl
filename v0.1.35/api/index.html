<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ MacroModelling.jl</title><meta name="title" content="API ¬∑ MacroModelling.jl"/><meta property="og:title" content="API ¬∑ MacroModelling.jl"/><meta property="twitter:title" content="API ¬∑ MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.Beta-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real" href="#MacroModelling.Beta-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>MacroModelling.Beta</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Beta(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Convenience wrapper for the truncated Beta distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li><li><code>lower_bound</code> [Type: <code>Real</code>]: truncation lower bound of the distribution</li><li><code>upper_bound</code> [Type: <code>Real</code>]: truncation upper bound of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.Beta-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#MacroModelling.Beta-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>MacroModelling.Beta</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Beta(Œº, œÉ; ŒºœÉ)
</code></pre><p>Convenience wrapper for the Beta distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.Gamma-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real" href="#MacroModelling.Gamma-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>MacroModelling.Gamma</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gamma(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Convenience wrapper for the truncated Inverse Gamma distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li><li><code>lower_bound</code> [Type: <code>Real</code>]: truncation lower bound of the distribution</li><li><code>upper_bound</code> [Type: <code>Real</code>]: truncation upper bound of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.Gamma-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#MacroModelling.Gamma-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>MacroModelling.Gamma</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gamma(Œº, œÉ; ŒºœÉ)
</code></pre><p>Convenience wrapper for the Gamma distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.InverseGamma-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real" href="#MacroModelling.InverseGamma-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>MacroModelling.InverseGamma</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InverseGamma(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Convenience wrapper for the truncated Inverse Gamma distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li><li><code>lower_bound</code> [Type: <code>Real</code>]: truncation lower bound of the distribution</li><li><code>upper_bound</code> [Type: <code>Real</code>]: truncation upper bound of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.InverseGamma-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#MacroModelling.InverseGamma-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>MacroModelling.InverseGamma</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InverseGamma(Œº, œÉ; ŒºœÉ)
</code></pre><p>Convenience wrapper for the Inverse Gamma distribution.</p><p>If <code>ŒºœÉ = true</code> then <code>Œº</code> and <code>œÉ</code> are translated to the parameters of the distribution. Otherwise <code>Œº</code> and <code>œÉ</code> represent the parameters of the distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean or first parameter of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation or first parameter of the distribution</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>]: switch whether Œº and œÉ represent the moments of the distribution or their parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.Normal-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real" href="#MacroModelling.Normal-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Real"><code>MacroModelling.Normal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Normal(Œº, œÉ, lower_bound, upper_bound)
</code></pre><p>Convenience wrapper for the truncated Normal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: mean of the distribution, </li><li><code>œÉ</code> [Type: <code>Real</code>]: standard deviation of the distribution</li><li><code>lower_bound</code> [Type: <code>Real</code>]: truncation lower bound of the distribution</li><li><code>upper_bound</code> [Type: <code>Real</code>]: truncation upper bound of the distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/priors.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.SS" href="#MacroModelling.SS"><code>MacroModelling.SS</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1452-L1454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.SSS-Tuple" href="#MacroModelling.SSS-Tuple"><code>MacroModelling.SSS</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1439-L1441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.autocorr" href="#MacroModelling.autocorr"><code>MacroModelling.autocorr</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2181-L2183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.corr" href="#MacroModelling.corr"><code>MacroModelling.corr</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2081-L2083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.cov" href="#MacroModelling.cov"><code>MacroModelling.cov</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2643-L2645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_dynare" href="#MacroModelling.export_dynare"><code>MacroModelling.export_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L209-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_mod_file" href="#MacroModelling.export_mod_file"><code>MacroModelling.export_mod_file</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L219-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_model" href="#MacroModelling.export_model"><code>MacroModelling.export_model</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L239-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_to_dynare" href="#MacroModelling.export_to_dynare"><code>MacroModelling.export_to_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L214-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.fevd" href="#MacroModelling.fevd"><code>MacroModelling.fevd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1876-L1878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_IRF" href="#MacroModelling.get_IRF"><code>MacroModelling.get_IRF</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1174-L1176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_SS" href="#MacroModelling.get_SS"><code>MacroModelling.get_SS</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1462-L1464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_SSS-Tuple" href="#MacroModelling.get_SSS-Tuple"><code>MacroModelling.get_SSS</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1433-L1435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_autocorr" href="#MacroModelling.get_autocorr"><code>MacroModelling.get_autocorr</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2175-L2177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_autocorrelation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_autocorrelation(
    ùìÇ;
    autocorrelation_periods,
    parameters,
    algorithm,
    verbose
)
</code></pre><p>Return the autocorrelations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>]: periods for which to return the autocorrelation</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_autocorrelation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Autocorrelation_orders ‚àà 5-element UnitRange{Int64}
And data, 4√ó5 Matrix{Float64}:
        (1)         (2)         (3)         (4)         (5)
  (:c)    0.966974    0.927263    0.887643    0.849409    0.812761
  (:k)    0.971015    0.931937    0.892277    0.853876    0.817041
  (:q)    0.32237     0.181562    0.148347    0.136867    0.129944
  (:z)    0.2         0.04        0.008       0.0016      0.00032</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2089">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibrated_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_calibrated_parameters(ùìÇ; values)
</code></pre><p>Returns the parameters (and optionally the values) which are determined by a calibration equation. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibrated_parameters(RBC)
# output
1-element Vector{String}:
 &quot;Œ¥&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibration_equation_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_calibration_equation_parameters(ùìÇ)
</code></pre><p>Returns the parameters used in calibration equations which are not used in the equations of the model (see <code>capital_to_output</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibration_equation_parameters(RBC)
# output
1-element Vector{String}:
 &quot;capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibration_equations-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_calibration_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibration_equations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_calibration_equations(ùìÇ)
</code></pre><p>Return the calibration equations declared in the <code>@parameters</code> block. Calibration equations are additional equations which are part of the non-stochastic steady state problem. The additional equation is matched with a calibated parameter which is part of the equations declared in the <code>@model</code> block and can be retrieved with: <code>get_calibrated_parameters</code></p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the ouput assumes the equations are equal to 0. As in, <code>k / (q * 4) - capital_to_output</code> implies <code>k / (q * 4) - capital_to_output = 0</code> and therefore: <code>k / (q * 4) = capital_to_output</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibration_equations(RBC)
# output
1-element Vector{String}:
 &quot;k / (q * 4) - capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}" href="#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.get_conditional_forecast</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_conditional_forecast(
    ùìÇ,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    variables,
    conditions_in_levels,
    algorithm,
    levels,
    verbose
)
</code></pre><p>Return the conditional forecast given restrictions on endogenous variables and shocks (optional) in a 2-dimensional array. By default (see <code>levels</code>), the values represent absolute deviations from the relevant steady state (e.g. higher order perturbation algorithms are relative to the stochastic steady state). A constrained minimisation problem is solved to find the combinations of shocks with the smallest magnitude to match the conditions.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as conditions. Note that you cannot condition variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which you specify conditions and all other variables are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing} = nothing</code>]: known values of shocks. This entry allows the user to include certain shock values. By entering restrictions on the shock sin this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the repective period. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of shocks and the second dimension to the number of periods. The shocks can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as certain shock values. Note that you cannot condition shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which you specify values and all other shocks are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model and is relevant for normal IRFs. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in devations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and initial state is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the non stochastic steady state substracted.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling
using SparseArrays, AxisKeys

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end


@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)
conditions[1,1] = .01
conditions[2,2] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

get_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_shocks ‚àà 9-element Vector{Symbol}
‚Üí   Periods ‚àà 42-element UnitRange{Int64}
And data, 9√ó42 Matrix{Float64}:
                (1)            (2)           ‚Ä¶  (41)            (42)
  (:A)            0.0313639      0.0134792         0.000221372     0.000199235
  (:Pi)           0.000780257    0.00020929       -0.000146071    -0.000140137
  (:R)            0.00117156     0.00031425       -0.000219325    -0.000210417
  (:c)            0.01           0.00600605        0.00213278      0.00203751
  (:k)            0.034584       0.0477482   ‚Ä¶     0.0397631       0.0380482
  (:y)            0.0446375      0.02              0.00129544      0.001222
  (:z_delta)      0.00025        0.000225          3.69522e-6      3.3257e-6
  (:delta_eps)    0.05           0.0               0.0             0.0
  (:eps_z)        4.61234       -2.16887           0.0             0.0

# The same can be achieved with the other input formats:
# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# using SparseArrays
# conditions = spzeros(7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])
# shocks[1,1] = .05

# using SparseArrays
# shocks = spzeros(2,1)
# shocks[1,1] = .05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_conditional_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_conditional_variance_decomposition(
    ùìÇ;
    periods,
    parameters,
    verbose
)
</code></pre><p>Return the conditional variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>[1:20...,Inf]</code>, Type: <code>Union{Vector{Int},Vector{Float64},UnitRange{Int64}}</code>]: vector of periods for which to calculate the conditional variance decomposition. If the vector conatins <code>Inf</code>, also the unconditional variance decomposition is calculated (same output as <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_variance_decomposition</code></a>).</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end


@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_conditional_variance_decomposition(RBC_CME)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 7-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
‚ó™   Periods ‚àà 21-element Vector{Float64}
And data, 7√ó2√ó21 Array{Float64, 3}:
[showing 3 of 21 slices]
[:, :, 1] ~ (:, :, 1.0):
              (:delta_eps)  (:eps_z)
  (:A)         0.0           1.0
  (:Pi)        0.00158668    0.998413
  (:R)         0.00158668    0.998413
  (:c)         0.0277348     0.972265
  (:k)         0.00869568    0.991304
  (:y)         0.0           1.0
  (:z_delta)   1.0           0.0

[:, :, 11] ~ (:, :, 11.0):
              (:delta_eps)  (:eps_z)
  (:A)         5.88653e-32   1.0
  (:Pi)        0.0245641     0.975436
  (:R)         0.0245641     0.975436
  (:c)         0.0175249     0.982475
  (:k)         0.00869568    0.991304
  (:y)         7.63511e-5    0.999924
  (:z_delta)   1.0           0.0

[:, :, 21] ~ (:, :, Inf):
              (:delta_eps)  (:eps_z)
  (:A)         9.6461e-31    1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_corr" href="#MacroModelling.get_corr"><code>MacroModelling.get_corr</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2075-L2077">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_correlation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_correlation(ùìÇ; parameters, algorithm, verbose)
</code></pre><p>Return the correlations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_correlation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   ùëâùëéùëüùëñùëéùëèùëôùëíùë† ‚àà 4-element Vector{Symbol}
And data, 4√ó4 Matrix{Float64}:
        (:c)       (:k)       (:q)       (:z)
  (:c)   1.0        0.999812   0.550168   0.314562
  (:k)   0.999812   1.0        0.533879   0.296104
  (:q)   0.550168   0.533879   1.0        0.965726
  (:z)   0.314562   0.296104   0.965726   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2001">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_cov" href="#MacroModelling.get_cov"><code>MacroModelling.get_cov</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2637-L2639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_covariance-Tuple" href="#MacroModelling.get_covariance-Tuple"><code>MacroModelling.get_covariance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2631-L2633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_dynamic_auxilliary_variables-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_dynamic_auxilliary_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_dynamic_auxilliary_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dynamic_auxilliary_variables(ùìÇ)
</code></pre><p>Returns the auxilliary variables, without timing subscripts, part of the augmented system of equations describing the model dynamics. Augmented means that, in case of variables with leads or lags larger than 1, or exogenous shocks with leads or lags, the system is augemented by auxilliary variables containing variables or shocks in lead or lag. because the original equations included variables with leads or lags certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxilliary variable is created for <code>c/q</code>).</p><p>See <code>get_dynamic_equations</code> for more details on the auxilliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_dynamic_auxilliary_variables(RBC)
# output
3-element Vector{String}:
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_dynamic_equations-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_dynamic_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_dynamic_equations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dynamic_equations(ùìÇ)
</code></pre><p>Return the augmented system of equations describing the model dynamics. Augmented means that, in case of variables with leads or lags larger than 1, or exogenous shocks with leads or lags, the system is augemented by auxilliary equations containing variables in lead or lag. The augmented system features only variables which are in the present <code>[0]</code>, future <code>[1]</code>, or past <code>[-1]</code>. For example, <code>Œîk_4q[0] = log(k[0]) - log(k[-3])</code> contains <code>k[-3]</code>. By introducing 2 auxilliary variables (<code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ</code> and <code>k·¥∏‚ÅΩ‚Åª¬≤‚Åæ</code> with <code>·¥∏</code> being the lead/lag operator) and augmenting the system (<code>k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[0] = k·¥∏‚ÅΩ‚Åª¬π‚Åæ[-1]</code> and <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] = k[-1]</code>) we can ensure that the timing is smaller than 1 in absolute terms: <code>Œîk_4q[0] - (log(k[0]) - log(k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[-1]))</code>.</p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the ouput assumes the equations are equal to 0. As in, <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1]</code> implies <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1] = 0</code> and therefore: <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] = k[-1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_dynamic_equations(RBC)
# output
12-element Vector{String}:
 &quot;1 / c[0] - (Œ≤ / c[1]) * (Œ± * ex&quot; ‚ãØ 25 bytes ‚ãØ &quot; - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))&quot;
 &quot;(c[0] + k[0]) - ((1 - exp(z{Œ¥}[0]) * Œ¥) * k[-1] + q[0])&quot;
 &quot;q[0] - exp(z{TFP}[0]) * k[-1] ^ Œ±&quot;
 &quot;eps_news{TFP}[0] - eps_news{TFP}[x]&quot;
 &quot;z{TFP}[0] - (œÅ{TFP} * z{TFP}[-1] + œÉ{TFP} * (eps{TFP}[x] + eps_news{TFP}[-1]))&quot;
 &quot;eps_news{Œ¥}[0] - eps_news{Œ¥}[x]&quot;
 &quot;z{Œ¥}[0] - (œÅ{Œ¥} * z{Œ¥}[-1] + œÉ{Œ¥} * (eps{Œ¥}[x] + eps_news{Œ¥}[-1]))&quot;
 &quot;Œîc_share[0] - (log(c[0] / q[0]) - log(c[-1] / q[-1]))&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ[0] - k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[-1]&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[0] - k·¥∏‚ÅΩ‚Åª¬π‚Åæ[-1]&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1]&quot;
 &quot;Œîk_4q[0] - (log(k[0]) - log(k·¥∏‚ÅΩ‚Åª¬≥‚Åæ[-1]))&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_equations-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_equations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_equations(ùìÇ)
</code></pre><p>Return the equations of the model. In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_equations(RBC)
# output
7-element Vector{String}:
 &quot;1 / c[0] = (Œ≤ / c[1]) * (Œ± * ex&quot; ‚ãØ 25 bytes ‚ãØ &quot; - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))&quot;
 &quot;c[0] + k[0] = (1 - exp(z{Œ¥}[0]) * Œ¥) * k[-1] + q[0]&quot;
 &quot;q[0] = exp(z{TFP}[0]) * k[-1] ^ Œ±&quot;
 &quot;z{TFP}[0] = œÅ{TFP} * z{TFP}[-1]&quot; ‚ãØ 18 bytes ‚ãØ &quot;TFP}[x] + eps_news{TFP}[x - 1])&quot;
 &quot;z{Œ¥}[0] = œÅ{Œ¥} * z{Œ¥}[-1] + œÉ{Œ¥} * (eps{Œ¥}[x] + eps_news{Œ¥}[x - 1])&quot;
 &quot;Œîc_share[0] = log(c[0] / q[0]) - log(c[-1] / q[-1])&quot;
 &quot;Œîk_4q[0] = log(k[0]) - log(k[-4])&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_shocks-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_shocks-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_shocks</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_estimated_shocks(
    ùìÇ,
    data;
    parameters,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    smooth,
    verbose
)
</code></pre><p>Return the estimated shocks based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>warmup_iterations</code> [Default: <code>0</code>, Type: <code>Int</code>]: periods added before the first observation for which shocks are computed such that the first observation is matched. A larger value alleviates the problem that the initial value is the relevant steady state.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non stochastic steady state substracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks. Only works for the Kalman filter. The inversion filter only returns filtered shocks.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_shocks(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Shocks ‚àà 1-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 1√ó40 Matrix{Float64}:
               (1)          (2)         (3)         (4)         ‚Ä¶  (37)         (38)        (39)         (40)
  (:eps_z‚Çç‚Çì‚Çé)    0.0603617    0.614652   -0.519048    0.711454       -0.873774     1.27918    -0.929701    -0.2255</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variable_standard_deviations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_estimated_variable_standard_deviations(
    ùìÇ,
    data;
    parameters,
    data_in_levels,
    smooth,
    verbose
)
</code></pre><p>Return the standard deviations of the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) estimates of the model variables based on the provided data and first order solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non stochastic steady state substracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks. Only works for the Kalman filter. The inversion filter only returns filtered shocks.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_variable_standard_deviations(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Standard_deviations ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó40 Matrix{Float64}:
        (1)           (2)            (3)            (4)            ‚Ä¶  (38)            (39)            (40)
  (:c)    1.23202e-9    1.84069e-10    8.23181e-11    8.23181e-11        8.23181e-11     8.23181e-11     0.0
  (:k)    0.00509299    0.000382934    2.87922e-5     2.16484e-6         1.6131e-9       9.31323e-10     1.47255e-9
  (:q)    0.0612887     0.0046082      0.000346483    2.60515e-5         1.31709e-9      1.31709e-9      9.31323e-10
  (:z)    0.00961766    0.000723136    5.43714e-5     4.0881e-6          3.08006e-10     3.29272e-10     2.32831e-10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_variables-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_variables-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_estimated_variables(
    ùìÇ,
    data;
    parameters,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    levels,
    smooth,
    verbose
)
</code></pre><p>Return the estimated variables (in levels by default, see <code>levels</code> keyword argument) based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>warmup_iterations</code> [Default: <code>0</code>, Type: <code>Int</code>]: periods added before the first observation for which shocks are computed such that the first observation is matched. A larger value alleviates the problem that the initial value is the relevant steady state.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non stochastic steady state substracted.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks. Only works for the Kalman filter. The inversion filter only returns filtered shocks.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_variables(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó40 Matrix{Float64}:
        (1)           (2)           (3)           (4)          ‚Ä¶  (37)          (38)            (39)           (40)
  (:c)    5.92901       5.92797       5.92847       5.92048          5.95845       5.95697         5.95686        5.96173
  (:k)   47.3185       47.3087       47.3125       47.2392          47.6034       47.5969         47.5954        47.6402
  (:q)    6.87159       6.86452       6.87844       6.79352          7.00476       6.9026          6.90727        6.95841
  (:z)   -0.00109471   -0.00208056    4.43613e-5   -0.0123318        0.0162992     0.000445065     0.00119089     0.00863586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_fevd" href="#MacroModelling.get_fevd"><code>MacroModelling.get_fevd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1864-L1866">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_first_order_solution-Tuple" href="#MacroModelling.get_first_order_solution-Tuple"><code>MacroModelling.get_first_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :first_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1620-L1622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_forecast_error_variance_decomposition" href="#MacroModelling.get_forecast_error_variance_decomposition"><code>MacroModelling.get_forecast_error_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1870-L1872">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_girf-Tuple" href="#MacroModelling.get_girf-Tuple"><code>MacroModelling.get_girf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a> with <code>shocks = :simulate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1209-L1211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}" href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ,
    parameters;
    periods,
    variables,
    shocks,
    negative_shock,
    initial_state,
    levels,
    verbose
)
</code></pre><p>Return impulse response functions (IRFs) of the model in a 3-dimensional array. Function to use when differentiating IRFs with repect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>parameters</code> [Type: <code>Vector</code>]: Parameter values in alphabetical order (sorted by parameter name).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>:all_excluding_obc</code> will contain all shocks but not the obc related ones.<code>:all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: provide state (in levels, not deviations) from which to start IRFs. Relevant for normal IRFs. The state includes all variables as well as exogenous variables in leads or lags if present.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_irf(RBC, RBC.parameter_values)
# output
4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] =
 0.00674687  0.00729773  0.00715114  0.00687615  ‚Ä¶  0.00146962   0.00140619
 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453
 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615
 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L766">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ;
    periods,
    algorithm,
    parameters,
    variables,
    shocks,
    negative_shock,
    generalised_irf,
    initial_state,
    levels,
    ignore_obc,
    verbose
)
</code></pre><p>Return impulse response functions (IRFs) of the model in a 3-dimensional KeyedArray. By default (see <code>levels</code>), the values represent absolute deviations from the relevant steady state (e.g. higher order perturbation algorithms are relative to the stochastic steady state).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>:all_excluding_obc</code> will contain all shocks but not the obc related ones.<code>:all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model and is relevant for normal IRFs. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in devations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and initial state is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_irf(RBC)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
‚ó™   Shocks ‚àà 1-element Vector{Symbol}
And data, 4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :eps_z):
        (1)           (2)           ‚Ä¶  (39)            (40)
  (:c)    0.00674687    0.00729773        0.00146962      0.00140619
  (:k)    0.0620937     0.0718322         0.0146789       0.0140453
  (:q)    0.0688406     0.0182781         0.00111425      0.00106615
  (:z)    0.01          0.002             2.74878e-29     5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L909">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irfs" href="#MacroModelling.get_irfs"><code>MacroModelling.get_irfs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1169-L1171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_jump_variables-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_jump_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_jump_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_jump_variables(ùìÇ)
</code></pre><p>Returns the jump variables of the model. Jumper variables occur in the future and not in the past or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_jump_variables(RBC)
# output
3-element Vector{String}:
 &quot;c&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_loglikelihood-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}, Vector{S}}} where S" href="#MacroModelling.get_loglikelihood-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}, Vector{S}}} where S"><code>MacroModelling.get_loglikelihood</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_loglikelihood(
    ùìÇ,
    data,
    parameter_values;
    algorithm,
    filter,
    warmup_iterations,
    tol,
    verbose
)
</code></pre><p>Return the loglikelihood of the model given the data and parameters provided. The loglikelihood is either calculated based on the inversion or the Kalman filter (depending on the <code>filter</code> keyword argument). In case of a nonlinear solution algorithm the inversion filter will be used. The data must be provided as a <code>KeyedArray{Float64}</code> with the names of the variables to be matched in rows and the periods in columns.</p><p>This function is differentiable (so far for the Kalman filter only) and can be used in gradient based sampling or optimisation.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>warmup_iterations</code> [Default: <code>0</code>, Type: <code>Int</code>]: periods added before the first observation for which shocks are computed such that the first observation is matched. A larger value alleviates the problem that the initial value is the relevant steady state.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulated_data = simulate(RBC)

get_loglikelihood(RBC, simulated_data([:k], :, :simulate), RBC.parameter_values)
# output
58.24780188977981</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2841">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_mean-Tuple" href="#MacroModelling.get_mean-Tuple"><code>MacroModelling.get_mean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>mean = true</code>, and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false, covariance = false</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2649-L2651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_moments</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_moments(
    ùìÇ;
    parameters,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    variables,
    derivatives,
    parameter_derivatives,
    algorithm,
    dependencies_tol,
    verbose,
    silent
)
</code></pre><p>Return the first and second moments of endogenous variables using the first, pruned second, or pruned third order perturbation solution. By default returns: non stochastic steady state (SS), and standard deviations, but can optionally return variances, and covariance matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>non_stochastic_steady_state</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return SS of endogenous variables</li><li><code>mean</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return mean of endogenous variables (the mean for the linearised solutoin is the NSSS)</li><li><code>standard_deviation</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return standard deviation of endogenous variables</li><li><code>variance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return variance of endogenous variables</li><li><code>covariance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return covariance matrix of endogenous variables</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>dependencies_tol</code> [Default: <code>1e-12</code>, Type: <code>AbstractFloat</code>]: tolerance for the effect of a variable on the variable of interest when isolating part of the system for calculating covariance related statistics</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

moments = get_moments(RBC);

moments[1]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre><pre><code class="language-julia hljs">moments[2]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Standard_deviation)  (:std_z)  ‚Ä¶  (:Œ¥)       (:Œ±)       (:Œ≤)
  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789
  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323
  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08
  (:z)   0.0102062              1.02062      0.0        0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_non_stochastic_steady_state-Tuple" href="#MacroModelling.get_non_stochastic_steady_state-Tuple"><code>MacroModelling.get_non_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1421-L1423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_nonnegativity_auxilliary_variables-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_nonnegativity_auxilliary_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_nonnegativity_auxilliary_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nonnegativity_auxilliary_variables(ùìÇ)
</code></pre><p>Returns the auxilliary variables, without timing subscripts, added to the non-stochastic steady state problem because certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxilliary variable is created for <code>c/q</code>).</p><p>See <code>get_steady_state_equations</code> for more details on the auxilliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_nonnegativity_auxilliary_variables(RBC)
# output
2-element Vector{String}:
 &quot;‚ûï‚ÇÅ&quot;
 &quot;‚ûï‚ÇÇ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_parameters(ùìÇ; values)
</code></pre><p>Returns the parameters (and optionally the values) which have an impact on the model dynamics but do not depend on other parameters and are not determined by calibration equations. </p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>œÉ</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters(RBC)
# output
7-element Vector{String}:
 &quot;œÉ{TFP}&quot;
 &quot;œÉ{Œ¥}&quot;
 &quot;œÅ{TFP}&quot;
 &quot;œÅ{Œ¥}&quot;
 &quot;capital_to_output&quot;
 &quot;alpha&quot;
 &quot;Œ≤&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_defined_by_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_parameters_defined_by_parameters(ùìÇ)
</code></pre><p>Returns the parameters which are defined by other parameters which are not necessarily used in the equations of the model (see <code>Œ±</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_defined_by_parameters(RBC)
# output
1-element Vector{String}:
 &quot;Œ±&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_defining_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_parameters_defining_parameters(ùìÇ)
</code></pre><p>Returns the parameters which define other parameters in the <code>@parameters</code> block which are not necessarily used in the equations of the model (see <code>alpha</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_defining_parameters(RBC)
# output
1-element Vector{String}:
 &quot;alpha&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_in_equations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_parameters_in_equations(ùìÇ)
</code></pre><p>Returns the parameters contained in the model equations. Note that these parameters might be determined by other parameters or calibration equations defined in the <code>@parameters</code> block.</p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>œÉ</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_in_equations(RBC)
# output
7-element Vector{String}:
 &quot;Œ±&quot;
 &quot;Œ≤&quot;
 &quot;Œ¥&quot;
 &quot;œÅ{TFP}&quot;
 &quot;œÅ{Œ¥}&quot;
 &quot;œÉ{TFP}&quot;
 &quot;œÉ{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_perturbation_solution-Tuple" href="#MacroModelling.get_perturbation_solution-Tuple"><code>MacroModelling.get_perturbation_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>See <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1635-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_second_order_solution-Tuple" href="#MacroModelling.get_second_order_solution-Tuple"><code>MacroModelling.get_second_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :second_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1625-L1627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_shock_decomposition-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}" href="#MacroModelling.get_shock_decomposition-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_shock_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_shock_decomposition(
    ùìÇ,
    data;
    parameters,
    data_in_levels,
    smooth,
    verbose
)
</code></pre><p>Return the shock decomposition in absolute deviations from the non stochastic steady state based on the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) using the provided data and first order solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non stochastic steady state substracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks. Only works for the Kalman filter. The inversion filter only returns filtered shocks.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_shock_decomposition(RBC,simulation([:c],:,:simulate))
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
‚ó™   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó2√ó40 Array{Float64, 3}:
[showing 3 of 40 slices]
[:, :, 1] ~ (:, :, 1):
        (:eps_z‚Çç‚Çì‚Çé)   (:Initial_values)
  (:c)   0.000407252  -0.00104779
  (:k)   0.00374808   -0.0104645
  (:q)   0.00415533   -0.000807161
  (:z)   0.000603617  -1.99957e-6

[:, :, 21] ~ (:, :, 21):
        (:eps_z‚Çç‚Çì‚Çé)  (:Initial_values)
  (:c)   0.026511    -0.000433619
  (:k)   0.25684     -0.00433108
  (:q)   0.115858    -0.000328764
  (:z)   0.0150266    0.0

[:, :, 40] ~ (:, :, 40):
        (:eps_z‚Çç‚Çì‚Çé)  (:Initial_values)
  (:c)   0.0437976   -0.000187505
  (:k)   0.4394      -0.00187284
  (:q)   0.00985518  -0.000142164
  (:z)  -0.00366442   8.67362e-19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_shocks-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_shocks-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_shocks</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_shocks(ùìÇ)
</code></pre><p>Returns the exogenous shocks.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>eps</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_shocks(RBC)
# output
4-element Vector{String}:
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{Œ¥}&quot;
 &quot;eps{TFP}&quot;
 &quot;eps{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_simulation-Tuple" href="#MacroModelling.get_simulation-Tuple"><code>MacroModelling.get_simulation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1199-L1201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_simulations-Tuple" href="#MacroModelling.get_simulations-Tuple"><code>MacroModelling.get_simulations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1204-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_solution(ùìÇ; parameters, algorithm, verbose)
</code></pre><p>Return the solution of the model. In the linear case it returns the linearised solution and the non stochastic steady state (NSSS) of the model. In the nonlinear case (higher order perturbation) the function returns a multidimensional array with the endogenous variables as the second dimension and the state variables, shocks, and perturbation parameter (:Volatility) in the case of higher order solutions as the other dimensions.</p><p>The values of the output represent the NSSS in the case of a linear solution and below it the effect that deviations from the NSSS of the respective past states, shocks, and perturbation parameter have (perturbation parameter = 1) on the present value (NSSS deviation) of the model variables.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p>The returned <code>KeyedArray</code> shows as columns the endogenous variables inlcuding the auxilliary endogenous and exogenous variables (due to leads and lags &gt; 1). The rows and other dimensions (depending on the chosen perturbation order) include the NSSS for the linear case only, followed by the states, and exogenous shocks.  Subscripts following variable names indicate the timing (e.g. <code>variable‚Çç‚Çã‚ÇÅ‚Çé</code>  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. <code>variable·¥∏‚ÅΩ¬≤‚Åæ</code> indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_solution(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Steady_state__States__Shocks ‚àà 4-element Vector{Symbol}
‚Üí   Variables ‚àà 4-element Vector{Symbol}
And data, 4√ó4 adjoint(::Matrix{Float64}) with eltype Float64:
                   (:c)         (:k)        (:q)        (:z)
  (:Steady_state)   5.93625     47.3903      6.88406     0.0
  (:k‚Çç‚Çã‚ÇÅ‚Çé)          0.0957964    0.956835    0.0726316  -0.0
  (:z‚Çç‚Çã‚ÇÅ‚Çé)          0.134937     1.24187     1.37681     0.2
  (:eps_z‚Çç‚Çì‚Çé)       0.00674687   0.0620937   0.0688406   0.01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_ss" href="#MacroModelling.get_ss"><code>MacroModelling.get_ss</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1467-L1469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_standard_deviation-Tuple" href="#MacroModelling.get_standard_deviation-Tuple"><code>MacroModelling.get_standard_deviation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2603-L2605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_state_variables-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_state_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_state_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_state_variables(ùìÇ)
</code></pre><p>Returns the state variables of the model. State variables occur in the past and not in the future or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_state_variables(RBC)
# output
10-element Vector{String}:
 &quot;c&quot;
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{Œ¥}&quot;
 &quot;k&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_statistics-Union{Tuple{T}, Tuple{U}, Tuple{Any, Vector{T}}} where {U, T}" href="#MacroModelling.get_statistics-Union{Tuple{T}, Tuple{U}, Tuple{Any, Vector{T}}} where {U, T}"><code>MacroModelling.get_statistics</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_statistics(
    ùìÇ,
    parameter_values;
    parameters,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    autocorrelation,
    autocorrelation_periods,
    algorithm,
    verbose
)
</code></pre><p>Return the first and second moments of endogenous variables using either the linearised solution or the pruned second or third order perturbation solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Type: <code>Vector{Symbol}</code>]: Corresponding names of parameters values.</li><li><code>non_stochastic_steady_state</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the SS of endogenous variables</li><li><code>mean</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the mean of endogenous variables (the mean for the linearised solutoin is the NSSS)</li><li><code>standard_deviation</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the standard deviation of the mentioned variables</li><li><code>variance</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the variance of the mentioned variables</li><li><code>covariance</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the covariance of the mentioned variables</li><li><code>autocorrelation</code> [Default: <code>Symbol[]</code>, Type: <code>Vector{Symbol}</code>]: if values are provided the function returns the autocorrelation of the mentioned variables</li><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>]: periods for which to return the autocorrelation of the mentioned variables</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_statistics(RBC, RBC.parameter_values, parameters = RBC.parameters, standard_deviation = RBC.var)
# output
1-element Vector{Any}:
 [0.02666420378525503, 0.26467737291221793, 0.07393254045396483, 0.010206207261596574]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_std" href="#MacroModelling.get_std"><code>MacroModelling.get_std</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2609-L2611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_stdev" href="#MacroModelling.get_stdev"><code>MacroModelling.get_stdev</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2614-L2616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_steady_state(
    ùìÇ;
    parameters,
    derivatives,
    stochastic,
    algorithm,
    parameter_derivatives,
    return_variables_only,
    verbose,
    silent,
    tol
)
</code></pre><p>Return the (non stochastic) steady state, calibrated parameters, and derivatives with respect to model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>stochastic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return stochastic steady state using second order perturbation</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>return_variables_only</code> [Defaut: <code>false</code>, Type: <code>Bool</code>]: return only variables and not calibrated parameters</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p>The columns show the (non stochastic) steady state and parameters for which derivatives are taken. The rows show the variables and calibrated parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_steady_state(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_calibrated_parameters ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_steady_state_equations-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_steady_state_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_steady_state_equations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_steady_state_equations(ùìÇ)
</code></pre><p>Return the non-stochastic steady state (NSSS) equations of the model. The difference to the equations as they were written in the <code>@model</code> block is that exogenous shocks are set to <code>0</code>, time subscripts are eliminated (e.g. <code>c[-1]</code> becomes <code>c</code>), trivial simplifications are carried out (e.g. <code>log(k) - log(k) = 0</code>), and auxilliary variables are added for expressions that cannot become negative. </p><p>Auxilliary variables facilitate the solution of the NSSS problem. The package substitutes expressions which cannot become negative with auxilliary variables and adds another equation to the system of equations determining the NSSS. For example, <code>log(c/q)</code> cannot be negative and <code>c/q</code> is substituted by an auxilliary varaible <code>‚ûï‚ÇÅ</code> and an additional equation is added: <code>‚ûï‚ÇÅ = c / q</code>.</p><p>Note that the ouput assumes the equations are equal to 0. As in, <code>-z{Œ¥} * œÅ{Œ¥} + z{Œ¥}</code> implies <code>-z{Œ¥} * œÅ{Œ¥} + z{Œ¥} = 0</code> and therefore: <code>z{Œ¥} * œÅ{Œ¥} = z{Œ¥}</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_steady_state_equations(RBC)
# output
9-element Vector{String}:
 &quot;(-Œ≤ * ((k ^ (Œ± - 1) * Œ± * exp(z{TFP}) - Œ¥ * exp(z{Œ¥})) + 1)) / c + 1 / c&quot;
 &quot;((c - k * (-Œ¥ * exp(z{Œ¥}) + 1)) + k) - q&quot;
 &quot;-(k ^ Œ±) * exp(z{TFP}) + q&quot;
 &quot;-z{TFP} * œÅ{TFP} + z{TFP}&quot;
 &quot;-z{Œ¥} * œÅ{Œ¥} + z{Œ¥}&quot;
 &quot;‚ûï‚ÇÅ - c / q&quot;
 &quot;‚ûï‚ÇÇ - c / q&quot;
 &quot;(Œîc_share - log(‚ûï‚ÇÅ)) + log(‚ûï‚ÇÇ)&quot;
 &quot;Œîk_4q - 0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_stochastic_steady_state-Tuple" href="#MacroModelling.get_stochastic_steady_state-Tuple"><code>MacroModelling.get_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1427-L1429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_third_order_solution-Tuple" href="#MacroModelling.get_third_order_solution-Tuple"><code>MacroModelling.get_third_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :third_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1630-L1632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_var" href="#MacroModelling.get_var"><code>MacroModelling.get_var</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2591-L2593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_var_decomp" href="#MacroModelling.get_var_decomp"><code>MacroModelling.get_var_decomp</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1993-L1995">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variables-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_variables</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_variables(ùìÇ)
</code></pre><p>Returns the variables of the model without timing subscripts and not including auxilliary variables.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_variables(RBC)
# output
7-element Vector{String}:
 &quot;c&quot;
 &quot;k&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;
 &quot;Œîc_share&quot;
 &quot;Œîk_4q&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/inspect.jl#L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variance-Tuple" href="#MacroModelling.get_variance-Tuple"><code>MacroModelling.get_variance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2585-L2587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_variance_decomposition(ùìÇ; parameters, verbose)
</code></pre><p>Return the variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end


@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_variance_decomposition(RBC_CME)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 7-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
And data, 7√ó2 Matrix{Float64}:
              (:delta_eps)  (:eps_z)
  (:A)         9.78485e-31   1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1885">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.gr_backend" href="#MacroModelling.gr_backend"><code>MacroModelling.gr_backend</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gr_backend()</code></pre><p>Renaming and reexport of Plot.jl function <code>gr()</code> to define GR.jl as backend</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.import_dynare" href="#MacroModelling.import_dynare"><code>MacroModelling.import_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L119-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.import_model" href="#MacroModelling.import_model"><code>MacroModelling.import_model</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L114-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_IRF" href="#MacroModelling.plot_IRF"><code>MacroModelling.plot_IRF</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L754-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}" href="#MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.plot_conditional_forecast</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_conditional_forecast(
    ùìÇ,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    variables,
    conditions_in_levels,
    algorithm,
    levels,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    verbose
)
</code></pre><p>Plot conditional forecast given restrictions on endogenous variables and shocks (optional) of the model. The algorithm finds the combinations of shocks with the smallest magnitude to match the conditions and plots both the endogenous variables and shocks.</p><p>The left axis shows the level, and the right axis the deviation from the (non) stochastic steady state, depending on the solution algorithm (e.g. higher order perturbation algorithms will show the stochastic steady state). Variable names are above the subplots, conditioned values are marked, and the title provides information about the model, and number of pages.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as conditions. Note that you cannot condition variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which you specify conditions and all other variables are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing} = nothing</code>]: known values of shocks. This entry allows the user to include certain shock values. By entering restrictions on the shock sin this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the repective period. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of shocks and the second dimension to the number of periods. The shocks can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as certain shock values. Note that you cannot condition shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which you specify values and all other shocks are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model and is relevant for normal IRFs. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in devations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and initial state is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li></ul><p><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the non stochastic steady state substracted.</p><ul><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)
conditions[1,1] = .01
conditions[2,2] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

plot_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)

# The same can be achieved with the other input formats:
# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# using SparseArrays
# conditions = spzeros(7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])
# shocks[1,1] = .05

# using SparseArrays
# shocks = spzeros(2,1)
# shocks[1,1] = .05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L1276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot_conditional_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_conditional_variance_decomposition(
    ùìÇ;
    periods,
    variables,
    parameters,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    verbose
)
</code></pre><p>Plot conditional variance decomposition of the model.</p><p>The vertical axis shows the share of the shocks variance contribution, and horizontal axis the period of the variance decomposition. The stacked bars represent each shocks variance contribution at a specific time horizon.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

plot_conditional_variance_decomposition(RBC_CME)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L786">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_fevd" href="#MacroModelling.plot_fevd"><code>MacroModelling.plot_fevd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>plot_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L944-L946">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_forecast_error_variance_decomposition" href="#MacroModelling.plot_forecast_error_variance_decomposition"><code>MacroModelling.plot_forecast_error_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>plot_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L949-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_girf-Tuple" href="#MacroModelling.plot_girf-Tuple"><code>MacroModelling.plot_girf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>generalised_irf = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L777-L779">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot_irf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_irf(
    ùìÇ;
    periods,
    shocks,
    variables,
    parameters,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    algorithm,
    negative_shock,
    generalised_irf,
    initial_state,
    ignore_obc,
    verbose
)
</code></pre><p>Plot impulse response functions (IRFs) of the model.</p><p>The left axis shows the level, and the right the deviation from the reference steady state. Linear solutions have the non stochastic steady state as reference other solution the stochastic steady state. The horizontal black line indicates the reference steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.</li><li><code>shocks</code> [Default: <code>:all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>:all_excluding_obc</code> will contain all shocks but not the obc related ones.<code>:all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model and is relevant for normal IRFs. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in devations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and initial state is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

plot_irf(RBC)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_irfs" href="#MacroModelling.plot_irfs"><code>MacroModelling.plot_irfs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L760-L762">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}" href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.plot_model_estimates</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_model_estimates(
    ùìÇ,
    data;
    parameters,
    algorithm,
    filter,
    warmup_iterations,
    variables,
    shocks,
    data_in_levels,
    shock_decomposition,
    smooth,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    transparency,
    verbose
)
</code></pre><p>Plot model estimates of the variables given the data. The default plot shows the estimated variables, shocks, and the data to estimate the former. The left axis shows the level, and the right the deviation from the reference steady state. The horizontal black line indicates the non stochastic steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.</p><p>In case <code>shock_decomposition = true</code>, then the plot shows the variables, shocks, and data in absolute deviations from the non stochastic steady state plus the contribution of the shocks as a stacked bar chart per period.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to plot the estimates. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code>, or <code>:all</code>), <code>Tuple{Symbol, Vararg{Symbol}}</code>, <code>Matrix{Symbol}</code>, or <code>Vector{Symbol}</code>.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non stochastic steady state substracted.</li><li><code>shock_decomposition</code> [Default: <code>false</code>, Type: <code>Bool</code>]: whether to show the contribution of the shocks to the deviations from NSSS for each variable. If <code>false</code>, the plot shows the values of the selected variables, data, and shocks</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks. Only works for the Kalman filter. The inversion filter only returns filtered shocks.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>transparency</code> [Default: <code>0.6</code>, Type: <code>Float64</code>]: transparency of bars</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots


@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

simulation = simulate(RBC_CME)

plot_model_estimates(RBC_CME, simulation([:k],:,:simulate))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_shock_decomposition-Tuple" href="#MacroModelling.plot_shock_decomposition-Tuple"><code>MacroModelling.plot_shock_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>plot_model_estimates</code></a> with <code>shock_decomposition = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L321-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_simulation-Tuple" href="#MacroModelling.plot_simulation-Tuple"><code>MacroModelling.plot_simulation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L771-L773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_simulations-Tuple" href="#MacroModelling.plot_simulations-Tuple"><code>MacroModelling.plot_simulations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L766-L768">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plot_solution-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}" href="#MacroModelling.plot_solution-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}"><code>MacroModelling.plot_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution(
    ùìÇ,
    state;
    variables,
    algorithm,
    œÉ,
    parameters,
    ignore_obc,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    verbose
)
</code></pre><p>Plot the solution of the model (mapping of past states to present variables) around the (non) stochastic steady state (depending on chosen solution algorithm). Each plot shows the relationship between the chosen state (defined in <code>state</code>) and one of the chosen variables (defined in <code>variables</code>). </p><p>The (non) stochastic steady state is plotted along with the mapping from the chosen past state to one present variable per plot. All other (non-chosen) states remain in the (non) stochastic steady state.</p><p>In the case of pruned solutions there as many (latent) state vectors as the perturbation order. The first and third order baseline state vectors are the non stochastic steady state and the second order baseline state vector is the stochastic steady state. Deviations for the chosen state are only added to the first order baseline state. The plot shows the mapping from <code>œÉ</code> standard deviations (first order) added to the first order non stochastic steady state and the present variables. Note that there is no unique mapping from the &quot;pruned&quot; states and the &quot;actual&quot; reported state. Hence, the plots shown are just one realisation of inifite possible mappings.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li><li><code>state</code> [Type: <code>Union{Symbol,String}</code>]: state variable to be shown on x-axis.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxilliary_and_obc</code> contains all shocks less those related to auxilliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxilliary variables. <code>:all</code> will contain all variables.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: Union{Symbol,Vector{Symbol}}]: solution algorithm for which to show the IRFs. Can be more than one, e.g.: <code>[:second_order,:pruned_third_order]</code>&quot;</li><li><code>œÉ</code> [Default: <code>2</code>, Type: <code>Union{Int64,Float64}</code>]: defines the range of the state variable around the (non) stochastic steady state in standard deviations. E.g. a value of 2 means that the state variable is plotted for values of the (non) stochastic steady state in standard deviations +/- 2 standard deviations.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

plot_solution(RBC_CME, :k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L958">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.plotlyjs_backend" href="#MacroModelling.plotlyjs_backend"><code>MacroModelling.plotlyjs_backend</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotlyjs_backend()</code></pre><p>Renaming and reexport of Plot.jl function <code>plotlyjs()</code> to define PlotlyJS.jl as backend</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/plotting.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.simulate-Tuple" href="#MacroModelling.simulate-Tuple"><code>MacroModelling.simulate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1194-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.ss-Tuple" href="#MacroModelling.ss-Tuple"><code>MacroModelling.ss</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1472-L1474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.sss-Tuple" href="#MacroModelling.sss-Tuple"><code>MacroModelling.sss</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1445-L1447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.std" href="#MacroModelling.std"><code>MacroModelling.std</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2626-L2628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.stdev" href="#MacroModelling.stdev"><code>MacroModelling.stdev</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2620-L2622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.steady_state" href="#MacroModelling.steady_state"><code>MacroModelling.steady_state</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L1457-L1459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.translate_dynare_file" href="#MacroModelling.translate_dynare_file"><code>MacroModelling.translate_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.translate_mod_file-Tuple{AbstractString}" href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>MacroModelling.translate_mod_file</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translate_mod_file(path_to_mod_file)
</code></pre><p>Reads in a <code>dynare</code> .mod-file, adapts the syntax, tries to capture parameter definitions, and writes a julia file in the same folder containing the model equations and parameters in <code>MacroModelling.jl</code> syntax. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>dynare</code> to <code>MacroModelling.jl</code>. </p><p>The recommended workflow is to use this function to translate a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p><strong>Arguments</strong></p><ul><li><code>path_to_mod_file</code> [Type: <code>AbstractString</code>]: path including filename of the .mod-file to be translated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.var" href="#MacroModelling.var"><code>MacroModelling.var</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/get_functions.jl#L2597-L2599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_dynare_file" href="#MacroModelling.write_dynare_file"><code>MacroModelling.write_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.write_mod_file</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_mod_file(m)
</code></pre><p>Writes a <code>dynare</code> .mod-file in the current working directory. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>MacroModelling.jl</code> to <code>dynare</code>. </p><p>The recommended workflow is to use this function to write a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> for which to get the solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_to_dynare" href="#MacroModelling.write_to_dynare"><code>MacroModelling.write_to_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L234-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_to_dynare_file" href="#MacroModelling.write_to_dynare_file"><code>MacroModelling.write_to_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/dynare.jl#L229-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.@model-Tuple{Any, Vararg{Any}}" href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@model</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>Parses the model equations and assigns them to an object.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object to be created containing the model information.</li><li><code>ex</code>: equations</li></ul><p><strong>Optional arguments to be placed between <code>ùìÇ</code> and <code>ex</code></strong></p><ul><li><code>max_obc_horizon</code> [Default: <code>40</code>, Type: <code>Int</code>]: maximum length of anticipated shocks and corresponding unconditional forecast horizon over which the occasionally binding constraint is to be enforced. Increase this number if no solution is found to enforce the constraint.</li></ul><p>Variables must be defined with their time subscript in squared brackets. Endogenous variables can have the following:</p><ul><li>present: <code>c[0]</code></li><li>non-stcohastic steady state: <code>c[ss]</code> instead of <code>ss</code> any of the following is also a valid flag for the non-stochastic steady state: <code>ss</code>, <code>stst</code>, <code>steady</code>, <code>steadystate</code>, <code>steady_state</code>, and the parser is case-insensitive (<code>SS</code> or <code>sTst</code> will work as well).</li><li>past: <code>c[-1]</code> or any negative Integer: e.g. <code>c[-12]</code></li><li>future: <code>c[1]</code> or any positive Integer: e.g. <code>c[16]</code> or <code>c[+16]</code></li></ul><p>Signed integers are recognised and parsed as such.</p><p>Exogenous variables (shocks) can have the following:</p><ul><li>present: <code>eps_z[x]</code> instead of <code>x</code> any of the following is also a valid flag for exogenous variables: <code>ex</code>, <code>exo</code>, <code>exogenous</code>, and the parser is case-insensitive (<code>Ex</code> or <code>exoGenous</code> will work as well).</li><li>past: <code>eps_z[x-1]</code></li><li>future: <code>eps_z[x+1]</code></li></ul><p>Parameters enter the equations without squared brackets.</p><p>If an equation contains a <code>max</code> or <code>min</code> operator, then the default dynamic (first order) solution of the model will enforce the occasionally binding constraint. You can choose to ignore it by setting <code>ignore_obc = true</code> in the relevant function calls.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Parameters and variables can be indexed using curly braces: e.g. <code>c{H}[0]</code>, <code>eps_z{F}[x]</code>, or <code>Œ±{H}</code>.</p><p><code>for</code> loops can be used to write models programmatically. They can either be used to generate expressions where you iterate over the time index or the index in curly braces:</p><ul><li>generate equation with different indices in curly braces: <code>for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end</code></li><li>generate multiple equations with different indices in curly braces: <code>for co in [H, F] K{co}[0] = (1-delta{co}) * K{co}[-1] + S{co}[0] end</code></li><li>generate equation with different time indices: <code>Y_annual[0] = for lag in -3:0 Y[lag] end</code> or <code>R_annual[0] = for operator = :*, lag in -3:0 R[lag] end</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/macros.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.@parameters-Tuple{Any, Vararg{Any}}" href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@parameters</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>Adds parameter values and calibration equations to the previously defined model.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object previously created containing the model information.</li><li><code>ex</code>: parameter, parameters values, and calibration equations</li></ul><p>Parameters can be defined in either of the following ways:</p><ul><li>plain number: <code>Œ¥ = 0.02</code></li><li>expression containing numbers: <code>Œ¥ = 1/50</code></li><li>expression containing other parameters: <code>Œ¥ = 2 * std_z</code> in this case it is irrelevant if <code>std_z</code> is defined before or after. The definitons including other parameters are treated as a system of equaitons and solved accordingly.</li><li>expressions containing a target parameter and an equations with endogenous variables in the non-stochastic steady state, and other parameters, or numbers: <code>k[ss] / (4 * q[ss]) = 1.5 | Œ¥</code> or <code>Œ± | 4 * q[ss] = Œ¥ * k[ss]</code> in this case the target parameter will be solved simultaneaously with the non-stochastic steady state using the equation defined with it.</li></ul><p><strong>Optional arguments to be placed between <code>ùìÇ</code> and <code>ex</code></strong></p><ul><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print more information about how the non stochastic steady state is solved</li><li><code>silent</code> [Default: <code>false</code>, Type: <code>Bool</code>]: do not print any information</li><li><code>symbolic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: try to solve the non stochastic steady state symbolically and fall back to a numerical solution if not possible</li><li><code>perturbation_order</code> [Default: <code>1</code>, Type: <code>Int</code>]: take derivatives only up to the specified order at this stage. In case you want to work with higher order perturbation later on, respective derivatives will be taken at that stage.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC verbose = true begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Variables and parameters indexed with curly braces can be either referenced specifically (e.g. <code>c{H}[ss]</code>) or generally (e.g. <code>alpha</code>). If they are referenced generaly the parse assumes all instances (indices) are meant. For example, in a model where <code>alpha</code> has two indices <code>H</code> and <code>F</code>, the expression <code>alpha = 0.3</code> is interpreted as two expressions: <code>alpha{H} = 0.3</code> and <code>alpha{F} = 0.3</code>. The same goes for calibration equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/772fa4d4ef49eb33ba08f0d775a51ab34e9569d9/src/macros.jl#L911">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how-to/obc/">¬´ Occasionally binding constraints</a><a class="docs-footer-nextpage" href="../call_index/">Index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 21 March 2024 00:13">Thursday 21 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
