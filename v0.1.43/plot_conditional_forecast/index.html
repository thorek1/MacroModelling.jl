<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conditional Forecasts ¬∑ MacroModelling.jl</title><meta name="title" content="Conditional Forecasts ¬∑ MacroModelling.jl"/><meta property="og:title" content="Conditional Forecasts ¬∑ MacroModelling.jl"/><meta property="twitter:title" content="Conditional Forecasts ¬∑ MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../plotting/">Overview</a></li><li><a class="tocitem" href="../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../plot_solution/">Policy Functions</a></li><li class="is-active"><a class="tocitem" href>Conditional Forecasts</a><ul class="internal"><li><a class="tocitem" href="#Combine-or-compare-conditional-forecasts-with-plot_conditional_forecast!"><span>Combine or compare conditional forecasts with <code>plot_conditional_forecast!</code></span></a></li><li><a class="tocitem" href="#Conditions-(Required)"><span>Conditions (Required)</span></a></li><li><a class="tocitem" href="#Shocks"><span>Shocks</span></a></li><li><a class="tocitem" href="#Solution-Algorithm"><span>Solution Algorithm</span></a></li><li><a class="tocitem" href="#Initial-State"><span>Initial State</span></a></li><li><a class="tocitem" href="#Simulation-Periods"><span>Simulation Periods</span></a></li><li><a class="tocitem" href="#Variables-to-Plot"><span>Variables to Plot</span></a></li><li><a class="tocitem" href="#Parameter-Values"><span>Parameter Values</span></a></li><li><a class="tocitem" href="#Conditions-in-levels"><span>Conditions in levels</span></a></li><li><a class="tocitem" href="#Plot-Labels"><span>Plot Labels</span></a></li><li><a class="tocitem" href="#Plot-Type"><span>Plot Type</span></a></li><li><a class="tocitem" href="#Plot-Attributes"><span>Plot Attributes</span></a></li><li><a class="tocitem" href="#Plots-Per-Page"><span>Plots Per Page</span></a></li><li><a class="tocitem" href="#Display-Plots"><span>Display Plots</span></a></li><li><a class="tocitem" href="#Saving-Plots"><span>Saving Plots</span></a></li><li><a class="tocitem" href="#Variable-and-Shock-Renaming-(rename-dictionary)"><span>Variable and Shock Renaming (rename dictionary)</span></a></li><li><a class="tocitem" href="#Verbose-Output"><span>Verbose Output</span></a></li><li><a class="tocitem" href="#Numerical-Tolerances"><span>Numerical Tolerances</span></a></li><li><a class="tocitem" href="#Quadratic-Matrix-Equation-Solver"><span>Quadratic Matrix Equation Solver</span></a></li><li><a class="tocitem" href="#Sylvester-Equation-Solver"><span>Sylvester Equation Solver</span></a></li></ul></li><li><a class="tocitem" href="../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../plot_model_estimates/">Model Estimates</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plotting</a></li><li class="is-active"><a href>Conditional Forecasts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conditional Forecasts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/plot_conditional_forecast.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conditional-Forecasting"><a class="docs-heading-anchor" href="#Conditional-Forecasting">Conditional Forecasting</a><a id="Conditional-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-Forecasting" title="Permalink"></a></h1><p>Conditional forecasting allows generating model projections conditional on future paths for endogenous variables or exogenous shocks. The conditions are fulfilled by contemporaneous shocks only and there is no effect today from conditions in the future. The <code>plot_conditional_forecast</code> function visualizes these conditional forecasts, showing how the model variables evolve.</p><p>First, define and load a model:</p><pre><code class="language-julia hljs">@model Gali_2015_chapter_3_nonlinear begin
    W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ
    Q[0] = Œ≤ * (C[1] / C[0]) ^ (-œÉ) * Z[1] / Z[0] / Pi[1]
    R[0] = 1 / Q[0]
    Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)
    R[0] = Pi[1] * realinterest[0]
    R[0] = 1 / Œ≤ * Pi[0] ^ œï·µñ‚Å± * (Y[0] / Y[ss]) ^ œï ∏ * exp(nu[0])
    C[0] = Y[0]
    log(A[0]) = œÅ_a * log(A[-1]) + std_a * eps_a[x]
    log(Z[0]) = œÅ_z * log(Z[-1]) - std_z * eps_z[x]
    nu[0] = œÅ_ŒΩ * nu[-1] + std_nu * eps_nu[x]
    MC[0] = W_real[0] / (S[0] * Y[0] * (1 - Œ±) / N[0])
    1 = Œ∏ * Pi[0] ^ (œµ - 1) + (1 - Œ∏) * Pi_star[0] ^ (1 - œµ)
    S[0] = (1 - Œ∏) * Pi_star[0] ^ (( - œµ) / (1 - Œ±)) + Œ∏ * Pi[0] ^ (œµ / (1 - Œ±)) * S[-1]
    Pi_star[0] ^ (1 + œµ * Œ± / (1 - Œ±)) = œµ * x_aux_1[0] / x_aux_2[0] * (1 - œÑ) / (œµ - 1)
    x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ + Œ± * œµ / (1 - Œ±)) * x_aux_1[1]
    x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ - 1) * x_aux_2[1]
    log_y[0] = log(Y[0])
    log_W_real[0] = log(W_real[0])
    log_N[0] = log(N[0])
    pi_ann[0] = 4 * log(Pi[0])
    i_ann[0] = 4 * log(R[0])
    r_real_ann[0] = 4 * log(realinterest[0])
    M_real[0] = Y[0] / R[0] ^ Œ∑
end

@parameters Gali_2015_chapter_3_nonlinear begin
    œÉ = 1
    œÜ = 5
    œï·µñ‚Å± = 1.5
    œï ∏ = 0.125
    Œ∏ = 0.75
    œÅ_ŒΩ = 0.5
    œÅ_z = 0.5
    œÅ_a = 0.9
    Œ≤ = 0.99
    Œ∑ = 3.77
    Œ± = 0.25
    œµ = 9
    œÑ = 0
    std_a = .01
    std_z = .05
    std_nu = .0025
end</code></pre><p>Calling <code>plot_conditional_forecast</code> requires specifying conditions on endogenous variables. For example, conditioning on <code>Y = 1.0</code> in the first period can be implemented as follows:</p><pre><code class="language-julia hljs">conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                Variables = [:Y], 
                Periods = [1])
conditions[1,1] = 1.0</code></pre><p>Given the model and conditions the conditional forecast can be plotted as follows:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,  
                            conditions)</code></pre><p><img src="../assets/conditional_forecast__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast"/></p><p>The function plots the paths of each endogenous variable conditional on fulfilling the specified conditions. If there was a condition provided for a variable it is represented by a marker (also indicated in the legend below the subplots). The title of the overall plot indicates the model name, and page number (if multiple pages are needed) and the title of each subplot indicates the variable name.</p><h2 id="Combine-or-compare-conditional-forecasts-with-plot_conditional_forecast!"><a class="docs-heading-anchor" href="#Combine-or-compare-conditional-forecasts-with-plot_conditional_forecast!">Combine or compare conditional forecasts with <code>plot_conditional_forecast!</code></a><a id="Combine-or-compare-conditional-forecasts-with-plot_conditional_forecast!-1"></a><a class="docs-heading-anchor-permalink" href="#Combine-or-compare-conditional-forecasts-with-plot_conditional_forecast!" title="Permalink"></a></h2><p>The <code>plot_conditional_forecast!</code> function (note the exclamation mark <code>!</code>) adds additional conditional forecasts to an existing plot created with <code>plot_conditional_forecast</code>, enabling direct comparison between different scenarios. Any input argument that affects the model&#39;s output (such as conditions, shocks, solution algorithm, parameter values, or initial states) can be varied to compare how these changes influence the conditional forecasts. See the respective subsections below (e.g., <a href="#conditions-required">Conditions</a>, <a href="#shocks">Shocks</a>, <a href="#solution-algorithm">Solution Algorithm</a>, <a href="#parameter-values">Parameter Values</a>) for details on specific arguments.</p><p>When using <code>plot_conditional_forecast!</code>, the new conditional forecast can be either overlaid for comparison (default) or stacked to show cumulative effects, depending on the <code>plot_type</code> argument (see <a href="#plot-type">Plot Type</a>). Condition markers adopt the corresponding line color for easy identification.</p><p><strong>Legend and table behavior:</strong></p><ul><li>When inputs differ in <strong>one dimension</strong> (e.g., only the algorithm changes), the legend displays the value of that input dimension for each line (e.g., <code>:first_order</code>, <code>:second_order</code>).</li><li>When inputs differ in <strong>multiple dimensions</strong> (e.g., both conditions and parameters change), the legend shows sequential numbers (1, 2, 3, ...) with a running ID to reference different sets of conditions and inputs. A table below the plot details all input differences for each numbered scenario.</li><li>Additional tables below show the relevant steady state values for each scenario to help identify differences across solution methods or parameter values.</li></ul><p><strong>Example with single input difference:</strong></p><p>When only one input differs (e.g., parameter values), the legend shows the parameter values directly:</p><pre><code class="language-julia hljs"># Set up conditions
conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                    Variables = [:Y], 
                    Periods = 1:1)
conditions_ka[1,1] = 1.0

# Plot conditional forecast with baseline parameters
plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = :Œ≤ =&gt; 0.99)

# Add conditional forecast with different discount factor
plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                          conditions_ka,
                          parameters = :Œ≤ =&gt; 0.95)</code></pre><p><img src="../assets/cnd_fcst_one_diff__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - comparing Œ≤ values"/></p><p>The legend will display the <code>Œ≤</code> values (0.99 and 0.95) to identify each forecast.</p><p>The subplot y-axis labels change depending on the steady state values for each scenario. If the steady state values differ for a variable across scenarios, the y-axis label will indicate that the lines are in absolute deviations from the steady state. In that case no percent deviation is shown on the secondary y-axis, as the steady state values differ. In case the steady state values are the same across scenarios, the y-axis label indicates absolute levels on the primary y-axis and if the values are strictly positive the secondary y-axis shows the percent deviation scale.</p><p><strong>Example with multiple input differences:</strong></p><p>When multiple inputs differ (e.g., both algorithm and parameters), the legend shows sequential numbers and a table details the differences:</p><pre><code class="language-julia hljs"># Plot with baseline settings
plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = :Œ≤ =&gt; 0.99)

# Add with different algorithm AND parameters
plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                          conditions_ka,
                          parameters = :Œ≤ =&gt; 0.95,
                          algorithm = :second_order)</code></pre><p><img src="../assets/cnd_fcst_two_diff__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - comparing Œ≤ values across algorithms"/></p><p>The legend will show <code>1</code> and <code>2</code>, with a table below the plot listing the parameter and algorithm values for each scenario.</p><h2 id="Conditions-(Required)"><a class="docs-heading-anchor" href="#Conditions-(Required)">Conditions (Required)</a><a id="Conditions-(Required)-1"></a><a class="docs-heading-anchor-permalink" href="#Conditions-(Required)" title="Permalink"></a></h2><p>The <code>conditions</code> argument [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>] defines conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>.</p><p>The number of endogenous variables can be retrieved as follows:</p><pre><code class="language-julia hljs">get_variables(Gali_2015_chapter_3_nonlinear)
# 23-element Vector{String}:
#  &quot;A&quot;
#  &quot;C&quot;
#  &quot;MC&quot;
#  &quot;M_real&quot;
#  &quot;N&quot;
#  &quot;Pi&quot;
#  &quot;Pi_star&quot;
#  &quot;Q&quot;
#  &quot;R&quot;
#  &quot;S&quot;
#  &quot;W_real&quot;
#  &quot;Y&quot;
#  &quot;Z&quot;
#  &quot;i_ann&quot;
#  &quot;log_N&quot;
#  &quot;log_W_real&quot;
#  &quot;log_y&quot;
#  &quot;nu&quot;
#  &quot;pi_ann&quot;
#  &quot;r_real_ann&quot;
#  &quot;realinterest&quot;
#  &quot;x_aux_1&quot;
#  &quot;x_aux_2&quot;</code></pre><p>Conditioning <code>Y</code> for 8 periods on a given path means setting the elements in the 12th row:</p><pre><code class="language-julia hljs">conditions = Matrix{Union{Nothing,Float64}}(undef,23,8)
conditions[12,1] = 1.0
conditions[12,2] = 1.1
conditions[12,3] = 1.2
conditions[12,4] = 1.3
conditions[12,5] = 1.4
conditions[12,6] = 1.5
conditions[12,7] = 1.6
conditions[12,8] = 1.7

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,  
                            conditions)</code></pre><p><img src="../assets/cnd_fcst_10_periods__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast 10 periods"/></p><p>The plot shows the conditional paths and the specified conditions. The last page displays the shocks used to enforce these paths. Because there is a single condition per period and three available shocks, the combination of the three shocks with the smallest magnitudes is selected.</p><p><img src="../assets/cnd_fcst_10_periods__Gali_2015_chapter_3_nonlinear__3.png" alt="Gali 2015 conditional forecast 10 periods"/></p><p>A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as conditions. Note that conditioning variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). The conditions in this example also include restrictions for the variable <code>R = 1.0</code> (second element) in period 9:</p><pre><code class="language-julia hljs">conditions_sp = spzeros(23,8)
conditions_sp[12,1] = 1.0
conditions_sp[12,2] = 1.1
conditions_sp[12,3] = 1.2
conditions_sp[12,4] = 1.3
conditions_sp[12,5] = 1.4
conditions_sp[12,6] = 1.5
conditions_sp[12,7] = 1.6
conditions_sp[12,8] = 1.7

conditions_sp[9,8] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,  
                            conditions_sp)</code></pre><p><img src="../assets/cnd_fcst_2_vars__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast sparse matrix input"/></p><p>The paths on both variables are enforced and in the 8th period the paths of the endogenous variables and shocks differ to the previous example.</p><p>This becomes even clearer by overlaying the two conditional forecasts with their different conditions:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,  
                            conditions)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,  
                            conditions_sp)</code></pre><p><img src="../assets/cnd_fcst_plot_overlay__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast overlay"/></p><p>The differences between the two become now clearly visible. Note that there are only 6 subplots per plot and at the bottom the legend now features the two set of conditions using a running ID to reference them, and the marker for the conditions also takes on the color of the line.</p><p>Another possibility to input conditions is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which conditions are specified can be included and all other variables are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</p><p>The benefit of using a <code>KeyedArray</code> is that there is no need to look up the variables. Conditioning on multiple variables in multiple periods works as follows:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0</code></pre><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka)</code></pre><p><img src="../assets/cnd_fcst_plot_ka__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast KeyedArray input"/></p><h2 id="Shocks"><a class="docs-heading-anchor" href="#Shocks">Shocks</a><a id="Shocks-1"></a><a class="docs-heading-anchor-permalink" href="#Shocks" title="Permalink"></a></h2><p>The <code>shocks</code> argument [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing}</code>] allows the user to condition on the shocks in addition to the endogenous variables. This argument allows the user to include certain (known) shock values. By entering restrictions on the shocks in this way, the problem to match the conditions on endogenous variables is restricted to the remaining free (unknown) shocks in the respective period.</p><p>The input can have multiple formats, but for all types of entries, the first dimension corresponds to shocks and the second dimension to the number of periods. <code>shocks</code> can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>.</p><p>Given conditions on <code>Y</code> for the first 8 periods, the shocks can be restricted to fulfill these conditions by setting all but one shock to zero. The number of shocks can be retrieved as follows:</p><pre><code class="language-julia hljs">get_shocks(Gali_2015_chapter_3_nonlinear)
# 3-element Vector{String}:
#  &quot;eps_a&quot;
#  &quot;eps_nu&quot;
#  &quot;eps_z&quot;</code></pre><p>Setting the shock values for the last two shocks to 0 can be done like this:</p><pre><code class="language-julia hljs">shocks = Matrix{Union{Nothing,Float64}}(undef,3,8)
shocks[2,:] .= 0
shocks[3,:] .= 0</code></pre><p>Together with the conditions the conditional forecast can then be plotted:</p><pre><code class="language-julia hljs">conditions = Matrix{Union{Nothing,Float64}}(undef,23,8)
conditions[12,1] = 1.0
conditions[12,2] = 1.1
conditions[12,3] = 1.2
conditions[12,4] = 1.3
conditions[12,5] = 1.4
conditions[12,6] = 1.5
conditions[12,7] = 1.6
conditions[12,8] = 1.7

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions,
                         shocks = shocks)</code></pre><p><img src="../assets/cnd_fcst_shocks__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - shocks"/></p><p><img src="../assets/cnd_fcst_shocks__Gali_2015_chapter_3_nonlinear__3.png" alt="Gali 2015 conditional forecast - shocks"/></p><p>Note the very large shock magnitudes of the first shock and the condition markers on the shocks indicating that the other two shocks were conditioned to be zero. Contrasting this with the version without the conditions of the shocks also highlights the difference in outcomes depending on which shocks can be used to enforce the conditions on the endogenous variables.</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions,
                         shocks = shocks)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions)</code></pre><p><img src="../assets/cnd_fcst_shocks_compare__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - with and without shocks"/></p><p>The paths clearly differ and are even directionally different due to the restriction on only the first shocks being able to fulfill the conditions on the endogenous variables.</p><p>A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as certain shock values. Note that conditioning shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so).</p><p>Using the previous example for the conditions on multiple variables across multiple periods, the same can be done for the <code>shocks</code>:</p><pre><code class="language-julia hljs">shocks_sp = spzeros(3,3)
shocks_sp[1,1] = 0.1
shocks_sp[2,2] = 0.1
shocks_sp[3,3] = 0.1</code></pre><p>Given this non-zero path for the shocks, two of the three shocks remain to fulfill the conditions. There was one condition per period so that the least square solution will be selected:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         shocks = shocks_sp)</code></pre><p><img src="../assets/cnd_fcst_shocks_sp__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - shocks sparse input"/></p><p>This mixture of known and unknown shocks, and known conditions on endogenous variables allows for substantial flexibility.</p><p>Another possibility to input known shocks is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which values are specified can be included and all other shocks are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</p><p>Working with the same conditions the shocks can be restricted to zero using this input type. Doing so for one shock per period works as follows:</p><pre><code class="language-julia hljs">shocks_ka = KeyedArray(Matrix{Float64}(undef,1,3),
                    Variables = [:eps_a], 
                    Periods = 1:3)
shocks_ka .= 0.0</code></pre><p>Combined with conditions on the endogenous variables the conditional forecast can be plotted:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         shocks = shocks_ka)</code></pre><p><img src="../assets/cnd_fcst_shocks_ka__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - shocks KeyedArray input"/></p><p>To see the influence of the shocks (which is similar to conditional forecasts) compare the last two examples. One scenario has non zero shocks and the other zero shocks they condition on:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         shocks = shocks_ka)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         shocks = shocks_sp)</code></pre><p><img src="../assets/cnd_fcst_shocks_compare_sp_ka__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - shocks KeyedArray input"/></p><h2 id="Solution-Algorithm"><a class="docs-heading-anchor" href="#Solution-Algorithm">Solution Algorithm</a><a id="Solution-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Algorithm" title="Permalink"></a></h2><p>Conditional forecasts can be plotted using different solution algorithms. The following example uses a second-order perturbation solution:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         algorithm = :second_order)</code></pre><p><img src="../assets/cnd_fcst_second_order__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - second order"/></p><p>The most notable difference is that at second order, dynamics are observed for <code>S</code>, which remains constant at first order (under certainty equivalence). Additionally, the steady state levels change because the stochastic steady state incorporates precautionary behavior (see horizontal lines). This has consequences for the conditions as they are in levels.</p><p>To compare the two solution methods side by side, use <code>plot_conditional_forecast!</code> to add to an existing plot:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         algorithm = :second_order)</code></pre><p><img src="../assets/cnd_fcst_second_order_combine__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - first and second order"/></p><p>The plots now show both solution methods overlaid. The first-order solution is shown in blue, the second-order solution in orange, as indicated in the legend below the plot. Note that the steady state levels can be different for the two solution methods. For variables where the relevant steady state is the same for both methods (e.g., <code>S</code>), the level appears on the left axis and percentage deviations on the right axis. For variables where the steady state differs between methods (e.g., <code>R</code>), only absolute level deviations (<code>abs. Œî</code>) appear on the left axis. The relevant steady state levels are shown in a table below the plot for reference (rounded to help identify differences). The relevant steady state also implies that the conditions vary in terms of distance to steady state and thereby in the shocks they require for them to be fulfilled. For the variable <code>Y</code> the conditions given a first order solution imply a lower absolute deviation from the relevant steady state than for the second order solution.</p><p>Additional solution methods can be added to the same plot:</p><pre><code class="language-julia hljs">plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         algorithm = :pruned_third_order)</code></pre><p><img src="../assets/cnd_fcst_higher_order_combine__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - multiple orders"/></p><p>Note that the pruned third-order solution incorporates time-varying risk and the dynamics differ relative to lower order solutions. The additional solution appears as another colored line with corresponding entries in both the legend and the steady state table below.</p><h2 id="Initial-State"><a class="docs-heading-anchor" href="#Initial-State">Initial State</a><a id="Initial-State-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-State" title="Permalink"></a></h2><p>The <code>initial_state</code> argument (default: <code>[0.0]</code>, type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>) defines the starting point for the model. For pruned solution algorithms, the initial state can be provided as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case, the initial state must be specified in deviations from the non-stochastic steady state. For all other cases, specify the initial state in levels. For pruned solution algorithms with a <code>Vector{Float64}</code> initial state, only the first-order initial state vector is affected. The initial state defines the starting point for the conditional forecast and must contain all model variables, including any leads or lags. To obtain the correct ordering and number of variables, call <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1)</code>, which returns a <code>KeyedArray</code> with all variables in the correct order. The <code>KeyedArray</code> type is provided by the AxisKeys package. For example:</p><pre><code class="language-julia hljs">init_state = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true)</code></pre><p>Only state variables will have an impact on the conditional forecast. To check which variables are state variables:</p><pre><code class="language-julia hljs">get_state_variables(Gali_2015_chapter_3_nonlinear)
# 4-element Vector{String}:
#  &quot;A&quot;
#  &quot;S&quot;
#  &quot;Z&quot;
#  &quot;nu&quot;</code></pre><p>Now modify the initial state and set <code>nu</code> to 0.1:</p><pre><code class="language-julia hljs">init_state(:nu,:,:) .= 0.1</code></pre><p>The modified initial state can now be input into the <code>plot_conditional_forecast</code> function as a <code>Vector</code>. Furthermore, in the following example the conditions are shifted 10 periods into the future:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,13),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:13)
conditions_ka[1,11] = 1.0
conditions_ka[2,12] = 1.0
conditions_ka[3,13] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         initial_state = vec(init_state))</code></pre><p><img src="../assets/cnd_fcst_init_state__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - custom initial state"/></p><p>Note how the initial state drives the dynamics until the conditions come in after period 10.</p><p>For pruned solution methods the initial state can also be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). When providing a vector of vectors, values must be specified as differences from the non-stochastic steady state. When providing only one vector, values must be in levels, with the initial state having its full nonlinear effect in the first period. Using a vector of vectors allows setting the pruned higher-order auxiliary state vectors. While this can be useful in some cases, note that these higher-order auxiliary state vectors have only a linear impact in the first period. Start by assembling the vector of vectors:</p><pre><code class="language-julia hljs">init_state_pruned_3rd_in_diff = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true) - get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    algorithm = :pruned_third_order,
    levels = true)
# 3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
# ‚Üì   Variables ‚àà 23-element Vector{Symbol}
# ‚Üí   Periods ‚àà 1-element UnitRange{Int64}
# ‚ó™   Shocks ‚àà 1-element Vector{Symbol}
# And data, 23√ó1√ó1 Array{Float64, 3}:
# [:, :, 1] ~ (:, :, :none):
#                    (1)
#   (:A)               0.0
#   (:C)               0.01899564383140051
#   (:MC)              0.26061783703451824
#   (:M_real)          0.014844948179111417
#   (:N)               0.0256329467464953
#   (:Pi)             -0.0013592503942323475
#   (:Pi_star)        -0.0040777511826968205
#   (:Q)              -0.00023912532361458627
#   (:R)               0.0002649588073291298
#   (:S)               3.3306690738754696e-16
#   (:W_real)          0.18508712654020898
#   (:Y)               0.01899564383140051
#   (:Z)               0.0
#   (:i_ann)           0.0010068434678508487
#   (:log_N)           0.024432922221986165
#   (:log_W_real)      0.1404893027764202
#   (:log_y)           0.018324691666489368
#   (:nu)             -1.3404049553225972e-17
#   (:pi_ann)         -0.005437001576929203
#   (:r_real_ann)      0.008306969164175088
#   (:realinterest)    0.002186044516888197
#   (:x_aux_1)        -0.7618262640813329
#   (:x_aux_2)        -0.371793344047362</code></pre><p>First- and third-order dynamics don&#39;t affect the steady state through risk, so they are zero. The second-order steady state includes the risk adjustment. Assemble the vectors for the third order case:</p><pre><code class="language-julia hljs">init_states_pruned_3rd_vec = [
    zero(vec(init_state_pruned_3rd_in_diff)),
    vec(init_state_pruned_3rd_in_diff),
    zero(vec(init_state_pruned_3rd_in_diff)),
]</code></pre><p>Then set <code>nu</code> to 0.1 in the first order terms. Inspecting <code>init_state_pruned_3rd_in_diff</code> shows that <code>nu</code> is the 18th variable in the vector:</p><pre><code class="language-julia hljs">init_states_pruned_3rd_vec[1][18] = 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         initial_state = init_states_pruned_3rd_vec,
                         algorithm = :pruned_third_order)</code></pre><p><img src="../assets/cnd_fcst_init_state_3rd_order__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - pruned 3rd order initial state vector"/></p><p>Alternatively, a simple vector can be used for the initial state. In this case the values must be in levels and the impact of the initial state is assumed to have the full nonlinear effect in the first period:</p><pre><code class="language-julia hljs">init_state_pruned_3rd = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true,
    algorithm = :pruned_third_order)

init_state_pruned_3rd(:nu, :,  :) .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         initial_state = vec(init_state_pruned_3rd),
                         algorithm = :pruned_third_order)</code></pre><p>Compare this with the first-order versions, each starting from their respective steady states.</p><pre><code class="language-julia hljs">plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         initial_state = vec(init_state))</code></pre><p><img src="../assets/cnd_fcst_init_state_compare_orders__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - initial state (first and pruned third order)"/></p><p>This shows that the pruned third-order solution changes the dynamics due to the nonlinear solution and it&#39;s effect on the absolute difference between the steady state and the conditions on endogenous variables.</p><h2 id="Simulation-Periods"><a class="docs-heading-anchor" href="#Simulation-Periods">Simulation Periods</a><a id="Simulation-Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Periods" title="Permalink"></a></h2><p>The <code>periods</code> argument (default: <code>40</code>, type: <code>Int</code>) specifies the number of periods after the end of the conditions for which to calculate the output. When a matrix of shocks is provided, the last period for which a shock or shock condition is provided is considered. To set the number of periods to 10:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,13),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:13)
conditions_ka[1,11] = 1.0
conditions_ka[2,12] = 1.0
conditions_ka[3,13] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         periods = 10)</code></pre><p><img src="../assets/cnd_fcst_periods__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - 10 periods"/></p><p>The x-axis automatically adjusts to show only 23 periods as this corresponds to the last period with a condition plus the 10 periods defined in the argument.</p><p>The following example uses a shock matrix with the last input in period 20, sets the <code>periods</code> argument to 30, and compares it to the previous 10-period plot:</p><pre><code class="language-julia hljs">shocks_ka = KeyedArray(Matrix{Float64}(undef,1,20),
                Variables = [:eps_a], 
                Periods = 1:20)
shocks_ka .= 0.0

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         shocks = shocks_ka,
                         periods = 30)</code></pre><p><img src="../assets/cnd_fcst_30_periods__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - mixed period lengths"/></p><p>The x-axis adjusts to 50 periods, with the first plot ending after 23 periods and the second plot ending after 50 periods. The legend indicates which color corresponds to which combination of shocks and periods.</p><h2 id="Variables-to-Plot"><a class="docs-heading-anchor" href="#Variables-to-Plot">Variables to Plot</a><a id="Variables-to-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-to-Plot" title="Permalink"></a></h2><p>The <code>variables</code> argument (default: <code>:all_excluding_obc</code>) specifies for which variables to show results. Variable names can be specified as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> includes all variables except auxiliary variables and those related to occasionally binding constraints (OBC). <code>:all_excluding_obc</code> includes all variables except those related to occasionally binding constraints. <code>:all</code> includes all variables.</p><p>Specific variables can be selected to plot. The following example selects only output (<code>Y</code>) and inflation (<code>Pi</code>) using a <code>Vector</code> of <code>Symbol</code>s:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = [:Y, :Pi])</code></pre><p><img src="../assets/cnd_fcst_vars__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - selected variables (Y, Pi)"/></p><p>The plot now displays the two selected variables (sorted alphabetically) and the plots enforcing the conditions on endogenous variables. The other two variables for which conditions were provided are not shown.</p><p>The same can be done using a <code>Tuple</code>:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = (:Y, :Pi))</code></pre><p>a <code>Matrix</code>:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = [:Y :Pi])</code></pre><p>or providing the variable names as <code>String</code>s:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = [&quot;Y&quot;, &quot;Pi&quot;])</code></pre><p>or a single variable as a <code>Symbol</code>:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = :Y)</code></pre><p>or as a <code>String</code>:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = &quot;Y&quot;)</code></pre><p>Then there are some predefined options:</p><p><code>:all_excluding_auxiliary_and_obc</code> (default) plots all variables except auxiliary variables and those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = :all_excluding_auxiliary_and_obc)</code></pre><p><code>:all_excluding_obc</code> plots all variables except those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         variables = :all_excluding_obc)</code></pre><p>To see auxiliary variables, use a model that defines them. The FS2000 model can be used:</p><pre><code class="language-julia hljs">@model FS2000 begin
    dA[0] = exp(gam + z_e_a  *  e_a[x])
    log(m[0]) = (1 - rho) * log(mst)  +  rho * log(m[-1]) + z_e_m  *  e_m[x]
    - P[0] / (c[1] * P[1] * m[0]) + bet * P[1] * (alp * exp( - alp * (gam + log(e[1]))) * k[0] ^ (alp - 1) * n[1] ^ (1 - alp) + (1 - del) * exp( - (gam + log(e[1])))) / (c[2] * P[2] * m[1])=0
    W[0] = l[0] / n[0]
    - (psi / (1 - psi)) * (c[0] * P[0] / (1 - n[0])) + l[0] / n[0] = 0
    R[0] = P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ ( - alp) / W[0]
    1 / (c[0] * P[0]) - bet * P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) / (m[0] * l[0] * c[1] * P[1]) = 0
    c[0] + k[0] = exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) + (1 - del) * exp( - (gam + z_e_a  *  e_a[x])) * k[-1]
    P[0] * c[0] = m[0]
    m[0] - 1 + d[0] = l[0]
    e[0] = exp(z_e_a  *  e_a[x])
    y[0] = k[-1] ^ alp * n[0] ^ (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x]))
    gy_obs[0] = dA[0] * y[0] / y[-1]
    gp_obs[0] = (P[0] / P[-1]) * m[-1] / dA[0]
    log_gy_obs[0] = log(gy_obs[0])
    log_gp_obs[0] = log(gp_obs[0])
end

@parameters FS2000 begin
    alp     = 0.356
    bet     = 0.993
    gam     = 0.0085
    mst     = 1.0002
    rho     = 0.129
    psi     = 0.65
    del     = 0.01
    z_e_a   = 0.035449
    z_e_m   = 0.008862
end</code></pre><p>Since both <code>c</code> and <code>P</code> appear in t+2, they generate auxiliary variables in the model. Plotting the conditional forecast for all variables excluding OBC-related ones means auxiliary variables are shown:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:P, :R, :c], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(FS2000,
                         conditions_ka,
                         variables = :all_excluding_obc)</code></pre><p><img src="../assets/cnd_fcst_all_excluding_obc__FS2000__1.png" alt="FS2000 conditional forecast - e_a shock with auxiliary variables"/></p><p>Both <code>c</code> and <code>P</code> appear twice: once as the variable itself and once as an auxiliary variable with the <code>·¥∏‚ÅΩ¬π‚Åæ</code> superscript, representing the value of the variable in t+1 as expected in t.</p><p><code>:all</code> plots all variables including auxiliary variables and those used to enforce occasionally binding constraints (OBC).</p><p>Use the <code>Gali_2015_chapter_3</code> model with an effective lower bound (note the use of the <code>max</code> function in the Taylor rule):</p><pre><code class="language-julia hljs">@model Gali_2015_chapter_3_obc begin
    W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ
    Q[0] = Œ≤ * (C[1] / C[0]) ^ (-œÉ) * Z[1] / Z[0] / Pi[1]
    R[0] = 1 / Q[0]
    Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)
    R[0] = Pi[1] * realinterest[0]
    R[0] = max(RÃÑ , 1 / Œ≤ * Pi[0] ^ œï·µñ‚Å± * (Y[0] / Y[ss]) ^ œï ∏ * exp(nu[0]))
    C[0] = Y[0]
    log(A[0]) = œÅ_a * log(A[-1]) + std_a * eps_a[x]
    log(Z[0]) = œÅ_z * log(Z[-1]) - std_z * eps_z[x]
    nu[0] = œÅ_ŒΩ * nu[-1] + std_nu * eps_nu[x]
    MC[0] = W_real[0] / (S[0] * Y[0] * (1 - Œ±) / N[0])
    1 = Œ∏ * Pi[0] ^ (œµ - 1) + (1 - Œ∏) * Pi_star[0] ^ (1 - œµ)
    S[0] = (1 - Œ∏) * Pi_star[0] ^ (( - œµ) / (1 - Œ±)) + Œ∏ * Pi[0] ^ (œµ / (1 - Œ±)) * S[-1]
    Pi_star[0] ^ (1 + œµ * Œ± / (1 - Œ±)) = œµ * x_aux_1[0] / x_aux_2[0] * (1 - œÑ) / (œµ - 1)
    x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ + Œ± * œµ / (1 - Œ±)) * x_aux_1[1]
    x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ - 1) * x_aux_2[1]
    log_y[0] = log(Y[0])
    log_W_real[0] = log(W_real[0])
    log_N[0] = log(N[0])
    pi_ann[0] = 4 * log(Pi[0])
    i_ann[0] = 4 * log(R[0])
    r_real_ann[0] = 4 * log(realinterest[0])
    M_real[0] = Y[0] / R[0] ^ Œ∑
end

@parameters Gali_2015_chapter_3_obc begin
    RÃÑ = 1.0
    œÉ = 1
    œÜ = 5
    œï·µñ‚Å± = 1.5
    œï ∏ = 0.125
    Œ∏ = 0.75
    œÅ_ŒΩ = 0.5
    œÅ_z = 0.5
    œÅ_a = 0.9
    Œ≤ = 0.99
    Œ∑ = 3.77
    Œ± = 0.25
    œµ = 9
    œÑ = 0
    std_a = .01
    std_z = .05
    std_nu = .0025
    R &gt; 1.0001
end</code></pre><p>Plotting the conditional forecast for all variables including OBC-related ones reveals the OBC-related auxiliary variables:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:C, :R, :Y], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_obc,
                         conditions_ka,
                         variables = :all)</code></pre><p><img src="../assets/cnd_fcst_all__Gali_2015_chapter_3_obc__3.png" alt="Gali 2015 OBC conditional forecast - with OBC variables"/></p><p>The OBC-related variables appear in the last subplot, but note that OBCs are ignored with conditional forecasting.</p><h2 id="Parameter-Values"><a class="docs-heading-anchor" href="#Parameter-Values">Parameter Values</a><a id="Parameter-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Values" title="Permalink"></a></h2><p>When no parameters are provided, the solution uses the previously defined parameter values. Parameters can be provided as a <code>Vector</code> of values, or as a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s mapping parameter <code>Symbol</code>s or <code>String</code>s to values. The solution is recalculated when new parameter values differ from the previous ones.</p><p>Start by changing the discount factor <code>Œ≤</code> from 0.99 to 0.95:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = :Œ≤ =&gt; 0.95)</code></pre><p><img src="../assets/cnd_fcst_beta_95__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - `Œ≤ = 0.95`"/></p><p>The steady states and dynamics changed as a result of changing the discount factor, also because the absolute deviation of the conditons on the endogenous variables from the relevant steady state changed. To better visualize the differences between <code>Œ≤ = 0.99</code> and <code>Œ≤ = 0.95</code>, the two conditional forecasts can be overlaid (compared). Since parameter changes are permanent, first reset <code>Œ≤ = 0.99</code> before overlaying the conditional forecast with <code>Œ≤ = 0.95</code> on top of it:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = :Œ≤ =&gt; 0.99)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = :Œ≤ =&gt; 0.95)</code></pre><p><img src="../assets/cnd_fcst_compare_beta__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - comparing Œ≤ values"/></p><p>The legend below the plot indicates which color corresponds to which <code>Œ≤</code> value, with the table underneath showing the relevant steady states. Note that both the steady states and dynamics differ across the two <code>Œ≤</code> values, even when the steady state remains the same (e.g., for <code>Y</code>).</p><p>Multiple parameters can also be changed simultaneously to compare the results to previous plots. This example changes <code>Œ≤</code> to 0.97 and <code>œÑ</code> to 0.5 using a <code>Tuple</code> of <code>Pair</code>s and define the variables with <code>Symbol</code>s:</p><pre><code class="language-julia hljs">plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = (:Œ≤ =&gt; 0.97, :œÑ =&gt; 0.5))</code></pre><p><img src="../assets/cnd_fcst_multi_params__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - multiple parameter changes"/></p><p>Since the plot function calls now differ in multiple input arguments, the legend indicates which color corresponds to which input combination, with the table showing steady states for all three combinations. The change in steady state for the latest change means substantially different absolute differences relevant for the conditions and therefore also different size of shocks to enforce the conditions.</p><p>A <code>Vector</code> of <code>Pair</code>s can also be used:</p><pre><code class="language-julia hljs">plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = [:Œ≤ =&gt; 0.98, :œÑ =&gt; 0.25])</code></pre><p>Alternatively, use a <code>Vector</code> of parameter values in the order they were defined in the model. To obtain them:</p><pre><code class="language-julia hljs">params = get_parameters(Gali_2015_chapter_3_nonlinear, values = true)
# 16-element Vector{Pair{String, Float64}}:
#       &quot;œÉ&quot; =&gt; 1.0
#       &quot;œÜ&quot; =&gt; 5.0
#     &quot;œï·µñ‚Å±&quot; =&gt; 1.5
#      &quot;œï ∏&quot; =&gt; 0.125
#       &quot;Œ∏&quot; =&gt; 0.75
#     &quot;œÅ_ŒΩ&quot; =&gt; 0.5
#     &quot;œÅ_z&quot; =&gt; 0.5
#     &quot;œÅ_a&quot; =&gt; 0.9
#       &quot;Œ≤&quot; =&gt; 0.95
#       &quot;Œ∑&quot; =&gt; 3.77
#       &quot;Œ±&quot; =&gt; 0.25
#       &quot;œµ&quot; =&gt; 9.0
#       &quot;œÑ&quot; =&gt; 0.5
#   &quot;std_a&quot; =&gt; 0.01
#   &quot;std_z&quot; =&gt; 0.05
#  &quot;std_nu&quot; =&gt; 0.0025

param_vals = [p[2] for p in params]
# 16-element Vector{Float64}:
#  1.0
#  5.0
#  1.5
#  0.125
#  0.75
#  0.5
#  0.5
#  0.9
#  0.95
#  3.77
#  0.25
#  9.0
#  0.5
#  0.01
#  0.05
#  0.0025

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_ka,
                         parameters = param_vals)</code></pre><h2 id="Conditions-in-levels"><a class="docs-heading-anchor" href="#Conditions-in-levels">Conditions in levels</a><a id="Conditions-in-levels-1"></a><a class="docs-heading-anchor-permalink" href="#Conditions-in-levels" title="Permalink"></a></h2><p>Conditions are assumed to be in levels by default. They can also be provided in differences to the relevant steady state (non-stochastic or stochastic steady state).</p><p>Starting with conditions in levels:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                    Variables = [:Y], 
                    Periods = 1:1)
conditions_ka[1,1] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_ka)</code></pre><p>Moving to defining conditions in absolute deviation from the relevant steady state:</p><pre><code class="language-julia hljs">conditions_in_dev_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                            Variables = [:Y], 
                            Periods = 1:1)
conditions_in_dev_ka[1,1] = -0.05

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                         conditions_in_dev_ka,
                         conditions_in_levels = false)</code></pre><p><img src="../assets/cnd_fcst_no_levels__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - conditions not in levels"/></p><p>The same works for higher order solutions, where then the conditions are interpreted as in difference to the stochastic steady state. The influence of risk and the nonlinear solution can be seen by overlaying the second order solution on top of the first order solution:</p><pre><code class="language-julia hljs">plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
                         conditions_in_dev_ka,
                         conditions_in_levels = false,
                         algorithm = :second_order)</code></pre><p><img src="../assets/cnd_fcst_no_levels_second_order__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - conditions not in levels (1st and 2nd order)"/></p><h2 id="Plot-Labels"><a class="docs-heading-anchor" href="#Plot-Labels">Plot Labels</a><a id="Plot-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Labels" title="Permalink"></a></h2><p>The <code>label</code> argument (type: <code>Union{String,Symbol,Real}</code>) controls labels that appear in plots when using the <code>plot_conditional_forecast!</code> function to overlay multiple conditional forecasts. By default, labels take on the values of the one dimensional input that differs and are sequential numbers in case the input differs along more than one dimension. Furthermore, custom labels can be provided using this argument. Acceptable inputs are a <code>String</code>, <code>Symbol</code>, or a <code>Real</code>.</p><p>Custom labels are particularly useful when inputs differ in complex ways (e.g., shock matrices or multiple input changes). For example, let&#39;s compare the conditional forecast of the <code>Gali_2015_chapter_3_nonlinear</code> model for a 1 standard deviation <code>eps_a</code> shock with <code>Œ≤ = 0.99</code> and <code>œÑ = 0</code> to the conditional forecast with <code>Œ≤ = 0.95</code> and <code>œÑ = 0.5</code> using custom labels <code>String</code> input:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                    Variables = [:Y], 
                    Periods = 1:1)
conditions_ka[1,1] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    label = &quot;Std. params&quot;)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    label = &quot;Alt. params&quot;)</code></pre><p><img src="../assets/cnd_fcst_label__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - custom labels"/></p><p>The legend now displays the custom label names instead of sequential numbers (1 and 2). Additionally, the tables showing input differences and steady states use the custom labels in the first column instead of sequential numbers.</p><p>The same result can be achieved using <code>Symbol</code>s (though they are less expressive):</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    label = :standard)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    label = :alternative)</code></pre><p>or with <code>Real</code> inputs:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    label = 0.99)

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    label = 0.95)</code></pre><h2 id="Plot-Type"><a class="docs-heading-anchor" href="#Plot-Type">Plot Type</a><a id="Plot-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Type" title="Permalink"></a></h2><p>The <code>plot_type</code> argument (default: <code>:compare</code>, type: <code>Symbol</code>) determines how conditional forecasts are visualized when multiple scenarios are displayed. Two options are available:</p><ul><li><code>:compare</code> - Displays conditional forecasts as separate lines for comparison across scenarios</li><li><code>:stack</code> - Stacks conditional forecasts on top of each other to show cumulative effects</li></ul><p>The <code>:stack</code> option is particularly useful when analyzing scenarios composed of differnt conditions or shock inputs. The <code>:compare</code> option is better suited for comparing conditional forecasts across different parameter values or model specifications.</p><h3 id="Using-:stack-to-layer-scenarios"><a class="docs-heading-anchor" href="#Using-:stack-to-layer-scenarios">Using <code>:stack</code> to layer scenarios</a><a id="Using-:stack-to-layer-scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Using-:stack-to-layer-scenarios" title="Permalink"></a></h3><p>When analyzing a scenario composed of different conditions or shocks, <code>:stack</code> visualizes the cumulative impact. For example, plot two conditions on endogenous variables:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false)

conditions_ka2 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,10),
                    Variables = [:Y,:R], 
                    Periods = 1:10)
conditions_ka2[1,:] .= -0.1
conditions_ka2[2,:] .= 0.0

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka2,
    conditions_in_levels = false,
    plot_type = :stack)</code></pre><p><img src="../assets/cnd_fcst_stack__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - stacked"/></p><p>The <code>:stack</code> visualization shows how each condition contributes to the combined path, with the second condition&#39;s effect layered on top of the first, and the solid black line representing the total effect.</p><h3 id="Using-:compare-for-scenario-comparisons"><a class="docs-heading-anchor" href="#Using-:compare-for-scenario-comparisons">Using <code>:compare</code> for scenario comparisons</a><a id="Using-:compare-for-scenario-comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Using-:compare-for-scenario-comparisons" title="Permalink"></a></h3><p>When comparing conditional forecasts across different scenarios, <code>:compare</code> displays the paths as separate lines:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),
                    Variables = [:R], 
                    Periods = 1:1)
conditions_ka .= 1.0

# Baseline parameterization
plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = :Œ≤ =&gt; 0.99)

# Alternative parameterization for comparison
plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = :Œ≤ =&gt; 0.95,
    plot_type = :compare)</code></pre><p><img src="../assets/cnd_fcst_compare__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - comparing Œ≤ values"/></p><p>The <code>:compare</code> option (the default) makes it easy to see how parameter changes affect the conditional forecast for the same conditions on endogenous variables.</p><h2 id="Plot-Attributes"><a class="docs-heading-anchor" href="#Plot-Attributes">Plot Attributes</a><a id="Plot-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Attributes" title="Permalink"></a></h2><p>The <code>plot_attributes</code> argument (default: <code>Dict()</code>, type: <code>Dict</code>) accepts a dictionary of attributes passed on to the plotting function. See the Plots.jl documentation for details.</p><p>The color palette can be customized using the <code>plot_attributes</code> argument. The following example defines a custom color palette (inspired by the European Commission&#39;s economic reports) to plot and stack multiple conditional forecasts for the <code>Gali_2015_chapter_3_nonlinear</code> model. First, define the custom color palette using hex color codes:</p><pre><code class="language-julia hljs">ec_color_palette =
[
    &quot;#FFD724&quot;,  # &quot;Sunflower Yellow&quot;
    &quot;#353B73&quot;,  # &quot;Navy Blue&quot;
    &quot;#2F9AFB&quot;,  # &quot;Sky Blue&quot;
    &quot;#B8AAA2&quot;,  # &quot;Taupe Grey&quot;
    &quot;#E75118&quot;,  # &quot;Vermilion&quot;
    &quot;#6DC7A9&quot;,  # &quot;Mint Green&quot;
    &quot;#F09874&quot;,  # &quot;Coral&quot;
    &quot;#907800&quot;   # &quot;Olive&quot;
]</code></pre><p>Then plot the first conditional forecast:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false)</code></pre><p>Finally, overlay another conditional forecast using the custom color palette:</p><pre><code class="language-julia hljs">conditions_ka2 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,10),
                    Variables = [:Y,:R], 
                    Periods = 1:10)
conditions_ka2[1,:] .= -0.1
conditions_ka2[2,:] .= 0.0

# Add second shock to show cumulative effect
plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka2,
    conditions_in_levels = false,
    plot_attributes = Dict(:palette =&gt; ec_color_palette),
    plot_type = :stack)</code></pre><p><img src="../assets/cnd_fcst_color__Gali_2015_chapter_3_nonlinear__2.png" alt="Gali 2015 conditional forecast - custom color palette"/></p><p>The colors of the bars now follow the custom color palette.</p><p>Other attributes such as the font family can also be modified (see here for <a href="https://github.com/JuliaPlots/Plots.jl/blob/v1.41.1/src/backends/gr.jl#L61">GR font options</a>):</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    plot_attributes = Dict(:fontfamily =&gt; &quot;computer modern&quot;))</code></pre><p><img src="../assets/cnd_fcst_font__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - custom font"/></p><p>All text in the plot now uses the Computer Modern font. Note that font rendering inherits the constraints of the plotting backend (GR in this case).</p><h2 id="Plots-Per-Page"><a class="docs-heading-anchor" href="#Plots-Per-Page">Plots Per Page</a><a id="Plots-Per-Page-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-Per-Page" title="Permalink"></a></h2><p>The <code>plots_per_page</code> argument (default: <code>9</code>, type: <code>Int</code>) controls the number of subplots per page. When the number of variables exceeds this value, multiple pages are created. The following example selects 9 variables and sets <code>plots_per_page</code> to 2:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false,
    variables = [:Y, :Pi, :R, :C, :N, :W_real, :MC, :i_ann, :A],
    plots_per_page = 2)</code></pre><p><img src="../assets/cnd_fcst_2_per_page__Gali_2015_chapter_3_nonlinear__3.png" alt="Gali 2015 conditional forecast - 2 plots per page"/></p><p>The first four pages display two variables (sorted alphabetically). The title indicates the current page and the total number of pages.</p><h2 id="Display-Plots"><a class="docs-heading-anchor" href="#Display-Plots">Display Plots</a><a id="Display-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Display-Plots" title="Permalink"></a></h2><p>The <code>show_plots</code> argument (default: <code>true</code>, type: <code>Bool</code>), when <code>true</code>, displays the plots; otherwise, they are only returned as an object.</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false,
    show_plots = false)</code></pre><h2 id="Saving-Plots"><a class="docs-heading-anchor" href="#Saving-Plots">Saving Plots</a><a id="Saving-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Plots" title="Permalink"></a></h2><p>The <code>save_plots</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, saves the plots to disk; otherwise, they are only displayed and returned as an object.</p><p>Related arguments control the saving behavior:</p><ul><li><code>save_plots_format</code> (default: <code>:pdf</code>, type: <code>Symbol</code>): output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> (default: <code>&quot;.&quot;</code>, type: <code>String</code>): path where plots are saved. If the path does not exist, it will be created automatically.</li><li><code>save_plots_name</code> (default: <code>&quot;conditional_forecast&quot;</code>, type: <code>Union{String, Symbol}</code>): prefix prepended to the filename when saving plots.</li></ul><p>Each plot is saved as a separate file with a name indicating the prefix, model name, shocks, and a sequential number for multiple plots (e.g., <code>conditional_forecast__ModelName__1.pdf</code>).</p><p>The following example saves all conditional forecasts for the <code>Gali_2015_chapter_3_nonlinear</code> model as PNG files in the <code>../plots</code> directory with <code>cond_fcst</code> as the filename prefix:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false,
    save_plots = true,
    save_plots_format = :png,
    save_plots_path = &quot;./../plots&quot;,
    save_plots_name = :cond_fcst)</code></pre><p>The plots appear in the specified folder with the specified prefix. Each plot is saved in a separate file with a name reflecting the model, and a sequential index when the number of variables exceeds the plots per page.</p><h2 id="Variable-and-Shock-Renaming-(rename-dictionary)"><a class="docs-heading-anchor" href="#Variable-and-Shock-Renaming-(rename-dictionary)">Variable and Shock Renaming (rename dictionary)</a><a id="Variable-and-Shock-Renaming-(rename-dictionary)-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-and-Shock-Renaming-(rename-dictionary)" title="Permalink"></a></h2><p>The <code>rename_dictionary</code> argument (default: <code>Dict()</code>, type: <code>AbstractDict{&lt;:Union{Symbol, String}, &lt;:Union{Symbol, String}}</code>) maps variable or shock symbols to custom display names in plots. This is particularly useful when comparing models with different variable naming conventions, allowing them to be displayed with consistent labels.</p><p>For example, to rename variables for clearer display:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.1

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false,
    rename_dictionary = Dict(:Y =&gt; &quot;Output&quot;, :Pi =&gt; &quot;Inflation&quot;, :R =&gt; &quot;Interest Rate&quot;))</code></pre><p><img src="../assets/cnd_fcst_rename_dict__Gali_2015_chapter_3_nonlinear__1.png" alt="Gali 2015 conditional forecast - rename dictionary"/></p><p>This feature is especially valuable when overlaying conditional forecasts from different models. Consider comparing FS2000 (which uses lowercase variable names like <code>c</code>) with <code>Gali_2015_chapter_3_nonlinear</code> (which uses uppercase variable names like <code>C</code>). The <code>rename_dictionary</code> allows harmonizing these names when plotting them together:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:P, :R, :c], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.01
conditions_ka[2,2] = 1.02
conditions_ka[3,3] = 1.03

plot_conditional_forecast(FS2000,
                         conditions_ka,
                         rename_dictionary = Dict(
                            :c =&gt; &quot;Consumption&quot;, 
                            :y =&gt; &quot;Output&quot;, 
                            :R =&gt; &quot;Interest Rate&quot;
                         ))

conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.01

plot_conditional_forecast!(Gali_2015_chapter_3_nonlinear,
    conditions_ka1,
    conditions_in_levels = false,
    rename_dictionary = Dict(
        :C =&gt; &quot;Consumption&quot;, 
        :Y =&gt; &quot;Output&quot;, 
        :R =&gt; &quot;Interest Rate&quot;
        ))</code></pre><p><img src="../assets/cnd_fcst_rename_dict2__multiple_models__2.png" alt="FS2000 and Gali 2015 conditional forecast - multiple models with rename dictionary"/></p><p>Both models now appear in the plot with consistent, readable labels, making comparison straightforward.</p><p>The <code>rename_dictionary</code> also works with shocks. For example, <code>Gali_2015_chapter_3_nonlinear</code> has shocks <code>eps_a</code> and <code>eps_nu</code>, while FS2000 has <code>e_a</code> and <code>e_m</code>. To compare these with consistent labels:</p><pre><code class="language-julia hljs">conditions_ka1 = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,10),
                    Variables = [:Y], 
                    Periods = 1:10)
conditions_ka1 .= 0.01

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
                            conditions_ka1,
                            conditions_in_levels = false,
                            rename_dictionary = Dict(
                                :eps_a =&gt; &quot;Technology Shock&quot;, 
                                :eps_nu =&gt; &quot;Monetary Policy Shock&quot;
                                ))

conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:P, :R, :c], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.01
conditions_ka[2,2] = 1.02
conditions_ka[3,3] = 1.03

plot_conditional_forecast!(FS2000,
                         conditions_ka,
                         rename_dictionary = Dict(
                            :e_a =&gt; &quot;Technology Shock&quot;, 
                            :e_m =&gt; &quot;Monetary Policy Shock&quot;
                            ))</code></pre><p><img src="../assets/cnd_fcst_rename_dict_shocks__multiple_models__7.png" alt="FS2000 and Gali 2015 conditional forecast - multiple models with shock rename dictionary"/></p><p>The <code>rename_dictionary</code> accepts flexible type combinations for keys and values‚Äîboth <code>Symbol</code> and <code>String</code> types work interchangeably:</p><pre><code class="language-julia hljs"># All of these are valid and equivalent:
Dict(:Y =&gt; &quot;Output&quot;)              # Symbol key, String value
Dict(&quot;Y&quot; =&gt; &quot;Output&quot;)             # String key, String value
Dict(:Y =&gt; :Output)               # Symbol key, Symbol value
Dict(&quot;Y&quot; =&gt; :Output)              # String key, Symbol value</code></pre><p>This flexibility is particularly useful for models like <code>Backus_Kehoe_Kydland_1992</code>, which uses <code>String</code> representations of variable and shock names (because of <code>{}</code>):</p><pre><code class="language-julia hljs"># Define the Backus model (abbreviated for clarity)
@model Backus_Kehoe_Kydland_1992 begin
    for co in [H, F]
        Y{co}[0] = ((LAMBDA{co}[0] * K{co}[-4]^theta{co} * N{co}[0]^(1-theta{co}))^(-nu{co}) + sigma{co} * Z{co}[-1]^(-nu{co}))^(-1/nu{co})
        K{co}[0] = (1-delta{co})*K{co}[-1] + S{co}[0]
        X{co}[0] = for lag in (-4+1):0 phi{co} * S{co}[lag] end
        A{co}[0] = (1-eta{co}) * A{co}[-1] + N{co}[0]
        L{co}[0] = 1 - alpha{co} * N{co}[0] - (1-alpha{co})*eta{co} * A{co}[-1]
        U{co}[0] = (C{co}[0]^mu{co}*L{co}[0]^(1-mu{co}))^gamma{co}
        psi{co} * mu{co} / C{co}[0]*U{co}[0] = LGM[0]
        psi{co} * (1-mu{co}) / L{co}[0] * U{co}[0] * (-alpha{co}) = - LGM[0] * (1-theta{co}) / N{co}[0] * (LAMBDA{co}[0] * K{co}[-4]^theta{co}*N{co}[0]^(1-theta{co}))^(-nu{co})*Y{co}[0]^(1+nu{co})

        for lag in 0:(4-1)  
            beta{co}^lag * LGM[lag]*phi{co}
        end +
        for lag in 1:4
            -beta{co}^lag * LGM[lag] * phi{co} * (1-delta{co})
        end = beta{co}^4 * LGM[+4] * theta{co} / K{co}[0] * (LAMBDA{co}[+4] * K{co}[0]^theta{co} * N{co}[+4]^(1-theta{co})) ^ (-nu{co})* Y{co}[+4]^(1+nu{co})

        LGM[0] = beta{co} * LGM[+1] * (1+sigma{co} * Z{co}[0]^(-nu{co}-1)*Y{co}[+1]^(1+nu{co}))
        NX{co}[0] = (Y{co}[0] - (C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1]))/Y{co}[0]
    end

    (LAMBDA{H}[0]-1) = rho{H}{H}*(LAMBDA{H}[-1]-1) + rho{H}{F}*(LAMBDA{F}[-1]-1) + Z_E{H} * E{H}[x]
    (LAMBDA{F}[0]-1) = rho{F}{F}*(LAMBDA{F}[-1]-1) + rho{F}{H}*(LAMBDA{H}[-1]-1) + Z_E{F} * E{F}[x]

    for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end
end

@parameters Backus_Kehoe_Kydland_1992 begin
    K_ss = 11
    K[ss] = K_ss | beta
    
    mu      =    0.34
    gamma   =    -1.0
    alpha   =    1
    eta     =    0.5
    theta   =    0.36
    nu      =    3
    sigma   =    0.01
    delta   =    0.025
    phi     =    1/4
    psi     =    0.5

    Z_E = 0.00852
    
    rho{H}{H} = 0.906
    rho{F}{F} = rho{H}{H}
    rho{H}{F} = 0.088
    rho{F}{H} = rho{H}{F}
end


conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),
                    Variables = [&quot;C{H}&quot;, &quot;C{F}&quot;], 
                    Periods = 1:2)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0

plot_conditional_forecast(Backus_Kehoe_Kydland_1992,
    conditions_ka,
    rename_dictionary = Dict(&quot;C{H}&quot; =&gt; &quot;Home Consumption&quot;, 
                             &quot;C{F}&quot; =&gt; &quot;Foreign Consumption&quot;,
                             &quot;Y{H}&quot; =&gt; &quot;Home Output&quot;,
                             &quot;Y{F}&quot; =&gt; &quot;Foreign Output&quot;))</code></pre><p><img src="../assets/cnd_fcst_rename_dict_string__Backus_Kehoe_Kydland_1992__1.png" alt="Backus, Kehoe, Kydland 1992 conditional forecast - E{H} shock with rename dictionary"/></p><p>Variables or shocks not included in the dictionary retain their default names. The renaming applies to all plot elements including legends, axis labels, and tables.</p><h2 id="Verbose-Output"><a class="docs-heading-anchor" href="#Verbose-Output">Verbose Output</a><a id="Verbose-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Verbose-Output" title="Permalink"></a></h2><p>The <code>verbose</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, enables verbose output related to solving the model</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    verbose = true)</code></pre><p>The code outputs information about solving the steady state blocks. When parameters change, the first-order solution is recomputed; otherwise, it uses the cached solution:</p><pre><code class="language-julia hljs">plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    parameters = :Œ≤ =&gt; 0.955,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.95       to 0.955
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 4.3825585462666584e-15
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16</code></pre><h2 id="Numerical-Tolerances"><a class="docs-heading-anchor" href="#Numerical-Tolerances">Numerical Tolerances</a><a id="Numerical-Tolerances-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Tolerances" title="Permalink"></a></h2><p>The <code>tol</code> argument (default: <code>Tolerances()</code>, type: <code>Tolerances</code>) defines various tolerances for the algorithm used to solve the model. See the Tolerances documentation for more details: <code>?Tolerances</code>. The tolerances used by the numerical solvers can be adjusted. The Tolerances object allows setting tolerances for the non-stochastic steady state solver (NSSS), Sylvester equations, Lyapunov equation, and quadratic matrix equation (QME). For example, to set tighter tolerances (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">custom_tol = Tolerances(qme_acceptance_tol = 1e-12,
    sylvester_acceptance_tol = 1e-12)

conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    tol = custom_tol,
    algorithm = :second_order,
    parameters = :Œ≤ =&gt; 0.9555,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.955      to 0.9555
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 3.692979383228777e-15
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 3.692979383228777e-15
# Sylvester equation - converged to tol 1.0e-12: true; iterations: 10; reached tol: 6.494758134185766e-17; algorithm: doubling
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16</code></pre><p>This is useful when higher precision is needed or when the default tolerances are insufficient for convergence. Use this argument for specific needs or when encountering issues with the default solver.</p><h2 id="Quadratic-Matrix-Equation-Solver"><a class="docs-heading-anchor" href="#Quadratic-Matrix-Equation-Solver">Quadratic Matrix Equation Solver</a><a id="Quadratic-Matrix-Equation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Matrix-Equation-Solver" title="Permalink"></a></h2><p>The <code>quadratic_matrix_equation_algorithm</code> argument (default: <code>:schur</code>, type: <code>Symbol</code>) specifies the algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code> The quadratic matrix equation solver is used internally when solving the model to first order. Different algorithms are available. The <code>:schur</code> algorithm is generally faster and more reliable, while <code>:doubling</code> can be more precise in some cases (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    quadratic_matrix_equation_algorithm = :doubling,
    parameters = :Œ≤ =&gt; 0.95555,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.9555     to 0.95555
# New parameters changed the steady state.
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver: doubling - converged: true in 8 iterations to tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>For most use cases, the default <code>:schur</code> algorithm is recommended. Use this argument for specific needs or when encountering issues with the default solver.</p><h2 id="Sylvester-Equation-Solver"><a class="docs-heading-anchor" href="#Sylvester-Equation-Solver">Sylvester Equation Solver</a><a id="Sylvester-Equation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Sylvester-Equation-Solver" title="Permalink"></a></h2><p>[Default: selector that uses <code>:doubling</code> for smaller problems and switches to <code>:bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: Algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. The input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solution&#39;s Sylvester equation. When only one element is provided, it corresponds to the second-order perturbation solution&#39;s Sylvester equation. The algorithm to use can be specified for solving Sylvester equations in higher-order solutions. For example, select the <code>:bartels_stewart</code> algorithm for solving the second-order perturbation problem:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    algorithm = :second_order,
    sylvester_algorithm = :bartels_stewart,
    verbose = true)
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - converged to tol 1.0e-10: true; iterations: -1; reached tol: 6.19336731775721e-17; algorithm: bartels_stewart
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>For third-order solutions, different algorithms can be specified for the second- and third-order Sylvester equations using a <code>Tuple</code>:</p><pre><code class="language-julia hljs">conditions_ka = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,3,3),
                    Variables = [:R, :Y, :MC], 
                    Periods = 1:3)
conditions_ka[1,1] = 1.0
conditions_ka[2,2] = 1.0
conditions_ka[3,3] = 1.0

plot_conditional_forecast(Gali_2015_chapter_3_nonlinear,
    conditions_ka,
    algorithm = :third_order,
    sylvester_algorithm = (:doubling, :bicgstab),
    verbose = true)
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - previous solution achieves relative tol of 3.838708060339852e-17
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - previous solution achieves relative tol of 3.838708060339852e-17
# Sylvester equation - converged to tol 1.0e-10: true; iterations: 23; reached tol: 8.328904812714592e-17; algorithm: bicgstab
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>The choice of algorithm affects both speed and precision: <code>:doubling</code> and <code>:bartels_stewart</code> are generally faster, while <code>:bicgstab</code>, <code>:dqgmres</code>, and <code>:gmres</code> are better for large sparse problems. Use this argument for specific needs or when encountering issues with the default solver.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plot_solution/">¬´ Policy Functions</a><a class="docs-footer-nextpage" href="../plot_conditional_variance_decomposition/">Variance Decomposition ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 21:59">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
