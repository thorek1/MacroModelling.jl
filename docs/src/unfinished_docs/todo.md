# Todo list

## High priority

- [ ] ss transition by entering new parameters at given periods
- [ ] add argument to plotting functions to replace names in plots (e.g. input a dictionnary: Dict(:dinve => "Investment growth"))
- [ ] programmatic model writing: accept {i}[0] as definition for variable
- [ ] check out dense sparse matmul on transposed matrices
- [ ] check out DiffInterface for NSSS solver
- [ ] write plotting callback for NSSS solver
- [ ] append forecast (no shocks) after estimated variables
- [ ] write more tests for the plots
- [ ] add background part in docs on NSSS solver (use material from presentation)
- [ ] juliacon followup: checkout alloccheck, infiltrator, bestie, DifferentiableInterface, DepotDelivery, Interfaces, ThreadedDenseparseMul, Optimization Ensemble, redo Kalman filter with PDMats
- [ ] use IrrationalConstants for log2pi...
- [ ] checkout this invalidation precompile trick and g dalle part on precompilation
- [ ] use sobol random numbers (gives you uniform but then use norminvcdf to get norm) to integrate out future randomness when solving with neural nets
- [ ] do proper testing of ss solver with random set of params, equal across configs
- [ ] load create parts of derivatives later and not directly after parameters block
- [ ] fix model estimate plot. data not above estimate (should be red but is blue)
- [ ] analytical derivatives of inversion filter (higher order)
- [ ] implement higher order (pruned) variance decomposition
- [ ] try slicesampler instead of pigeons
- [ ] use faster derivatives for SS solver (currently forward diff)
- [ ] speed up sensitivity by caching matrix inversion from implicit diff with LRUcache
- [ ] FastDifferentiation is faster in taking derivatives and more efficient in writing functions but does not support custom functions (e.g. normlogpdf)
- [ ] fix this inference errors for large fuctions. they are slow. fix derivatives in general.
- [ ] check downgrade tests
- [ ] put write_derivatives_function and lock structure inside function
- [ ] take apart solve_matrix_equation for various cases
- [ ] try static arrays in KF
- [ ] check derivatives of erfcinv with Symbolics. seems off
- [ ] have a workspace in the model object. to be accessed for example by the riccati solver at each run (instead of initialising values at each function call)
- [ ] check why PG samples are off
- [ ] optimise vanilla loglikelihood calculation and gradient thereof (incl comp time)
- [ ] checkout dynamic perturbation for obc solution: https://www.southampton.ac.uk/~alexmen/dynamic_perturbation.pdf
- [ ] checkout schedule free ADAM for global methods: https://github.com/facebookresearch/schedule_free
- [ ] figure out why PG and IS return basically the prior
- [ ] allow external functions to calculate the steady state (and hand it over via SS or get_loglikelihood function) - need to use the check function for implicit derivatives and cannot use it to get him a guess from which he can use internal solver going forward
- [ ] go through custom SS solver once more and try to find parameters and logic that achieves best results
- [ ] SS solver with less equations than variables
- [ ] improve docs: timing in first sentence seems off; have something more general in first sentence; why is the syntax user friendly? give an example; make the former and the latter a footnote
- [ ] write tests/docs/technical details for nonlinear obc, forecasting, (non-linear) solution algorithms, SS solver, obc solver, and other algorithms
- [ ] change docs to reflect that the output of irfs include aux vars and also the model info Base.show includes aux vars
- [ ] recheck function examples and docs (include output description)
- [ ] Docs: document outputs and associated functions to work with function
- [ ] write documentation/docstrings using copilot
- [ ] feedback: sell the sampler better (ESS vs dynare), more details on algorithm (SS solver)
- [ ] NaNMath pow does not work (is not substituted)
- [ ] check whether its possible to run parameters macro/block without rerunning model block
- [ ] eliminate possible log, ^ terms in parameters block equations - because of nonnegativity errors
- [ ] throw error when equations appear more than once
- [ ] plot multiple solutions of models - multioptions in one graph
- [ ] make SS calc faster (func and optim, maybe inplace ops)
- [ ] try preallocation tools for forwarddiff (DiffInterface)
- [ ] add nonlinear shock decomposition
- [ ] check obc once more
- [ ] rm obc vars from get_SS
- [ ] check why warmup_iterations = 0 makes estimated shocks larger
- [ ] use analytical derivatives also for shocks matching optim (and HMC - implicit diff)
- [ ] info on when what filter is used and chosen options are overridden
- [ ] check warnings, errors throughout. check suppress not interfering with pigeons
- [ ] functions to reverse state_update (input: previous shock and current state, output previous state), find shocks corresponding to bringing one state to the next
- [ ] cover nested case: min(50,a+b+max(c,10))
- [ ] add balanced growth path handling
- [ ] higher order solutions: some kron matrix mults are later compressed. write custom compressed kron mult; check if sometimes dense mult is faster? (e.g. GNSS2010 seems dense at higher order)
- [ ] make inversion filter / higher order sols suitable for HMC (forward and reverse diff!!, currently only analytical pushforward, no implicitdiff) | analytic derivatives
- [ ] speed up sparse matrix calcs in implicit diff of higher order funcs
- [ ] compressed higher order derivatives and sparsity of jacobian
- [ ] dont use SS_solve_func but the wrapper instead (write forwarddiff wrapper)
- [ ] add user facing option to choose sylvester solver
- [ ] autocorr and covariance with derivatives. return 3d array
- [ ] use ID for sparse output sylvester solvers (filed issue)
- [ ] add pydsge and econpizza to overview
- [ ] add for loop parser in @parameters
- [ ] implement more multi country models
- [ ] speed benchmarking (focus on ImplicitDiff part)
- [ ] for cond forecasting allow less shocks than conditions with a warning. should be svd then
- [ ] have parser accept rss | (r[ss] - 1) * 400 = rss
- [ ] when doing calibration with optimiser have better return values when he doesnt find a solution (probably NaN)
- [ ] sampler returned negative std. investigate and come up with solution ensuring sampler can continue
- [ ] automatically adjust plots for different legend widths and heights
- [ ] include weakdeps: https://pkgdocs.julialang.org/dev/creating-packages/#Weak-dependencies
- [ ] have get_std take variables as an input
- [ ] more informative errors when something goes wrong when writing a model
- [ ] initial state accept keyed array, SS and SSS as arguments
- [ ] plot_model_estimates with unconditional forecast at the end
- [ ] kick out unused parameters from m.parameters
- [ ] use cache for gradient calc in estimation (see DifferentiableStateSpaceModels)
- [ ] write functions to debug (fix_SS.jl...)
- [ ] model compression (speed up 2nd moment calc (derivatives) for large models; gradient loglikelihood is very slow due to large matmuls) -> model setup as maximisation problem (gEcon) -> HANK models
- [ ] implement global solution methods - Julien Pascal, QuantEcon
- [ ] add more models

- [ ] use @assert for errors and @test_throws
- [ ] print SS dependencies (get parameters (in function of parameters) into the dependencies), show SS solver
- [ ] use strings instead of symbols internally
- [ ] write how-to for calibration equations
- [ ] make the nonnegativity trick optional or use nanmath?
- [ ] clean up different parameter types
- [ ] clean up printouts/reporting
- [ ] clean up function inputs and harmonise AD and standard commands
- [ ] figure out combinations for inputs (parameters and variables in different formats for get_irf for example)
- [ ] weed out SS solver and saved objects

- [x] implement estimation tests for all models
- [x] make plotting options as dynamic setting instead of default, accept kwargs
- [x] streamline estimation part (dont do string matching... but rely on precomputed indices...)
- [x] estimation: run auto-tune before and use solver treating parameters as given
- [x] use arraydist in tests and docs
- [x] include guess in docs
- [x] Find any SS by optimising over both SS guesses and parameter inputs
- [x] riccati with analytical derivatives (much faster if sparse) instead of implicit diff; done for ChainRules; ForwardDiff only feasible for smaller problems -> ID is fine there
- [x] log in parameters block is recognized as variable
- [x] add termination condition if relative change in ss solver is smaller than tol (relevant when values get very large)
- [x] provide option for external SS guess; provided in parameters macro
- [x] make it possible to run multiple ss solver parameter combination including starting points when solving a model
- [x] automatically put the combi first which solves it fastest the first time
- [x] write auto-tune in case he cant find SS (add it to the warning when he cant find the SS)
- [x] nonlinear conditional forecasts for higher order and obc
- [x] for cond forecasting and kalman, get rid of observables input and use axis key of data input
- [x] fix translate dynare mod file from file written using write to dynare file (see test models): added retranslation to test
- [x] use packages for kalman filter: nope sticking to own implementation
- [x] check that there is an error if he cant find SS
- [x] bring solution error into an object of the model so we dont have to pass it on as output: errors get returned by functions and are thrown where appropriate
- [x] include option to provide pruned states for irfs
- [x] use other quadratic iteration for diffable first order solve (useful because schur can error in estimation): used try catch, schur is still fastest
- [x] fix SS solver (failed for backus in guide): works now
- [x] nonlinear estimation using unscented kalman filter / inversion filter (minimization problem: find shocks to match states with data): used inversion filter with gradient optim
- [x] check if higher order effects might distort results for autocorr (problem with order deffinition) - doesnt seem to be the case; full_covar yields same result
- [x] implement occasionally binding constraints with shocks
- [x] add QUEST3 tests
- [x] add obc tests
- [x] highlight NUTS sampler compatibility
- [x] differentiate more vs diffstatespace
- [x] reorder other toolboxes according to popularity
- [x] add JOSS article (see Makie.jl)
- [x] write to mod file for unicode characters. have them take what you would type: \alpha\bar
- [x] write dynare model using function converting unicode to tab completion
- [x] write parameter equations to dynare (take ordering on board)
- [x] pruning of 3rd order takes pruned 2nd order input
- [x] implement moment matching for pruned models
- [x] test pruning and add literature
- [x] use more implicit diff for the other functions as well
- [x] handle sparsity in sylvester solver better (hand over indices and nzvals instead of vec)
- [x] redo naming in moments calc and make whole process faster (precalc wrangling matrices)
- [x] write method of moments how to
- [x] check tols - all set to eps() except for dependencies tol (1e-12)
- [x] set to 0 SS values < 1e-12 - doesnt work with Zygote
- [x] sylvester with analytical derivatives (much faster if sparse) instead of implicit diff - yes but there are still way too large matrices being realised. implicitdiff is better here
- [x] autocorr to statistics output and in general for higher order pruned sols
- [x] fix product moments and test for cases with more than 2 shocks
- [x] write tests for variables argument in get_moment and for higher order moments
- [x] handle KeyedArrays with strings as dimension names as input
- [x] add mean in output funcs for higher order 
- [x] recheck results for third order cov
- [x] have a look again at get_statistics function
- [x] consolidate sylvester solvers (diff)
- [x] put outside of loop the ignore derviatives for derivatives
- [x] write function to smart select variables to calc cov for
- [x] write get function for variables, parameters, equations with proper parsing so people can understand what happens when invoking for loops
- [x] have for loop where the items are multiplied or divided or whatever, defined by operator | + or * only
- [x] write documentation for string inputs
- [x] write documentation for programmatic model writing
- [x] input indices not as symbol
- [x] make sure plots and printed output also uses strings instead of symbols if adequate
- [x] have keyedarray with strings as axis type if necessary as output
- [x] write test for keyedarray with strings as primary axis
- [x] test string input
- [x] have all functions accept strings and write tests for it
- [x] parser model into per equation functions instead of single big functions
- [x] use krylov instead of linearsolve
- [x] implement for loops in model macro (e.g. to setup multi country models)
- [x] fix ss of pruned solution in plotsolution. seems detached
- [x] try solve first order with JuMP - doesnt work because JuMP cannot handle matrix constraints/objectives 
- [x] get solution higher order with multidimensional array (states, 1 and 2 partial derivatives variables names as dimensions in 2order case)
- [x] add pruning
- [x] add other outputs from estimation (smoothed, filter states and shocks)
- [x] shorten plot_irf (take inspiration from model estimate)
- [x] fix solution plot
- [x] see if we can avoid try catch and test for invertability instead
- [x] have Flux solve SS field #gradient descent based is worse than LM based
- [x] have parameters keyword accept Int and 2/3
- [x] plot_solution colors change from 2nd to 2rd order
- [x] custom LM: optimize for other RBC models, use third order backtracking
- [x] add SSS for third order (can be different than the one from 2nd order, see Gali (2015)) in solution plot; also put legend to the bottom as with Condition
- [x] check out Aqua.jl as additional tests
- [x] write tests and documentation for solution, estimation... making sure results are consistent
- [x] catch cases where you define calibration equation without declaring conditional variable
- [x] flag if equations contain no info for SS, suggest to set ss values as parameters
- [x] handle SS case where there are equations which have no information for the SS. use SS definitions in parameter block to complete system | no, set steady state values to parameters instead. might fail if redundant equation has y[0] - y[-1] instead of y[0] - y[ss]
- [x] try eval instead of runtimegeneratedfunctions; eval is slower but can be typed
- [x] check correctness of solution for models added
- [x] SpecialFunctions eta and gamma cause conflicts; consider importing used functions explicitly
- [x] bring the parsing of equations after the parameters macro
- [x] rewrite redundant var part so that it works with ss_aux_equations instead of ss_equations
- [x] catch cases where ss vars are set to zero. x[0] * eps_z[x] in SS becomes x[0] * 0 but should be just 0 (use sympy for this)
- [x] remove duplicate nonnegative aux vars to speed up SS solver
- [x] error when defining variable more than once in parameters macro
- [x] consolidate aux vars, use sympy to simplify
- [x] error when writing equations with only one variable
- [x] error when defining variable as parameter
- [x] more options for IRFs, simulate only certain shocks - set stds to 0 instead
- [x] add NBTOOLBOX, IRIS to overview
- [x] input field for SS init guess in all functions #not necessary so far. SS solver works out everything just fine
- [x] symbolic derivatives
- [x] check SW03 SS solver
- [x] more options for IRFs, pass on shock vector
- [x] write to dynare
- [x] add plot for policy function
- [x] add plot for FEVD
- [x] add functions like get_variance, get_sd, get_var, get_covar
- [x] add correlation, autocorrelation, and (conditional) variance decomposition
- [x] go through docs to reflect verbose behaviour
- [x] speed up covariance mat calc
- [x] have conditional parameters at end of entry as well (... | alpha instead of alpha | ...)
- [x] Get functions: get_output, get_moments
- [x] get rid of init_guess
- [x] an and schorfheide estimation
- [x] estimation, IRF matching, system priors
- [x] check derivative tests with finite diff
- [x] release first version
- [x] SS solve: add domain transformation optim
- [x] revisit optimizers for SS
- [x] figure out licenses
- [x] SS: replace variables in log() with auxilliary variable which must be positive to help solver
- [x] complex example with lags > 1, [ss], calib equations, aux nonneg vars
- [x] add NLboxsolve
- [x] try NonlinearSolve - fails due to missing bounds
- [x] make noneg aux part of optim problem for NLboxsolve in order to avoid DomainErrors - not necessary
- [x] have bounds on alpha (failed previously due to naming conflict) - works now

## Not high priority

- [ ] estimation codes with missing values (adopt kalman filter)
- [ ] decide on whether levels = false means deviations from NSSS or relevant SS
- [ ] whats a good error measure for higher order solutions (taking whole dist of future shock into account)? use mean error for n number of future shocks
- [ ] improve redundant calculations of SS and other parts of solution
- [ ] restructure functions and containers so that compiler knows what types to expect
- [ ] use RecursiveFactorization and TriangularSolve to solve, instead of MKL or OpenBLAS
- [ ] fix SnoopCompile with generated functions
- [ ] exploit variable incidence and compression for higher order derivatives
- [ ] for estimation use CUDA with st order: linear time iteration starting from last 1st order solution and then LinearSolveCUDA solvers for higher orders. this should bring benefits for large models and HANK models
- [ ] pull request in StatsFuns to have norminv... accept type numbers and add translation from matlab: norminv to StatsFuns norminvcdf
- [ ] more informative errors when declaring equations/ calibration
- [ ] unit equation errors
- [ ] implenent reduced linearised system solver + nonlinear
- [ ] implement HANK
- [ ] implement automatic problem derivation (gEcon)
- [ ] print legend for algorithm in last subplot of plot only
- [ ] select variables for moments

- [x] rewrite first order with riccati equation MatrixEquations.jl: not necessary/feasable see dynare package
- [x] test on highly [nonlinear model](https://www.sciencedirect.com/science/article/pii/S0165188917300970) # caldara et al is actually epstein zin wiht stochastic vol
- [x] conditional forecasting
- [x] find way to recover from failed SS solution which is written to init guess
- [x] redo ugly solution for selecting parameters to differentiate for
- [x] conditions for when to use which solution. if solution is outdated redo all solutions which have been done so far and use smart starting points
- [x] Revise 2,3 pert codes to make it more intuitive
- [x] implement blockdiag with julia package instead of python
- [x] Pretty print linear solution
- [x] write function to get_irfs
- [x] Named arrays for irf
- [x] write state space function for solution
- [x] Status print for model container
- [x] implenent 2nd + 3rd order perturbation
- [x] implement fuctions for distributions
- [x] try speedmapping.jl - no improvement
- [x] moment matching
- [x] write tests for higher order pert and standalone function
- [x] add compression back in
- [x] FixedPointAcceleration didnt improve on iterative procedure
- [x] add exogenous variables in lead or lag
- [x] regex in parser of SS and exo
- [x] test SS solver on SW07
- [x] change calibration, distinguish SS/dyn parameters
- [x] plot multiple solutions at same time (save them in separate constructs)
- [x] implement bounds in SS finder
- [x] map pars + vars impacting SS
- [x] check bounds when putting in new calibration
- [x] Save plot option
- [x] Add shock to plot title
- [x] print model name
