<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variance Decomposition · MacroModelling.jl</title><meta name="title" content="Variance Decomposition · MacroModelling.jl"/><meta property="og:title" content="Variance Decomposition · MacroModelling.jl"/><meta property="twitter:title" content="Variance Decomposition · MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../plotting/">Overview</a></li><li><a class="tocitem" href="../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../plot_conditional_forecast/">Conditional Forecasts</a></li><li class="is-active"><a class="tocitem" href>Variance Decomposition</a><ul class="internal"><li><a class="tocitem" href="#Periods-Argument"><span>Periods Argument</span></a></li><li><a class="tocitem" href="#Variables-to-Plot"><span>Variables to Plot</span></a></li><li><a class="tocitem" href="#Parameter-Values"><span>Parameter Values</span></a></li><li><a class="tocitem" href="#Plot-Attributes"><span>Plot Attributes</span></a></li><li><a class="tocitem" href="#Plots-Per-Page"><span>Plots Per Page</span></a></li><li><a class="tocitem" href="#Display-Plots"><span>Display Plots</span></a></li><li><a class="tocitem" href="#Saving-Plots"><span>Saving Plots</span></a></li><li><a class="tocitem" href="#Variable-and-Shock-Renaming-(rename-dictionary)"><span>Variable and Shock Renaming (rename dictionary)</span></a></li><li><a class="tocitem" href="#Verbose-Output"><span>Verbose Output</span></a></li><li><a class="tocitem" href="#Numerical-Tolerances"><span>Numerical Tolerances</span></a></li><li><a class="tocitem" href="#Quadratic-Matrix-Equation-Solver"><span>Quadratic Matrix Equation Solver</span></a></li></ul></li><li><a class="tocitem" href="../plot_model_estimates/">Model Estimates</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plotting</a></li><li class="is-active"><a href>Variance Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variance Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/plot_conditional_variance_decomposition.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conditional-Variance-Decomposition"><a class="docs-heading-anchor" href="#Conditional-Variance-Decomposition">Conditional Variance Decomposition</a><a id="Conditional-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-Variance-Decomposition" title="Permalink"></a></h1><p>The <code>plot_conditional_variance_decomposition</code> function visualizes the forecast error variance decomposition (FEVD), showing how much of the variance in forecast errors for each variable can be attributed to different shocks over various forecast horizons.</p><p>First, define and load a model:</p><pre><code class="language-julia hljs">@model Smets_Wouters_2007_linear begin
    a[0] = calfa * rkf[0] + (1 - calfa) * wf[0]
    zcapf[0] = rkf[0] * 1 / (czcap / (1 - czcap))
    rkf[0] = wf[0] + labf[0] - kf[0]
    kf[0] = zcapf[0] + kpf[-1]
    invef[0] = qs[0] + 1 / (1 + cgamma * cbetabar) * (pkf[0] * 1 / (csadjcost * cgamma ^ 2) + invef[-1] + invef[1] * cgamma * cbetabar)
    pkf[0] = b[0] * (1 / ((1 - chabb / cgamma) / (csigma * (1 + chabb / cgamma)))) - rrf[0] + rkf[1] * (crk / (crk + (1 - ctou))) + pkf[1] * ((1 - ctou) / (crk + (1 - ctou)))
    cf[0] = b[0] + cf[-1] * chabb / cgamma / (1 + chabb / cgamma) + cf[1] * 1 / (1 + chabb / cgamma) + (labf[0] - labf[1]) * ((csigma - 1) * cwhlc / (csigma  *(1 + chabb / cgamma))) - rrf[0] * (1 - chabb / cgamma) / (csigma * (1 + chabb / cgamma))
    yf[0] = g[0] + cf[0] * ccy + invef[0] * ciy + zcapf[0] * crkky
    yf[0] = cfc * (a[0] + calfa * kf[0] + (1 - calfa) * labf[0])
    wf[0] = labf[0] * csigl + cf[0] * 1 / (1 - chabb / cgamma) - cf[-1] * chabb / cgamma / (1 - chabb / cgamma)
    kpf[0] = kpf[-1] * (1 - cikbar) + invef[0] * cikbar + qs[0] * csadjcost * cgamma ^ 2 * cikbar
    mc[0] = calfa * rk[0] + (1 - calfa) * w[0] - a[0]
    zcap[0] = 1 / (czcap / (1 - czcap)) * rk[0]
    rk[0] = w[0] + lab[0] - k[0]
    k[0] = zcap[0] + kp[-1]
    inve[0] = qs[0] + 1 / (1 + cgamma * cbetabar) * (pk[0] * 1 / (csadjcost * cgamma ^ 2) + inve[-1] + inve[1] * cgamma * cbetabar)
    pk[0] = pinf[1] - r[0] + b[0] * 1 / ((1 - chabb / cgamma) / (csigma * (1 + chabb / cgamma))) + rk[1] * (crk / (crk + (1 - ctou))) + pk[1] * ((1 - ctou) / (crk + (1 - ctou)))
    c[0] = b[0] + c[-1] * chabb / cgamma / (1 + chabb / cgamma) + c[1] * 1 / (1 + chabb / cgamma) + 
    (lab[0] - lab[1]) * ((csigma - 1) * cwhlc / (csigma * (1 + chabb / cgamma))) - (r[0] - pinf[1]) * (1 - chabb / cgamma) / (csigma * (1 + chabb / cgamma))
    y[0] = g[0] + c[0] * ccy + inve[0] * ciy + zcap[0] * crkky
    y[0] = cfc * (a[0] + calfa * k[0] + (1 - calfa) * lab[0])
    pinf[0] = spinf[0] + 1 / (1 + cindp * cgamma * cbetabar) * (cindp * pinf[-1] + pinf[1] * cgamma * cbetabar + mc[0] * (1 - cprobp) * (1 - cprobp * cgamma * cbetabar) / cprobp / (1 + (cfc - 1) * curvp))
    w[0] = sw[0] + w[-1] * 1 / (1 + cgamma * cbetabar) + w[1] * cgamma * cbetabar / (1 + cgamma * cbetabar) + pinf[-1] * cindw / (1 + cgamma * cbetabar) - pinf[0] * (1 + cindw * cgamma * cbetabar) / (1 + cgamma * cbetabar) + pinf[1] * cgamma * cbetabar / (1 + cgamma * cbetabar) + (csigl * lab[0] + c[0] * 1 / (1 - chabb / cgamma) - c[-1] * chabb / cgamma / (1 - chabb / cgamma) - w[0]) * 1 / (1 + (clandaw - 1) * curvw) * (1 - cprobw) * (1 - cprobw * cgamma * cbetabar) / (cprobw * (1 + cgamma * cbetabar))
    r[0] = pinf[0] * crpi * (1 - crr) + (1 - crr) * cry * (y[0] - yf[0]) + crdy * (y[0] - yf[0] - y[-1] + yf[-1]) + crr * r[-1] + ms[0]
    a[0] = crhoa * a[-1] + z_ea * ea[x]
    b[0] = crhob * b[-1] + z_eb * eb[x]
    g[0] = crhog * g[-1] + z_eg * eg[x] + z_ea * ea[x] * cgy
    qs[0] = crhoqs * qs[-1] + z_eqs * eqs[x]
    ms[0] = crhoms * ms[-1] + z_em * em[x]
    spinf[0] = crhopinf * spinf[-1] + epinfma[0] - cmap * epinfma[-1]
    epinfma[0] = z_epinf * epinf[x]
    sw[0] = crhow * sw[-1] + ewma[0] - cmaw * ewma[-1]
    ewma[0] = z_ew * ew[x]
    kp[0] = kp[-1] * (1 - cikbar) + inve[0] * cikbar + qs[0] * csadjcost * cgamma ^ 2 * cikbar
    dy[0] = ctrend + y[0] - y[-1]
    dc[0] = ctrend + c[0] - c[-1]
    dinve[0] = ctrend + inve[0] - inve[-1]
    pinfobs[0] = constepinf + pinf[0]
    robs[0] = r[0] + conster
    dwobs[0] = ctrend + w[0] - w[-1]
    labobs[0] = lab[0] + constelab
end

@parameters Smets_Wouters_2007_linear begin
    ctou = .025
    clandaw = 1.5
    cg = 0.18
    curvp = 10
    curvw = 10
    calfa = .24
    csigma = 1.5
    cfc = 1.5
    cgy = 0.51
    csadjcost = 6.0144
    chabb = 0.6361
    cprobw = 0.8087
    csigl = 1.9423
    cprobp = 0.6
    cindw = 0.3243
    cindp = 0.47
    czcap = 0.2696
    crpi = 1.488
    crr = 0.8762
    cry = 0.0593
    crdy = 0.2347
    crhoa = 0.9977
    crhob = 0.5799
    crhog = 0.9957
    crhoqs = 0.7165
    crhoms = 0
    crhopinf = 0
    crhow = 0
    cmap = 0
    cmaw = 0
    constelab = 0
    constepinf = 0.7
    constebeta = 0.7420
    ctrend = 0.3982
    z_ea    = 0.4618
    z_eb    = 1.8513
    z_eg    = 0.6090
    z_em    = 0.2397
    z_ew    = 0.2089
    z_eqs   = 0.6017
    z_epinf = 0.1455
    cpie    = 1 + constepinf / 100                                                                      # gross inflation rate
    cgamma  = 1 + ctrend / 100                                                                          # gross growth rate
    cbeta   = 1 / (1 + constebeta / 100)                                                                # discount factor
    clandap = cfc                                                                                       # fixed cost share/gross price markup
    cbetabar= cbeta * cgamma ^ (-csigma)                                                                # growth-adjusted discount factor in Euler equation
    cr      = cpie / cbetabar                                                                           # steady state gross real interest rate
    crk     = 1 / cbetabar - (1 - ctou)                                                                 # steady state rental rate
    cw      = (calfa ^ calfa * (1 - calfa) ^ (1 - calfa) / (clandap * crk ^ calfa)) ^ (1 / (1 - calfa)) # steady state real wage
    cikbar  = 1 - (1 - ctou) / cgamma                                                                   # (1-k_1) in equation LOM capital, equation (8)
    cik     = cikbar * cgamma                                                                           # i_k: investment-capital ratio
    clk     = (1 - calfa) / calfa * crk / cw                                                            # labor to capital ratio
    cky     = cfc * clk ^ (calfa - 1)                                                                   # k_y: steady state output ratio
    ciy     = cik * cky                                                                                 # investment-output ratio
    ccy     = 1 - cg - cik * cky                                                                        # consumption-output ratio
    crkky   = crk * cky                                                                                 # z_y=R_{*}^k*k_y
    cwhlc   = (1 / clandaw) * (1 - calfa) / calfa * crk * cky / ccy                                     # W^{h}_{*}*L_{*}/C_{*} used in c_2 in equation (2)
    conster = (cr - 1) * 100                                                                            # steady state federal funds rate ($\bar r$)
end</code></pre><p>Calling the conditional variance decomposition plot function:</p><pre><code class="language-julia hljs">plot_conditional_variance_decomposition(Smets_Wouters_2007_linear)</code></pre><p><img src="../assets/fevd__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD"/></p><p>This creates conditional variance decomposition plots showing the contribution of each shock to the forecast error variance of each variable across different forecast horizons.</p><p>The vertical axis shows the share of the shocks variance contribution, and the horizontal axis the period of the variance decomposition. The stacked bars represent each shocks variance contribution at a specific time horizon.</p><p>Note that if occasionally binding constraints are present in the model, they are not taken into account here.</p><p>The same function can be called using different names. For example: <code>plot_fevd</code>, or <code>plot_forecast_error_variance_decomposition</code>. Going forward, <code>plot_fevd</code> will be used for brevity.</p><h2 id="Periods-Argument"><a class="docs-heading-anchor" href="#Periods-Argument">Periods Argument</a><a id="Periods-Argument-1"></a><a class="docs-heading-anchor-permalink" href="#Periods-Argument" title="Permalink"></a></h2><p>The <code>periods</code> argument (default: <code>40</code>, type: <code>Int</code>) specifies the number of forecast horizons to include in the variance decomposition. This determines how far into the future the decomposition extends.</p><pre><code class="language-julia hljs"># Show variance decomposition up to 12 periods ahead
plot_fevd(Smets_Wouters_2007_linear, periods = 12)</code></pre><p><img src="../assets/short_period__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - 12 periods"/></p><h2 id="Variables-to-Plot"><a class="docs-heading-anchor" href="#Variables-to-Plot">Variables to Plot</a><a id="Variables-to-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-to-Plot" title="Permalink"></a></h2><p>The <code>variables</code> argument (default: <code>:all</code>) specifies for which variables to show results. Variable names can be specified as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> includes all variables except auxiliary variables and those related to occasionally binding constraints (OBC). <code>:all_excluding_obc</code> includes all variables except those related to occasionally binding constraints. <code>:all</code> includes all variables.</p><p>Specific variables can be selected to plot. The following example selects output <code>Y</code>, consumption <code>c</code>, investment <code>inve</code>, inflation <code>pinf</code>, wages <code>w</code>, and labor <code>lab</code> using a <code>Vector</code> of <code>Symbol</code>s:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = [:inve, :c, :y, :pinf, :w, :lab])</code></pre><p><img src="../assets/var_select__Smets_Wouters_2007_linear__1.png" alt="Smets and Wouters 2007 FEVD - selected variables"/></p><p>The plot now displays only one plot with the six selected variables (sorted alphabetically).</p><p>The same can be done using a <code>Tuple</code>:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = (:inve, :c, :y, :pinf, :w, :lab))</code></pre><p>a <code>Matrix</code>:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = [:inve :c :y :pinf :w :lab])</code></pre><p>or providing the variable names as <code>String</code>s:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = [&quot;inve&quot;, &quot;c&quot;, &quot;y&quot;, &quot;pinf&quot;, &quot;w&quot;, &quot;lab&quot;])</code></pre><p>or a single variable as a <code>Symbol</code>:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = :inve)</code></pre><p>or as a <code>String</code>:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = &quot;inve&quot;)</code></pre><p>Then there are some predefined options:</p><p><code>:all_excluding_auxiliary_and_obc</code> plots all variables except auxiliary variables and those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = :all_excluding_auxiliary_and_obc)</code></pre><p><code>:all_excluding_obc</code> plots all variables except those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = :all_excluding_obc)</code></pre><p>To see auxiliary variables, use a model that defines them. The <code>FS2000</code> model can be used:</p><pre><code class="language-julia hljs">@model FS2000 begin
    dA[0] = exp(gam + z_e_a  *  e_a[x])
    log(m[0]) = (1 - rho) * log(mst)  +  rho * log(m[-1]) + z_e_m  *  e_m[x]
    - P[0] / (c[1] * P[1] * m[0]) + bet * P[1] * (alp * exp( - alp * (gam + log(e[1]))) * k[0] ^ (alp - 1) * n[1] ^ (1 - alp) + (1 - del) * exp( - (gam + log(e[1])))) / (c[2] * P[2] * m[1])=0
    W[0] = l[0] / n[0]
    - (psi / (1 - psi)) * (c[0] * P[0] / (1 - n[0])) + l[0] / n[0] = 0
    R[0] = P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ ( - alp) / W[0]
    1 / (c[0] * P[0]) - bet * P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) / (m[0] * l[0] * c[1] * P[1]) = 0
    c[0] + k[0] = exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) + (1 - del) * exp( - (gam + z_e_a  *  e_a[x])) * k[-1]
    P[0] * c[0] = m[0]
    m[0] - 1 + d[0] = l[0]
    e[0] = exp(z_e_a  *  e_a[x])
    y[0] = k[-1] ^ alp * n[0] ^ (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x]))
    gy_obs[0] = dA[0] * y[0] / y[-1]
    gp_obs[0] = (P[0] / P[-1]) * m[-1] / dA[0]
    log_gy_obs[0] = log(gy_obs[0])
    log_gp_obs[0] = log(gp_obs[0])
end

@parameters FS2000 begin
    alp     = 0.356
    bet     = 0.993
    gam     = 0.0085
    mst     = 1.0002
    rho     = 0.129
    psi     = 0.65
    del     = 0.01
    z_e_a   = 0.035449
    z_e_m   = 0.008862
end</code></pre><p>Since both <code>c</code> and <code>P</code> appear in <code>t+2</code>, they generate auxiliary variables in the model. Plotting the policy functions for all variables excluding OBC-related ones means auxiliary variables are shown (same for the default <code>:all</code> option since there are no OBCs in this model):</p><pre><code class="language-julia hljs">plot_fevd(FS2000,
    variables = :all_excluding_obc)</code></pre><p><img src="../assets/aux__FS2000__1.png" alt="FS2000 FEVD - including auxiliary variables"/></p><p>Both <code>c</code> and <code>P</code> appear twice: once as the variable itself and once as an auxiliary variable with the <code>ᴸ⁽¹⁾</code> superscript, representing the value of the variable in <code>t+1</code> as expected in <code>t</code>.</p><p><code>:all</code> (default) plots all variables including auxiliary variables. Since OBCs are not considered with FEVD, variables used to enforce occasionally binding constraints (OBC) are not included.</p><pre><code class="language-julia hljs">plot_fevd(FS2000)</code></pre><h2 id="Parameter-Values"><a class="docs-heading-anchor" href="#Parameter-Values">Parameter Values</a><a id="Parameter-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Values" title="Permalink"></a></h2><p>When no parameters are provided, the solution uses the previously defined parameter values. Parameters can be provided as a <code>Vector</code> of values, or as a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s mapping parameter <code>Symbol</code>s or <code>String</code>s to values. The solution is recalculated when new parameter values differ from the previous ones.</p><p>Start by changing the discount factor <code>z_eg</code> to 1:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    parameters = :z_eg =&gt; 1)</code></pre><p><img src="../assets/param_change__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - different parameter values"/></p><p>The shock contributions changed as a result of changing the shock standard deviation.</p><p>Multiple parameters can also be changed simultaneously. This example changes <code>z_eg</code> to 1.5 and <code>crpi</code> to 1.75 using a <code>Tuple</code> of <code>Pair</code>s and define the variables with <code>Symbol</code>s:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    parameters = (:z_eg =&gt; 1.5, :crpi =&gt; 1.75))</code></pre><p><img src="../assets/param_change_2__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - multiple parameter changes"/></p><p>A <code>Vector</code> of <code>Pair</code>s can also be used:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    parameters = [:z_eg =&gt; 1.5, :crpi =&gt; 1.75])</code></pre><p>Alternatively, use a <code>Vector</code> of parameter values in the order they were defined in the model. To obtain them:</p><pre><code class="language-julia hljs">params = get_parameters(Smets_Wouters_2007_linear, values = true)

param_vals = [p[2] for p in params]

plot_fevd(Smets_Wouters_2007_linear,
    parameters = param_vals)</code></pre><h2 id="Plot-Attributes"><a class="docs-heading-anchor" href="#Plot-Attributes">Plot Attributes</a><a id="Plot-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Attributes" title="Permalink"></a></h2><p>The <code>plot_attributes</code> argument (default: <code>Dict()</code>, type: <code>Dict</code>) accepts a dictionary of attributes passed on to the plotting function. See the Plots.jl documentation for details.</p><p>The color palette can be customized using the <code>plot_attributes</code> argument. The following example defines a custom color palette (inspired by the European Commission&#39;s economic reports) to plot the FEVD using the <code>Smets_Wouters_2007_linear</code> model. First, define the custom color palette using hex color codes:</p><pre><code class="language-julia hljs">ec_color_palette =
[
    &quot;#FFD724&quot;,  # &quot;Sunflower Yellow&quot;
    &quot;#353B73&quot;,  # &quot;Navy Blue&quot;
    &quot;#2F9AFB&quot;,  # &quot;Sky Blue&quot;
    &quot;#B8AAA2&quot;,  # &quot;Taupe Grey&quot;
    &quot;#E75118&quot;,  # &quot;Vermilion&quot;
    &quot;#6DC7A9&quot;,  # &quot;Mint Green&quot;
    &quot;#F09874&quot;,  # &quot;Coral&quot;
    &quot;#907800&quot;   # &quot;Olive&quot;
]</code></pre><p>Next, plot the FEVD using the custom color palette:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    plot_attributes = Dict(:palette =&gt; ec_color_palette))</code></pre><p><img src="../assets/color_palette__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - custom color palette"/></p><p>The colors of the shock contributions now follow the custom color palette.</p><p>Other attributes such as the font family can also be modified (see here for <a href="https://github.com/JuliaPlots/Plots.jl/blob/v1.41.1/src/backends/gr.jl#L61">GR font options</a>):</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    plot_attributes = Dict(:fontfamily =&gt; &quot;computer modern&quot;))</code></pre><p><img src="../assets/font_family__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - custom font"/></p><p>All text in the plot now uses the Computer Modern font. Note that font rendering inherits the constraints of the plotting backend (GR in this case).</p><p>Here is another example that customizes the alpha (transparency) of the filled areas in the FEVD plots:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    plot_attributes = Dict(:fillalpha =&gt; .5))</code></pre><p><img src="../assets/fill_alpha__Smets_Wouters_2007_linear__2.png" alt="Smets and Wouters 2007 FEVD - custom fill alpha"/></p><h2 id="Plots-Per-Page"><a class="docs-heading-anchor" href="#Plots-Per-Page">Plots Per Page</a><a id="Plots-Per-Page-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-Per-Page" title="Permalink"></a></h2><p>The <code>plots_per_page</code> argument (default: <code>9</code>, type: <code>Int</code>) controls the number of subplots per page. When the number of variables exceeds this value, multiple pages are created. The following example selects 6 variables and sets <code>plots_per_page</code> to 4, resulting in 2 pages with the first page having 4 subplots and the second page having 2 subplots:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    variables = [:inve, :c, :y, :pinf, :w, :lab],
    plots_per_page = 4)</code></pre><p><img src="../assets/four_per_page__Smets_Wouters_2007_linear__1.png" alt="Smets and Wouters 2007 FEVD - 4 plots per page"/></p><p>The first page displays the first four variables (sorted alphabetically) with two subplots for each shock. The title indicates this is page 1 of 2.</p><h2 id="Display-Plots"><a class="docs-heading-anchor" href="#Display-Plots">Display Plots</a><a id="Display-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Display-Plots" title="Permalink"></a></h2><p>The <code>show_plots</code> argument (default: <code>true</code>, type: <code>Bool</code>), when <code>true</code>, displays the plots; otherwise, they are only returned as an object.</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    show_plots = false)</code></pre><h2 id="Saving-Plots"><a class="docs-heading-anchor" href="#Saving-Plots">Saving Plots</a><a id="Saving-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Plots" title="Permalink"></a></h2><p>The <code>save_plots</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, saves the plots to disk; otherwise, they are only displayed and returned as an object.</p><p>Related arguments control the saving behavior:</p><ul><li><code>save_plots_format</code> (default: <code>:pdf</code>, type: <code>Symbol</code>): output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> (default: <code>&quot;.&quot;</code>, type: <code>String</code>): path where plots are saved. If the path does not exist, it will be created automatically.</li><li><code>save_plots_name</code> (default: <code>&quot;fevd&quot;</code>, type: <code>Union{String, Symbol}</code>): prefix prepended to the filename when saving plots.</li></ul><p>Each plot is saved as a separate file with a name indicating the prefix, model name, shocks, and a sequential number for multiple plots (e.g., <code>fevd__ModelName__1.pdf</code>).</p><p>The following example saves all policy functions for the <code>Smets_Wouters_2007_linear</code> model as PNG files in the <code>../plots</code> directory with <code>fevd_plot</code> as the filename prefix:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    save_plots = true,
    save_plots_format = :png,
    save_plots_path = &quot;./../plots&quot;,
    save_plots_name = :fevd_plot)</code></pre><p>The plots appear in the specified folder with the specified prefix. Each plot is saved in a separate file with a name reflecting the model, the shock, and a sequential index when the number of variables exceeds the plots per page.</p><h2 id="Variable-and-Shock-Renaming-(rename-dictionary)"><a class="docs-heading-anchor" href="#Variable-and-Shock-Renaming-(rename-dictionary)">Variable and Shock Renaming (rename dictionary)</a><a id="Variable-and-Shock-Renaming-(rename-dictionary)-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-and-Shock-Renaming-(rename-dictionary)" title="Permalink"></a></h2><p>The <code>rename_dictionary</code> argument (default: <code>Dict()</code>, type: <code>AbstractDict{&lt;:Union{Symbol, String}, &lt;:Union{Symbol, String}}</code>) maps variable or shock symbols to custom display names in plots. This is particularly useful when comparing models with different variable naming conventions, allowing them to be displayed with consistent labels.</p><p>For example, to rename variables for clearer display:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
        rename_dictionary = Dict(
            :y =&gt; &quot;Output&quot;, 
            :pinfobs =&gt; &quot;Inflation&quot;, 
            :robs =&gt; &quot;Interest Rate&quot;, 
            :inve =&gt; &quot;Investment&quot;, 
            :c =&gt; &quot;Consumption&quot;, 
            :w =&gt; &quot;Wages&quot;, 
            :lab =&gt; &quot;Labor&quot;
        ))</code></pre><p><img src="../assets/rename_dict_fevd__Smets_Wouters_2007_linear__1.png" alt="Smets and Wouters 2007 FEVD - rename dictionary"/></p><p>The <code>rename_dictionary</code> accepts flexible type combinations for keys and values—both <code>Symbol</code> and <code>String</code> types work interchangeably:</p><pre><code class="language-julia hljs"># All of these are valid and equivalent:
Dict(:y =&gt; &quot;Output&quot;)              # Symbol key, String value
Dict(&quot;y&quot; =&gt; &quot;Output&quot;)             # String key, String value
Dict(:y =&gt; :Output)               # Symbol key, Symbol value
Dict(&quot;y&quot; =&gt; :Output)              # String key, Symbol value</code></pre><p>This flexibility is particularly useful for models like <code>Backus_Kehoe_Kydland_1992</code>, which uses <code>String</code> representations of variable and shock names (because of <code>{}</code>):</p><pre><code class="language-julia hljs"># Define the Backus model (abbreviated for clarity)
@model Backus_Kehoe_Kydland_1992 begin
    for co in [H, F]
        Y{co}[0] = ((LAMBDA{co}[0] * K{co}[-4]^theta{co} * N{co}[0]^(1-theta{co}))^(-nu{co}) + sigma{co} * Z{co}[-1]^(-nu{co}))^(-1/nu{co})
        K{co}[0] = (1-delta{co})*K{co}[-1] + S{co}[0]
        X{co}[0] = for lag in (-4+1):0 phi{co} * S{co}[lag] end
        A{co}[0] = (1-eta{co}) * A{co}[-1] + N{co}[0]
        L{co}[0] = 1 - alpha{co} * N{co}[0] - (1-alpha{co})*eta{co} * A{co}[-1]
        U{co}[0] = (C{co}[0]^mu{co}*L{co}[0]^(1-mu{co}))^gamma{co}
        psi{co} * mu{co} / C{co}[0]*U{co}[0] = LGM[0]
        psi{co} * (1-mu{co}) / L{co}[0] * U{co}[0] * (-alpha{co}) = - LGM[0] * (1-theta{co}) / N{co}[0] * (LAMBDA{co}[0] * K{co}[-4]^theta{co}*N{co}[0]^(1-theta{co}))^(-nu{co})*Y{co}[0]^(1+nu{co})

        for lag in 0:(4-1)  
            beta{co}^lag * LGM[lag]*phi{co}
        end +
        for lag in 1:4
            -beta{co}^lag * LGM[lag] * phi{co} * (1-delta{co})
        end = beta{co}^4 * LGM[+4] * theta{co} / K{co}[0] * (LAMBDA{co}[+4] * K{co}[0]^theta{co} * N{co}[+4]^(1-theta{co})) ^ (-nu{co})* Y{co}[+4]^(1+nu{co})

        LGM[0] = beta{co} * LGM[+1] * (1+sigma{co} * Z{co}[0]^(-nu{co}-1)*Y{co}[+1]^(1+nu{co}))
        NX{co}[0] = (Y{co}[0] - (C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1]))/Y{co}[0]
    end

    (LAMBDA{H}[0]-1) = rho{H}{H}*(LAMBDA{H}[-1]-1) + rho{H}{F}*(LAMBDA{F}[-1]-1) + Z_E{H} * E{H}[x]
    (LAMBDA{F}[0]-1) = rho{F}{F}*(LAMBDA{F}[-1]-1) + rho{F}{H}*(LAMBDA{H}[-1]-1) + Z_E{F} * E{F}[x]

    for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end
end

@parameters Backus_Kehoe_Kydland_1992 begin
    K_ss = 11
    K[ss] = K_ss | beta
    
    mu      =    0.34
    gamma   =    -1.0
    alpha   =    1
    eta     =    0.5
    theta   =    0.36
    nu      =    3
    sigma   =    0.01
    delta   =    0.025
    phi     =    1/4
    psi     =    0.5

    Z_E = 0.00852
    
    rho{H}{H} = 0.906
    rho{F}{F} = rho{H}{H}
    rho{H}{F} = 0.088
    rho{F}{H} = rho{H}{F}
end

# Backus model example showing String to String mapping
plot_fevd(Backus_Kehoe_Kydland_1992,
    rename_dictionary = Dict(&quot;K{H}&quot; =&gt; &quot;Capital (Home)&quot;, 
                             &quot;K{F}&quot; =&gt; &quot;Capital (Foreign)&quot;,
                             &quot;Y{H}&quot; =&gt; &quot;Output (Home)&quot;,
                             &quot;Y{F}&quot; =&gt; &quot;Output (Foreign)&quot;))</code></pre><p><img src="../assets/rename_dict_string__Backus_Kehoe_Kydland_1992__1.png" alt="Backus, Kehoe, Kydland 1992 FEVD - rename dictionary"/></p><p>Variables or shocks not included in the dictionary retain their default names. The renaming applies to all plot elements including legends, axis labels, and tables.</p><h2 id="Verbose-Output"><a class="docs-heading-anchor" href="#Verbose-Output">Verbose Output</a><a id="Verbose-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Verbose-Output" title="Permalink"></a></h2><p>The <code>verbose</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, enables verbose output related to solving the model</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    verbose = true)</code></pre><p>The code outputs information about solving the steady state blocks. When parameters change, the first-order solution is recomputed; otherwise, it uses the cached solution:</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    parameters = :z_eg =&gt; 1.05,
    verbose = true)
# Parameter changes: 
#         z_eg    from 1.5        to 1.05
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 1.776217186138026e-21
# Block: 2, - Solved using previous solution; residual norm: 6.83217016268833e-19
# Quadratic matrix equation solver previous solution has tolerance: 2.25183977733317e-15</code></pre><h2 id="Numerical-Tolerances"><a class="docs-heading-anchor" href="#Numerical-Tolerances">Numerical Tolerances</a><a id="Numerical-Tolerances-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Tolerances" title="Permalink"></a></h2><p>The <code>tol</code> argument (default: <code>Tolerances()</code>, type: <code>Tolerances</code>) defines various tolerances for the algorithm used to solve the model. See the Tolerances documentation for more details: <code>?Tolerances</code>. The tolerances used by the numerical solvers can be adjusted. The Tolerances object allows setting tolerances for the non-stochastic steady state solver (NSSS), Sylvester equations, Lyapunov equation, and quadratic matrix equation (QME). For example, to set tighter tolerances (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">custom_tol = Tolerances(qme_acceptance_tol = 1e-12,
    sylvester_acceptance_tol = 1e-12)

plot_fevd(Smets_Wouters_2007_linear,
    tol = custom_tol,
    parameters = :z_eg =&gt; 1.055,
    verbose = true)
# Parameter changes: 
#         z_eg    from 1.05       to 1.055
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 1.776217186138026e-21
# Block: 2, - Solved using previous solution; residual norm: 6.83217016268833e-19
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 2.25183977733317e-15</code></pre><p>This is useful when higher precision is needed or when the default tolerances are insufficient for convergence. Use this argument for specific needs or when encountering issues with the default solver.</p><h2 id="Quadratic-Matrix-Equation-Solver"><a class="docs-heading-anchor" href="#Quadratic-Matrix-Equation-Solver">Quadratic Matrix Equation Solver</a><a id="Quadratic-Matrix-Equation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Matrix-Equation-Solver" title="Permalink"></a></h2><p>The <code>quadratic_matrix_equation_algorithm</code> argument (default: <code>:schur</code>, type: <code>Symbol</code>) specifies the algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code> The quadratic matrix equation solver is used internally when solving the model to first order. Different algorithms are available. The <code>:schur</code> algorithm is generally faster and more reliable, while <code>:doubling</code> can be more precise in some cases (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">plot_fevd(Smets_Wouters_2007_linear,
    quadratic_matrix_equation_algorithm = :doubling,
    parameters = :z_eg =&gt; 1.0555,
    verbose = true)
# Parameter changes: 
#         z_eg    from 1.055      to 1.0555
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 1.776217186138026e-21
# Block: 2, - Solved using previous solution; residual norm: 6.83217016268833e-19
# Quadratic matrix equation solver previous solution has tolerance: 2.25183977733317e-15</code></pre><p>For most use cases, the default <code>:schur</code> algorithm is recommended. Use this argument for specific needs or when encountering issues with the default solver.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plot_conditional_forecast/">« Conditional Forecasts</a><a class="docs-footer-nextpage" href="../plot_model_estimates/">Model Estimates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 11:56">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
