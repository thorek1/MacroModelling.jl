<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Impulse Response Functions ¬∑ MacroModelling.jl</title><meta name="title" content="Impulse Response Functions ¬∑ MacroModelling.jl"/><meta property="og:title" content="Impulse Response Functions ¬∑ MacroModelling.jl"/><meta property="twitter:title" content="Impulse Response Functions ¬∑ MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../plotting/">Overview</a></li><li class="is-active"><a class="tocitem" href>Impulse Response Functions</a><ul class="internal"><li><a class="tocitem" href="#Combine-or-compare-IRFs-with-plot_irf!"><span>Combine or compare IRFs with <code>plot_irf!</code></span></a></li><li><a class="tocitem" href="#Solution-Algorithm"><span>Solution Algorithm</span></a></li><li><a class="tocitem" href="#Initial-State"><span>Initial State</span></a></li><li><a class="tocitem" href="#Shocks"><span>Shocks</span></a></li><li><a class="tocitem" href="#Simulation-Periods"><span>Simulation Periods</span></a></li><li><a class="tocitem" href="#Shock-Size"><span>Shock Size</span></a></li><li><a class="tocitem" href="#Negative-Shocks"><span>Negative Shocks</span></a></li><li><a class="tocitem" href="#Variables-to-Plot"><span>Variables to Plot</span></a></li><li><a class="tocitem" href="#Parameter-Values"><span>Parameter Values</span></a></li><li><a class="tocitem" href="#Ignoring-Occasionally-Binding-Constraints"><span>Ignoring Occasionally Binding Constraints</span></a></li><li><a class="tocitem" href="#Generalized-Impulse-Response-Functions"><span>Generalized Impulse Response Functions</span></a></li><li><a class="tocitem" href="#Generalized-Impulse-Response-Function-Options"><span>Generalized Impulse Response Function Options</span></a></li><li><a class="tocitem" href="#Plot-Labels"><span>Plot Labels</span></a></li><li><a class="tocitem" href="#Plot-Type"><span>Plot Type</span></a></li><li><a class="tocitem" href="#Plot-Attributes"><span>Plot Attributes</span></a></li><li><a class="tocitem" href="#Plots-Per-Page"><span>Plots Per Page</span></a></li><li><a class="tocitem" href="#Display-Plots"><span>Display Plots</span></a></li><li><a class="tocitem" href="#Saving-Plots"><span>Saving Plots</span></a></li><li><a class="tocitem" href="#Variable-and-Shock-Renaming-(rename-dictionary)"><span>Variable and Shock Renaming (rename dictionary)</span></a></li><li><a class="tocitem" href="#Verbose-Output"><span>Verbose Output</span></a></li><li><a class="tocitem" href="#Numerical-Tolerances"><span>Numerical Tolerances</span></a></li><li><a class="tocitem" href="#Quadratic-Matrix-Equation-Solver"><span>Quadratic Matrix Equation Solver</span></a></li><li><a class="tocitem" href="#Sylvester-Equation-Solver"><span>Sylvester Equation Solver</span></a></li></ul></li><li><a class="tocitem" href="../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../plot_conditional_forecast/">Conditional Forecasts</a></li><li><a class="tocitem" href="../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../plot_model_estimates/">Model Estimates</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plotting</a></li><li class="is-active"><a href>Impulse Response Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Impulse Response Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/plot_irf.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Impulse-Response-Functions-(IRF)"><a class="docs-heading-anchor" href="#Impulse-Response-Functions-(IRF)">Impulse Response Functions (IRF)</a><a id="Impulse-Response-Functions-(IRF)-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions-(IRF)" title="Permalink"></a></h1><p>Calling <code>plot_irf</code> computes IRFs for <strong>every exogenous shock</strong> and <strong>every endogenous variable</strong> by default, using the model&#39;s default solution method (first-order perturbation) and a <strong>one-standard-deviation positive</strong> shock.</p><p>First, define and load a model:</p><pre><code class="language-julia hljs">@model Gali_2015_chapter_3_nonlinear begin
    W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ
    Q[0] = Œ≤ * (C[1] / C[0]) ^ (-œÉ) * Z[1] / Z[0] / Pi[1]
    R[0] = 1 / Q[0]
    Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)
    R[0] = Pi[1] * realinterest[0]
    R[0] = 1 / Œ≤ * Pi[0] ^ œï·µñ‚Å± * (Y[0] / Y[ss]) ^ œï ∏ * exp(nu[0])
    C[0] = Y[0]
    log(A[0]) = œÅ_a * log(A[-1]) + std_a * eps_a[x]
    log(Z[0]) = œÅ_z * log(Z[-1]) - std_z * eps_z[x]
    nu[0] = œÅ_ŒΩ * nu[-1] + std_nu * eps_nu[x]
    MC[0] = W_real[0] / (S[0] * Y[0] * (1 - Œ±) / N[0])
    1 = Œ∏ * Pi[0] ^ (œµ - 1) + (1 - Œ∏) * Pi_star[0] ^ (1 - œµ)
    S[0] = (1 - Œ∏) * Pi_star[0] ^ (( - œµ) / (1 - Œ±)) + Œ∏ * Pi[0] ^ (œµ / (1 - Œ±)) * S[-1]
    Pi_star[0] ^ (1 + œµ * Œ± / (1 - Œ±)) = œµ * x_aux_1[0] / x_aux_2[0] * (1 - œÑ) / (œµ - 1)
    x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ + Œ± * œµ / (1 - Œ±)) * x_aux_1[1]
    x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ - 1) * x_aux_2[1]
    log_y[0] = log(Y[0])
    log_W_real[0] = log(W_real[0])
    log_N[0] = log(N[0])
    pi_ann[0] = 4 * log(Pi[0])
    i_ann[0] = 4 * log(R[0])
    r_real_ann[0] = 4 * log(realinterest[0])
    M_real[0] = Y[0] / R[0] ^ Œ∑
end

@parameters Gali_2015_chapter_3_nonlinear begin
    œÉ = 1
    œÜ = 5
    œï·µñ‚Å± = 1.5
    œï ∏ = 0.125
    Œ∏ = 0.75
    œÅ_ŒΩ = 0.5
    œÅ_z = 0.5
    œÅ_a = 0.9
    Œ≤ = 0.99
    Œ∑ = 3.77
    Œ± = 0.25
    œµ = 9
    œÑ = 0
    std_a = .01
    std_z = .05
    std_nu = .0025
end</code></pre><p>Now, plot the IRFs using the default settings:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear)</code></pre><p><img src="../assets/default_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock"/></p><p>The plots display every endogenous variable affected for each exogenous shock. Each page consists of multiple subplots, one per variable, and shows the response for a single shock at a time (mentioned in the title). The title includes the model name, shock identifier, sign of the impulse (positive by default), and the page indicator (e.g., <code>(1/3)</code>). Each subplot shows the steady state as a horizontal reference line (non-stochastic for first-order solutions, stochastic for higher orders). For strictly positive variables, a secondary axis displays percentage deviations.</p><h2 id="Combine-or-compare-IRFs-with-plot_irf!"><a class="docs-heading-anchor" href="#Combine-or-compare-IRFs-with-plot_irf!">Combine or compare IRFs with <code>plot_irf!</code></a><a id="Combine-or-compare-IRFs-with-plot_irf!-1"></a><a class="docs-heading-anchor-permalink" href="#Combine-or-compare-IRFs-with-plot_irf!" title="Permalink"></a></h2><p>The <code>plot_irf!</code> function (note the exclamation mark <code>!</code>) adds additional IRFs to an existing plot created with <code>plot_irf</code>, enabling direct comparison between different scenarios. Any input argument that affects the model&#39;s output (such as solution algorithm, parameter values, shocks, or initial states) can be varied to compare how these changes influence the impulse response functions. See the respective subsections below (e.g., <a href="#solution-algorithm">Solution Algorithm</a>, <a href="#parameter-values">Parameter Values</a>) for details on specific arguments.</p><p>When using <code>plot_irf!</code>, the new IRF can be either overlaid for comparison (default) or stacked to show cumulative effects, depending on the <code>plot_type</code> argument (see <a href="#plot-type">Plot Type</a>).</p><p><strong>Legend and table behavior:</strong></p><ul><li>When inputs differ in <strong>one dimension</strong> (e.g., only the algorithm changes), the legend displays the value of that input dimension for each line (e.g., <code>:first_order</code>, <code>:second_order</code>).</li><li>When inputs differ in <strong>multiple dimensions</strong> (e.g., both algorithm and parameters change), the legend shows sequential numbers (1, 2, 3, ...) and references a table below the plot that details all input differences for each numbered scenario.</li><li>A separate table below shows the relevant steady state values for each scenario to help identify differences across solution methods or parameter values.</li></ul><p><strong>Example with single input difference:</strong></p><p>When only one input differs (e.g., the solution algorithm), the legend shows the algorithm names directly:</p><pre><code class="language-julia hljs"># Plot first-order solution
plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a)

# Add second-order solution to the same plot
plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :second_order)</code></pre><p><img src="../assets/compare_orders_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (first vs second order)"/></p><p>The legend will display <code>:first_order</code> and <code>:second_order</code> to identify each line.</p><p>The subplot y-axis labels change depending on the steady state values for each scenario. If the steady state values differ for a variable across scenarios, the y-axis label will indicate that the lines are in absolute deviations from the steady state. In that case no percent deviation is shown on the secondary y-axis, as the steady state values differ. In case the steady state values are the same across scenarios, the y-axis label indicates absolute levels on the primary y-axis and if the values are strictly positive the secondary y-axis shows the percent deviation scale.</p><p><strong>Example with multiple input differences:</strong></p><p>When multiple inputs differ (e.g., both algorithm and parameters), the legend shows sequential numbers and a table details the differences:</p><pre><code class="language-julia hljs"># Plot with baseline parameters
plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = :Œ≤ =&gt; 0.99,
    shocks = :eps_a)

# Add with different algorithm AND parameters
plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = :Œ≤ =&gt; 0.95,
    shocks = :eps_a,
    algorithm = :second_order)</code></pre><p><img src="../assets/compare_beta_and_orders__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (comparing Œ≤ values across algorithms)"/></p><p>The legend will show <code>1</code> and <code>2</code>, with a table below the plot listing the parameter and algorithm values for each scenario.</p><h2 id="Solution-Algorithm"><a class="docs-heading-anchor" href="#Solution-Algorithm">Solution Algorithm</a><a id="Solution-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Algorithm" title="Permalink"></a></h2><p>IRFs can be plotted using different solution algorithms. The following example uses a second-order perturbation solution:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :second_order)</code></pre><p><img src="../assets/second_order_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock (second order)"/></p><p>The most notable difference is that at second order, dynamics are observed for <code>S</code>, which remains constant at first order (under certainty equivalence). Additionally, the steady state levels change because the stochastic steady state incorporates precautionary behavior (see horizontal lines).</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a)</code></pre><p><img src="../assets/first_order_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock (first order)"/></p><p>To compare the two solution methods side by side, use <code>plot_irf!</code> to add to an existing plot:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :second_order)</code></pre><p><img src="../assets/compare_orders_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (first vs second order)"/></p><p>The plots now show both solution methods overlaid. The first-order solution is shown in blue, the second-order solution in red, as indicated in the legend below the plot. Note that the steady state levels can be different for the two solution methods. For variables where the relevant steady state is the same for both methods (e.g., <code>A</code>), the level appears on the left axis and percentage deviations on the right axis. For variables where the steady state differs between methods (e.g., <code>C</code>), only absolute level deviations (<code>abs. Œî</code>) appear on the left axis. The relevant steady state levels are shown in a table below the plot for reference (rounded to help identify differences).</p><p>Additional solution methods can be added to the same plot:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :pruned_third_order)</code></pre><p><img src="../assets/multiple_orders_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (multiple orders)"/></p><p>Note that the pruned third-order solution incorporates time-varying risk and reverses the sign of the response for <code>MC</code> and <code>N</code>. The additional solution appears as another colored line with corresponding entries in both the legend and the steady state table below.</p><h2 id="Initial-State"><a class="docs-heading-anchor" href="#Initial-State">Initial State</a><a id="Initial-State-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-State" title="Permalink"></a></h2><p>The <code>initial_state</code> argument (default: <code>[0.0]</code>, type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>) defines the starting point for the model. For pruned solution algorithms, the initial state can be provided as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case, the initial state must be specified in deviations from the non-stochastic steady state. For all other cases, specify the initial state in levels. For pruned solution algorithms with a <code>Vector{Float64}</code> initial state, only the first-order initial state vector is affected. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1)</code> returns a <code>KeyedArray</code> with all variables. The <code>KeyedArray</code> type is provided by the AxisKeys package.</p><p>The initial state defines the starting point for the IRF and must contain all model variables, including any leads or lags. To obtain the correct ordering and number of variables, call <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1)</code>, which returns a <code>KeyedArray</code> with all variables in the correct order. The <code>KeyedArray</code> type is provided by the AxisKeys package. For example:</p><pre><code class="language-julia hljs">init_state = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true)</code></pre><p>Only state variables will have an impact on the IRF. To check which variables are state variables:</p><pre><code class="language-julia hljs">get_state_variables(Gali_2015_chapter_3_nonlinear)
# 4-element Vector{String}:
#  &quot;A&quot;
#  &quot;S&quot;
#  &quot;Z&quot;
#  &quot;nu&quot;</code></pre><p>Now modify the initial state and set <code>nu</code> to 0.1:</p><pre><code class="language-julia hljs">init_state(:nu,:,:) .= 0.1</code></pre><p>The modified initial state can now be input into the <code>plot_irf</code> function as a <code>Vector</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state))</code></pre><p><img src="../assets/custom_init_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock with custom initial state"/></p><p>Note that the example also defines the shock <code>eps_a</code> to show how the model reacts to a shock to <code>A</code>. For more details on the <code>shocks</code> argument see the corresponding section. This shows the difference in the IRF compared to starting from the non-stochastic steady state. Setting <code>nu</code> to a higher level effectively combines the effects of shocks to both <code>nu</code> and <code>A</code>. Since this uses a linear solution, these effects can be separated by stacking the components. Start with the IRF from the initial state as defined above:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    initial_state = vec(init_state))</code></pre><p><img src="../assets/no_shock_init_irf__Gali_2015_chapter_3_nonlinear__no_shock__1.png" alt="Gali 2015 IRF - no shock with initial state"/></p><p>then stack the IRF from a shock to A on top of it:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    plot_type = :stack)</code></pre><p><img src="../assets/stacked_init_irf__Gali_2015_chapter_3_nonlinear__multiple_shocks__1.png" alt="Gali 2015 IRF - stacked initial state and eps_a shock"/></p><p>The two components are shown with labels explained in the table below. The blue bars represent the first input (no shock, non-zero initial state), while the red bars correspond to the second input (starting from the steady state with an <code>eps_a</code> shock). Both components add up to the solid line that is the same as in the case of combining the <code>eps_a</code> shock with the initial state.</p><p>The same approach works for higher order solutions. Start with the second order solution. First, obtain the initial state in levels from the second order solution:</p><pre><code class="language-julia hljs">init_state_2nd = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true,
    algorithm = :second_order)</code></pre><p>Then set <code>nu</code> to 0.1:</p><pre><code class="language-julia hljs">init_state_2nd(:nu, :, :) .= 0.1</code></pre><p>and plot the IRF for <code>eps_a</code> starting from this initial state:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state_2nd),
    algorithm = :second_order)</code></pre><p>While these components can be stacked, they won&#39;t add up linearly due to the non-linear solution. Instead, the IRF behavior can be compared across the two solution methods:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state))

plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state_2nd),
    algorithm = :second_order)</code></pre><p><img src="../assets/multi_sol_init_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock with initial state (multiple solutions)"/></p><p>The legend shows two lines, with their input differences detailed in the table below. The first line corresponds to the initial state used for the first order solution as well as the IRF using the first order solution and the second line corresponds to the initial state used for the second order solution and using the second order solution. Note that the steady states differ between the two solution methods, which also affects the initial states (except for <code>nu</code>, which is set to 0.1 in both cases). A second table below the first one shows the relevant steady states for both solution methods. Since the relevant steady state of <code>A</code> is the same for both methods, the corresponding subplot shows the level on the left axis and percentage deviations on the right axis. For all other variables, the relevant steady state differs between methods, so only absolute level deviations appear (<code>abs. Œî</code>) on the left axis, with steady states listed in the table at the bottom.</p><p>For pruned solution methods the initial state can also be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). When providing a vector of vectors, values must be specified as differences from the non-stochastic steady state. When providing only one vector, values must be in levels, with the initial state having its full nonlinear effect in the first period. Using a vector of vectors allows setting the pruned higher-order auxiliary state vectors. While this can be useful in some cases, note that these higher-order auxiliary state vectors have only a linear impact in the first period. Start by assembling the vector of vectors:</p><pre><code class="language-julia hljs">init_state_pruned_3rd_in_diff = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true) - get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    algorithm = :pruned_third_order,
    levels = true)
# 3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
# ‚Üì   Variables ‚àà 23-element Vector{Symbol}
# ‚Üí   Periods ‚àà 1-element UnitRange{Int64}
# ‚ó™   Shocks ‚àà 1-element Vector{Symbol}
# And data, 23√ó1√ó1 Array{Float64, 3}:
# [:, :, 1] ~ (:, :, :none):
#                    (1)
#   (:A)               0.0
#   (:C)               0.01899564383140051
#   (:MC)              0.26061783703451824
#   (:M_real)          0.014844948179111417
#   (:N)               0.0256329467464953
#   (:Pi)             -0.0013592503942323475
#   (:Pi_star)        -0.0040777511826968205
#   (:Q)              -0.00023912532361458627
#   (:R)               0.0002649588073291298
#   (:S)               3.3306690738754696e-16
#   (:W_real)          0.18508712654020898
#   (:Y)               0.01899564383140051
#   (:Z)               0.0
#   (:i_ann)           0.0010068434678508487
#   (:log_N)           0.024432922221986165
#   (:log_W_real)      0.1404893027764202
#   (:log_y)           0.018324691666489368
#   (:nu)             -1.3404049553225972e-17
#   (:pi_ann)         -0.005437001576929203
#   (:r_real_ann)      0.008306969164175088
#   (:realinterest)    0.002186044516888197
#   (:x_aux_1)        -0.7618262640813329
#   (:x_aux_2)        -0.371793344047362</code></pre><p>First- and third-order dynamics don&#39;t affect the steady state through risk, so they are zero. The second-order steady state includes the risk adjustment. Assemble the vectors for the third order case:</p><pre><code class="language-julia hljs">init_states_pruned_3rd_vec = [
    zero(vec(init_state_pruned_3rd_in_diff)),
    vec(init_state_pruned_3rd_in_diff),
    zero(vec(init_state_pruned_3rd_in_diff)),
]</code></pre><p>Then set <code>nu</code> to 0.1 in the first order terms. Inspecting <code>init_state_pruned_3rd_in_diff</code> shows that <code>nu</code> is the 18th variable in the vector:</p><pre><code class="language-julia hljs">init_states_pruned_3rd_vec[1][18] = 0.1

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = init_states_pruned_3rd_vec,
    algorithm = :pruned_third_order)</code></pre><p><img src="../assets/pruned_3rd_vec_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock with pruned 3rd order vector"/></p><p>Alternatively, a simple vector can be used for the initial state. In this case the values must be in levels and the impact of the initial state is assumed to have the full nonlinear effect in the first period:</p><pre><code class="language-julia hljs">init_state_pruned_3rd = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true,
    algorithm = :pruned_third_order)

init_state_pruned_3rd(:nu, :,  :) .= 0.1

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state_pruned_3rd),
    algorithm = :pruned_third_order)</code></pre><p>Compare this with the second- and first-order versions, each starting from their respective steady states.</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state_2nd),
    algorithm = :second_order)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    initial_state = vec(init_state))</code></pre><p><img src="../assets/all_sol_init_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock with initial state (all solution methods)"/></p><p>This shows that the pruned third-order solution changes the dynamics while maintaining the same steady states as the second-order solution.</p><h2 id="Shocks"><a class="docs-heading-anchor" href="#Shocks">Shocks</a><a id="Shocks-1"></a><a class="docs-heading-anchor-permalink" href="#Shocks" title="Permalink"></a></h2><p>The <code>shocks</code> argument (default: <code>:all_excluding_obc</code>) determines which IRFs to calculate. Shock names can be specified as either a <code>Symbol</code> or <code>String</code> (e.g., <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding those related to occasionally binding constraints). <code>:all_excluding_obc</code> includes all shocks except OBC-related ones. <code>:all</code> also includes the OBC related shocks. A series of shocks can be passed using either a <code>Matrix{Float64}</code> or a <code>KeyedArray{Float64}</code>, with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the AxisKeys package. The simulation length equals the input length in the period dimension plus the number of periods specified in the <code>periods</code> argument. When using a <code>KeyedArray{Float64}</code>, ensure that rows are named with valid shock names of type <code>Symbol</code> or <code>String</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</p><p>Individual shocks can be called by name:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a)</code></pre><p><img src="../assets/single_shock_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock"/></p><p>The same works if the shock name is input as a <code>String</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = &quot;eps_a&quot;)</code></pre><p>or multiple shocks at once (as <code>String</code> or <code>Symbol</code>):</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = [:eps_a, :eps_z])</code></pre><p><img src="../assets/multi_shocks_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock"/></p><p><img src="../assets/multi_shocks_irf__Gali_2015_chapter_3_nonlinear__eps_z__1.png" alt="Gali 2015 IRF - eps_z shock"/></p><p>Multiple shocks can also be input as a <code>Tuple</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = (:eps_a, :eps_z))</code></pre><p>or a <code>Matrix</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = [:eps_a :eps_z])</code></pre><p>Then there are some predefined options:</p><p><code>:all_excluding_obc</code> (default) plots all shocks not used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :all_excluding_obc)</code></pre><p><img src="../assets/all_ex_obc_irf__Gali_2015_chapter_3_nonlinear__eps_nu__1.png" alt="Gali 2015 IRF - eps_nu shock"/></p><p><code>:all</code> plots all shocks including the OBC related ones.</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :all)</code></pre><p><code>:simulate</code> triggers random draws of all shocks (excluding OBC-related shocks). The seed can be set to get reproducible results (e.g. <code>import Random; Random.seed!(10)</code>).</p><p>Alternatively, the <code>plot_simulation</code> function can be used as a convenient wrapper. This is equivalent to calling <code>plot_irf</code> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :simulate)

# Equivalent to:
plot_simulation(Gali_2015_chapter_3_nonlinear)</code></pre><p><img src="../assets/simulated_irf__Gali_2015_chapter_3_nonlinear__simulation__1.png" alt="Gali 2015 IRF - simulated shocks"/></p><p><code>:none</code> can be used in combination with an <code>initial_state</code> for deterministic simulations. See the section on <code>initial_state</code> for more details. Start by getting the initial state in levels:</p><pre><code class="language-julia hljs">init_state = get_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    variables = :all,
    periods = 1,
    levels = true)</code></pre><p>Only state variables will have an impact on the IRF. To check which variables are state variables:</p><pre><code class="language-julia hljs">get_state_variables(Gali_2015_chapter_3_nonlinear)
# 4-element Vector{String}:
#  &quot;A&quot;
#  &quot;S&quot;
#  &quot;Z&quot;
#  &quot;nu&quot;</code></pre><p>Now modify the initial state and set <code>nu</code> to 0.1:</p><pre><code class="language-julia hljs">init_state(:nu, :, :) .= 0.1</code></pre><p>Now input the modified initial state into the <code>plot_irf</code> function as a <code>Vector</code> and set <code>shocks</code> to <code>:none</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :none,
    initial_state = vec(init_state))</code></pre><p><img src="../assets/deterministic_irf__Gali_2015_chapter_3_nonlinear__no_shock__1.png" alt="Gali 2015 IRF - deterministic simulation from initial state"/></p><p>Note how this is similar to a shock to <code>eps_nu</code> but instead <code>nu</code> is set to 0.1 in the initial state and the model evolves deterministically from there. In the title the reference to the shock disappeared as it was set to <code>:none</code>.</p><p>Shocks can also be compared:</p><pre><code class="language-julia hljs">shocks = get_shocks(Gali_2015_chapter_3_nonlinear)

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = shocks[1])

for s in shocks[2:end]
    plot_irf!(Gali_2015_chapter_3_nonlinear,
        shocks = s)
end</code></pre><p><img src="../assets/compare_shocks_irf__Gali_2015_chapter_3_nonlinear__multiple_shocks__1.png" alt="Gali 2015 IRF - all shocks compared"/></p><p>All three shocks now appear overlaid in the same plot. The legend below the plot indicates which color corresponds to which shock and in the title the plot shows that all shocks are positive and includes multiple shocks.</p><p>A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. Start with a <code>KeyedArray</code>:</p><pre><code class="language-julia hljs">shocks = get_shocks(Gali_2015_chapter_3_nonlinear)

n_periods = 3

shock_keyedarray = KeyedArray(
    zeros(length(shocks), n_periods),
    Shocks = shocks,
    Periods = 1:n_periods,
)</code></pre><p>and then set a one standard deviation shock to <code>eps_a</code> in period 1, a negative 1/2 standard deviation shock to <code>eps_z</code> in period 2 and a 1/3 standard deviation shock to <code>eps_nu</code> in period 3:</p><pre><code class="language-julia hljs">shock_keyedarray(&quot;eps_a&quot;, [1]) .= 1
shock_keyedarray(&quot;eps_z&quot;, [2]) .= -1/2
shock_keyedarray(&quot;eps_nu&quot;, [3]) .= 1/3

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = shock_keyedarray)</code></pre><p><img src="../assets/shock_series_irf__Gali_2015_chapter_3_nonlinear__shock_matrix__2.png" alt="Gali 2015 IRF - shock series from KeyedArray"/></p><p>In the title it is now mentioned that the input is a series of shocks and the values of the shock processes <code>Z</code> and <code>nu</code> move with the shifted timing and note that the impact of the <code>eps_z</code> shock has a - in front of it in the model definition, which is why they both move in the same direction. Note also that the number of periods is prolonged by the number of periods in the shock input. This example defines 3 periods of shocks and the default number of periods is 40, so the result shows 43 periods in total.</p><p>The same can be done with a <code>Matrix</code>:</p><pre><code class="language-julia hljs">shock_matrix = zeros(length(shocks), n_periods)

shock_matrix[1, 1] = 1
shock_matrix[3, 2] = -1/2
shock_matrix[2, 3] = 1/3

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = shock_matrix)</code></pre><p>In certain circumstances a shock matrix might correspond to a certain scenario and when working with linear solutions, the IRF can be stacked for different scenarios or components of scenarios. Consider two scenarios defined by two different shock matrices:</p><pre><code class="language-julia hljs">shock_matrix_1 = zeros(length(shocks), n_periods)

shock_matrix_1[1, 1] = 1
shock_matrix_1[3, 2] = -1/2
shock_matrix_1[2, 3] = 1/3


shock_matrix_2 = zeros(length(shocks), n_periods * 2)

shock_matrix_2[1, 4] = -1
shock_matrix_2[3, 5] = 1/2
shock_matrix_2[2, 6] = -1/3</code></pre><p>Plot them on top of each other using the :stack option for the <code>plot_type</code> argument:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = shock_matrix_1)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = shock_matrix_2,
    plot_type = :stack)</code></pre><p><img src="../assets/stacked_matrices_irf__Gali_2015_chapter_3_nonlinear__shock_matrix__2.png" alt="Gali 2015 IRF - stacked shock matrices"/></p><p>The blue bars correspond to the first shock matrix and the red to the second shock matrix and they are labeled accordingly in the legend below the plot. The solid line corresponds to the sum of both components. The result shows 46 periods as the second shock matrix has 6 periods and the first one 3 periods and the default number of periods is 40.</p><h2 id="Simulation-Periods"><a class="docs-heading-anchor" href="#Simulation-Periods">Simulation Periods</a><a id="Simulation-Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Periods" title="Permalink"></a></h2><p>The <code>periods</code> argument (default: <code>40</code>, type: <code>Int</code>) specifies the number of periods for which to calculate the output. When a matrix of shocks is provided, this defines how many periods to continue after the shock series. To set the number of periods to 10 (for the <code>eps_a</code> shock):</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    periods = 10,
    shocks = :eps_a)</code></pre><p><img src="../assets/ten_periods_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (10 periods)"/></p><p>The x-axis automatically adjusts to show only 10 periods.</p><p>The following example uses a shock matrix with 15 periods as input, sets the <code>periods</code> argument to 20, and compares it to the previous 10-period plot:</p><pre><code class="language-julia hljs">shock_matrix = zeros(length(shocks), 15)

shock_matrix[1, 1] = .1
shock_matrix[3, 5] = -1/2
shock_matrix[2, 15] = 1/3

plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = shock_matrix,
    periods = 20)</code></pre><p><img src="../assets/mixed_periods_irf__Gali_2015_chapter_3_nonlinear__multiple_shocks__1.png" alt="Gali 2015 IRF - mixed period lengths"/></p><p>The x-axis adjusts to 35 periods, with the first plot ending after 10 periods and the second plot ending after 35 periods. The legend indicates which color corresponds to which shock, and the title shows that multiple shocks are in the plot.</p><h2 id="Shock-Size"><a class="docs-heading-anchor" href="#Shock-Size">Shock Size</a><a id="Shock-Size-1"></a><a class="docs-heading-anchor-permalink" href="#Shock-Size" title="Permalink"></a></h2><p>The <code>shock_size</code> argument (default: <code>1.0</code>, type: <code>Real</code>) controls the size of the shocks in standard deviations. Only affects shocks not provided as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>. Negative values flip the sign of the shock.</p><p>The shock size can be set using the <code>shock_size</code> argument. The following example sets it to -2 standard deviations:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    shock_size = -2)</code></pre><p><img src="../assets/shock_size_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (size -2)"/></p><p>Note how the shock&#39;s sign is flipped and the response magnitude is increased.</p><h2 id="Negative-Shocks"><a class="docs-heading-anchor" href="#Negative-Shocks">Negative Shocks</a><a id="Negative-Shocks-1"></a><a class="docs-heading-anchor-permalink" href="#Negative-Shocks" title="Permalink"></a></h2><p>The <code>negative_shock</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, calculates IRFs for a negative shock. Only affects shocks not provided as a matrix or <code>KeyedArray</code> or set to <code>:none</code>.</p><p>Alternatively, set <code>negative_shock</code> to <code>true</code> to obtain the IRF for a negative one-standard-deviation shock:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    negative_shock = true)</code></pre><p><img src="../assets/negative_shock_irf__Gali_2015_chapter_3_nonlinear__eps_z__1.png" alt="Gali 2015 IRF - eps_z shock (negative)"/></p><h2 id="Variables-to-Plot"><a class="docs-heading-anchor" href="#Variables-to-Plot">Variables to Plot</a><a id="Variables-to-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-to-Plot" title="Permalink"></a></h2><p>The <code>variables</code> argument (default: <code>:all_excluding_obc</code>) specifies for which variables to show results. Variable names can be specified as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> includes all variables except auxiliary variables and those related to occasionally binding constraints (OBC). <code>:all_excluding_obc</code> includes all variables except those related to occasionally binding constraints. <code>:all</code> includes all variables.</p><p>Specific variables can be selected to plot. The following example selects only output (<code>Y</code>) and inflation (<code>Pi</code>) using a <code>Vector</code> of <code>Symbol</code>s:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = [:Y, :Pi])</code></pre><p><img src="../assets/var_select_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - selected variables (Y, Pi)"/></p><p>The plot now displays only the two selected variables (sorted alphabetically), with two subplots for each shock. The same can be done using a <code>Tuple</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = (:Y, :Pi))</code></pre><p>a <code>Matrix</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = [:Y :Pi])</code></pre><p>or providing the variable names as <code>String</code>s:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = [&quot;Y&quot;, &quot;Pi&quot;])</code></pre><p>or a single variable as a <code>Symbol</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = :Y)</code></pre><p>or as a <code>String</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = &quot;Y&quot;)</code></pre><p>Then there are some predefined options:</p><p><code>:all_excluding_auxiliary_and_obc</code> (default) plots all variables except auxiliary variables and those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = :all_excluding_auxiliary_and_obc)</code></pre><p><code>:all_excluding_obc</code> plots all variables except those used to enforce occasionally binding constraints (OBC).</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = :all_excluding_obc)</code></pre><p>To see auxiliary variables, use a model that defines them. The FS2000 model can be used:</p><pre><code class="language-julia hljs">@model FS2000 begin
    dA[0] = exp(gam + z_e_a  *  e_a[x])
    log(m[0]) = (1 - rho) * log(mst)  +  rho * log(m[-1]) + z_e_m  *  e_m[x]
    - P[0] / (c[1] * P[1] * m[0]) + bet * P[1] * (alp * exp( - alp * (gam + log(e[1]))) * k[0] ^ (alp - 1) * n[1] ^ (1 - alp) + (1 - del) * exp( - (gam + log(e[1])))) / (c[2] * P[2] * m[1])=0
    W[0] = l[0] / n[0]
    - (psi / (1 - psi)) * (c[0] * P[0] / (1 - n[0])) + l[0] / n[0] = 0
    R[0] = P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ ( - alp) / W[0]
    1 / (c[0] * P[0]) - bet * P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) / (m[0] * l[0] * c[1] * P[1]) = 0
    c[0] + k[0] = exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) + (1 - del) * exp( - (gam + z_e_a  *  e_a[x])) * k[-1]
    P[0] * c[0] = m[0]
    m[0] - 1 + d[0] = l[0]
    e[0] = exp(z_e_a  *  e_a[x])
    y[0] = k[-1] ^ alp * n[0] ^ (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x]))
    gy_obs[0] = dA[0] * y[0] / y[-1]
    gp_obs[0] = (P[0] / P[-1]) * m[-1] / dA[0]
    log_gy_obs[0] = log(gy_obs[0])
    log_gp_obs[0] = log(gp_obs[0])
end

@parameters FS2000 begin
    alp     = 0.356
    bet     = 0.993
    gam     = 0.0085
    mst     = 1.0002
    rho     = 0.129
    psi     = 0.65
    del     = 0.01
    z_e_a   = 0.035449
    z_e_m   = 0.008862
end</code></pre><p>Since both <code>c</code> and <code>P</code> appear in t+2, they generate auxiliary variables in the model. Plotting the IRF for all variables excluding OBC-related ones means auxiliary variables are shown:</p><pre><code class="language-julia hljs">plot_irf(FS2000, 
    variables = :all_excluding_obc)</code></pre><p><img src="../assets/with_aux_vars_irf__FS2000__e_a__1.png" alt="FS2000 IRF - e_a shock with auxiliary variables"/></p><p>Both <code>c</code> and <code>P</code> appear twice: once as the variable itself and once as an auxiliary variable with the <code>·¥∏‚ÅΩ¬π‚Åæ</code> superscript, representing the value of the variable in t+1 as expected in t.</p><p><code>:all</code> plots all variables including auxiliary variables and those used to enforce occasionally binding constraints (OBC).</p><p>Use the <code>Gali_2015_chapter_3</code> model with an effective lower bound (note the use of the <code>max</code> function in the Taylor rule):</p><pre><code class="language-julia hljs">@model Gali_2015_chapter_3_obc begin
    W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ
    Q[0] = Œ≤ * (C[1] / C[0]) ^ (-œÉ) * Z[1] / Z[0] / Pi[1]
    R[0] = 1 / Q[0]
    Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)
    R[0] = Pi[1] * realinterest[0]
    R[0] = max(RÃÑ , 1 / Œ≤ * Pi[0] ^ œï·µñ‚Å± * (Y[0] / Y[ss]) ^ œï ∏ * exp(nu[0]))
    C[0] = Y[0]
    log(A[0]) = œÅ_a * log(A[-1]) + std_a * eps_a[x]
    log(Z[0]) = œÅ_z * log(Z[-1]) - std_z * eps_z[x]
    nu[0] = œÅ_ŒΩ * nu[-1] + std_nu * eps_nu[x]
    MC[0] = W_real[0] / (S[0] * Y[0] * (1 - Œ±) / N[0])
    1 = Œ∏ * Pi[0] ^ (œµ - 1) + (1 - Œ∏) * Pi_star[0] ^ (1 - œµ)
    S[0] = (1 - Œ∏) * Pi_star[0] ^ (( - œµ) / (1 - Œ±)) + Œ∏ * Pi[0] ^ (œµ / (1 - Œ±)) * S[-1]
    Pi_star[0] ^ (1 + œµ * Œ± / (1 - Œ±)) = œµ * x_aux_1[0] / x_aux_2[0] * (1 - œÑ) / (œµ - 1)
    x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ + Œ± * œµ / (1 - Œ±)) * x_aux_1[1]
    x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ - 1) * x_aux_2[1]
    log_y[0] = log(Y[0])
    log_W_real[0] = log(W_real[0])
    log_N[0] = log(N[0])
    pi_ann[0] = 4 * log(Pi[0])
    i_ann[0] = 4 * log(R[0])
    r_real_ann[0] = 4 * log(realinterest[0])
    M_real[0] = Y[0] / R[0] ^ Œ∑
end

@parameters Gali_2015_chapter_3_obc begin
    RÃÑ = 1.0
    œÉ = 1
    œÜ = 5
    œï·µñ‚Å± = 1.5
    œï ∏ = 0.125
    Œ∏ = 0.75
    œÅ_ŒΩ = 0.5
    œÅ_z = 0.5
    œÅ_a = 0.9
    Œ≤ = 0.99
    Œ∑ = 3.77
    Œ± = 0.25
    œµ = 9
    œÑ = 0
    std_a = .01
    std_z = .05
    std_nu = .0025
    R &gt; 1.0001
end</code></pre><p>Plotting the IRF for all variables including OBC-related ones reveals the OBC-related auxiliary variables:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_obc,
    variables = :all)</code></pre><p><img src="../assets/with_obc_vars_irf__Gali_2015_chapter_3_obc__eps_z__3.png" alt="Gali 2015 OBC IRF - eps_z shock with OBC variables"/></p><p>The OBC-related variables appear in the last subplot. Note that with the <code>eps_z</code> shock, the interest rate <code>R</code> hits the effective lower bound in period 1:</p><p><img src="../assets/with_obc_vars_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock hitting lower bound"/></p><p>The effective lower bound is enforced using shocks to the equation containing the <code>max</code> statement. See the documentation for details on constructing occasionally binding constraints. For this specific model, examine the equations the parser generated to enforce the OBC:</p><pre><code class="language-julia hljs">get_equations(Gali_2015_chapter_3_obc)
# 68-element Vector{String}:
#  &quot;W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ&quot;
#  &quot;Q[0] = ((Œ≤ * (C[1] / C[0]) ^ -œÉ * Z[1]) / Z[0]) / Pi[1]&quot;
#  &quot;R[0] = 1 / Q[0]&quot;
#  &quot;Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)&quot;
#  &quot;R[0] = Pi[1] * realinterest[0]&quot;
#  &quot;œá·µí·µá·∂ú‚Å∫Íúù¬πÍúùÀ°[0] = RÃÑ - R[0]&quot;
#  ‚ãÆ
#  &quot;œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∂‚Åæ[0] = œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Åµ‚Åæ[-1] + active·µí·µá·∂úshocks * œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù‚ÅΩ‚Å¥‚Åæ[x]&quot;
#  &quot;œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∑‚Åæ[0] = œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∂‚Åæ[-1] + active·µí·µá·∂úshocks * œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù‚ÅΩ¬≥‚Åæ[x]&quot;
#  &quot;œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∏‚Åæ[0] = œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∑‚Åæ[-1] + active·µí·µá·∂úshocks * œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù‚ÅΩ¬≤‚Åæ[x]&quot;
#  &quot;œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Åπ‚Åæ[0] = œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Å∏‚Åæ[-1] + active·µí·µá·∂úshocks * œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù‚ÅΩ¬π‚Åæ[x]&quot;
#  &quot;œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª‚Å¥‚Å∞‚Åæ[0] = œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù·¥∏‚ÅΩ‚Åª¬≥‚Åπ‚Åæ[-1] + active·µí·µá·∂úshocks * œµ·µí·µá·∂ú‚Å∫Íúù¬πÍúù‚ÅΩ‚Å∞‚Åæ[x]&quot;</code></pre><h2 id="Parameter-Values"><a class="docs-heading-anchor" href="#Parameter-Values">Parameter Values</a><a id="Parameter-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Values" title="Permalink"></a></h2><p>When no parameters are provided, the solution uses the previously defined parameter values. Parameters can be provided as a <code>Vector</code> of values, or as a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s mapping parameter <code>Symbol</code>s or <code>String</code>s to values. The solution is recalculated when new parameter values differ from the previous ones.</p><p>Start by changing the discount factor <code>Œ≤</code> from 0.99 to 0.95:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = :Œ≤ =&gt; 0.95,
    shocks = :eps_a)</code></pre><p><img src="../assets/beta_095_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (`Œ≤ = 0.95`)"/></p><p>The steady states and dynamics changed as a result of changing the discount factor. To better visualize the differences between <code>Œ≤ = 0.99</code> and <code>Œ≤ = 0.95</code>, the two IRFs can be overlaid (compared). Since parameter changes are permanent, first reset <code>Œ≤ = 0.99</code> before overlaying the IRF with <code>Œ≤ = 0.95</code> on top of it:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = :Œ≤ =&gt; 0.99,
    shocks = :eps_a)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = :Œ≤ =&gt; 0.95,
    shocks = :eps_a)</code></pre><p><img src="../assets/compare_beta_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock comparing Œ≤ values"/></p><p>The legend below the plot indicates which color corresponds to which <code>Œ≤</code> value, with the table underneath showing the relevant steady states. Note that both the steady states and dynamics differ across the two <code>Œ≤</code> values, even when the steady state remains the same (e.g., for <code>Y</code>).</p><p>Multiple parameters can also be changed simultaneously to compare the results to previous plots. This example changes <code>Œ≤</code> to 0.97 and <code>œÑ</code> to 0.5 using a <code>Tuple</code> of <code>Pair</code>s and define the variables with <code>Symbol</code>s:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.97, :œÑ =&gt; 0.5),
    shocks = :eps_a)</code></pre><p><img src="../assets/multi_params_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock with multiple parameter changes"/></p><p>Since the plot function calls now differ in multiple input arguments, the legend indicates which color corresponds to which input combination, with the table showing steady states for all three combinations.</p><p>A <code>Vector</code> of <code>Pair</code>s can also be used:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = [:Œ≤ =&gt; 0.98, :œÑ =&gt; 0.25],
    shocks = :eps_a)</code></pre><p>Alternatively, use a <code>Vector</code> of parameter values in the order they were defined in the model. To obtain them:</p><pre><code class="language-julia hljs">params = get_parameters(Gali_2015_chapter_3_nonlinear, values = true)
# 16-element Vector{Pair{String, Float64}}:
#       &quot;œÉ&quot; =&gt; 1.0
#       &quot;œÜ&quot; =&gt; 5.0
#     &quot;œï·µñ‚Å±&quot; =&gt; 1.5
#      &quot;œï ∏&quot; =&gt; 0.125
#       &quot;Œ∏&quot; =&gt; 0.75
#     &quot;œÅ_ŒΩ&quot; =&gt; 0.5
#     &quot;œÅ_z&quot; =&gt; 0.5
#     &quot;œÅ_a&quot; =&gt; 0.9
#       &quot;Œ≤&quot; =&gt; 0.95
#       &quot;Œ∑&quot; =&gt; 3.77
#       &quot;Œ±&quot; =&gt; 0.25
#       &quot;œµ&quot; =&gt; 9.0
#       &quot;œÑ&quot; =&gt; 0.5
#   &quot;std_a&quot; =&gt; 0.01
#   &quot;std_z&quot; =&gt; 0.05
#  &quot;std_nu&quot; =&gt; 0.0025

param_vals = [p[2] for p in params]
# 16-element Vector{Float64}:
#  1.0
#  5.0
#  1.5
#  0.125
#  0.75
#  0.5
#  0.5
#  0.9
#  0.95
#  3.77
#  0.25
#  9.0
#  0.5
#  0.01
#  0.05
#  0.0025

plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = param_vals,
    shocks = :eps_a)</code></pre><h2 id="Ignoring-Occasionally-Binding-Constraints"><a class="docs-heading-anchor" href="#Ignoring-Occasionally-Binding-Constraints">Ignoring Occasionally Binding Constraints</a><a id="Ignoring-Occasionally-Binding-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Ignoring-Occasionally-Binding-Constraints" title="Permalink"></a></h2><p>The <code>ignore_obc</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, ignores occasionally binding constraints (OBC) even if they are part of the model. This is useful for comparing dynamics with and without OBC. For models with defined OBC, use the <code>ignore_obc</code> argument to ignore them. The following example compares the IRF of the <code>Gali_2015_chapter_3_obc</code> model with and without OBC. First, examine the IRF for a 3-standard-deviation <code>eps_z</code> shock with OBC enforced. See the <code>shock_size</code> and <code>variables</code> sections for more details on these input arguments. Since OBC is enforced by default, call:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_obc,
    shocks = :eps_z,
    variables = [:Y, :R, :Pi, :C],
    shock_size = 3)</code></pre><p><img src="../assets/obc_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock with OBC"/></p><p>Then overlay the IRF ignoring the OBC:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_obc,
    shocks = :eps_z,
    variables = [:Y, :R, :Pi, :C],
    shock_size = 3,
    ignore_obc = true)</code></pre><p><img src="../assets/compare_obc_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock comparing with and without OBC"/></p><p>The legend indicates which color corresponds to which <code>ignore_obc</code> value. Note how the interest rate <code>R</code> hits the effective lower bound in periods 1-3 when OBC is enforced (blue line) but not when OBC is ignored (red line). The dynamics of other variables also change when OBC is enforced. Enforcing the OBC results in a deeper and longer recession. The length of the lower bound period depends on the size of the shock.</p><h2 id="Generalized-Impulse-Response-Functions"><a class="docs-heading-anchor" href="#Generalized-Impulse-Response-Functions">Generalized Impulse Response Functions</a><a id="Generalized-Impulse-Response-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Impulse-Response-Functions" title="Permalink"></a></h2><p>The <code>generalised_irf</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, calculates generalized IRFs (GIRFs) instead of standard IRFs. GIRFs are computed by simulating the model with and without the shock, taking the difference, and averaging over multiple draws. GIRFs are particularly insightful for models solved to higher-order or models with occasionally binding constraints (OBC), because these non-linearities make them state-dependent. GIRFs then average out the state dependence and give an average IRF over the ergodic set of the model.</p><p>Alternatively, the <code>plot_girf</code> function can be used as a convenient wrapper. This is equivalent to calling <code>plot_irf</code> with <code>generalised_irf = true</code>.</p><p>The following example compares the IRF of the <code>Gali_2015_chapter_3_obc</code> model for a 3-standard-deviation <code>eps_z</code> shock with and without using <code>generalised_irf</code>. First, examine the GIRF:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_obc,
    generalised_irf = true,
    shocks = :eps_z,
    variables = [:Y, :R, :Pi, :C],
    shock_size = 3)</code></pre><p><img src="../assets/obc_girf_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock GIRF"/></p><p>then overlay the standard IRF:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_obc,
    shocks = :eps_z,
    variables = [:Y, :R, :Pi, :C],
    shock_size = 3)</code></pre><p><img src="../assets/obc_girf_compare_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock comparing GIRF vs standard"/></p><p>The legend indicates which color corresponds to which <code>generalised_irf</code> value. Note how the interest rate <code>R</code> hits the effective lower bound in periods 1-3 when using the standard IRF (red line). This suggests that the GIRF&#39;s accepted draws include many cases where the OBC is not binding. This can be confirmed by also overlaying the IRF ignoring the OBC.</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_obc,
    shocks = :eps_z,
    variables = [:Y, :R, :Pi, :C],
    shock_size = 3,
    ignore_obc = true)</code></pre><p><img src="../assets/obc_all_compare_irf__Gali_2015_chapter_3_obc__eps_z__1.png" alt="Gali 2015 OBC IRF - eps_z shock GIRF vs standard vs no OBC"/></p><p>The IRF ignoring the OBC shows <code>R</code> falling more, confirming that the GIRF draws include cases where the OBC is binding. Enforcing the OBC results in a deeper and longer recession. The length of the lower bound period depends on the size of the shock.</p><p>Another use case for GIRFs is examining the IRF of a model with a higher-order solution. The following example examines the IRF of the <code>Gali_2015_chapter_3_nonlinear</code> model solved with pruned second-order perturbation for a 1-standard-deviation <code>eps_a</code> shock with and without using <code>generalised_irf</code>. First, examine the GIRF:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    generalised_irf = true,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p><img src="../assets/girf_2nd_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock GIRF (pruned 2nd order)"/></p><p>Some lines are quite jittery, highlighting the state-dependent nature of the GIRF and the dominant effect of the randomness of the draws (e.g., <code>N</code> or <code>MC</code>).</p><p>Now overlay the standard IRF for the pruned second order solution:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p><img src="../assets/girf_compare_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock GIRF vs standard (pruned 2nd order)"/></p><p>The comparison reveals that the response of <code>S</code> is highly state-dependent and can go either way depending on the economy&#39;s state when the shock occurs. The same applies to <code>W_real</code>, while other variables are less state-dependent, making the GIRF and standard IRF more similar.</p><h2 id="Generalized-Impulse-Response-Function-Options"><a class="docs-heading-anchor" href="#Generalized-Impulse-Response-Function-Options">Generalized Impulse Response Function Options</a><a id="Generalized-Impulse-Response-Function-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Impulse-Response-Function-Options" title="Permalink"></a></h2><p>The <code>generalised_irf_draws</code> (default: <code>50</code>, type: <code>Int</code>) and <code>generalised_irf_warmup_iterations</code> (default: <code>100</code>, type: <code>Int</code>) arguments control the number of draws and warmup iterations. Increasing the number of draws improves GIRF accuracy but increases computation time. Warmup iterations ensure that the starting points of individual draws adequately explore the state space and represent the model&#39;s ergodic distribution.</p><p>Start with the GIRF that had the wiggly lines above:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    generalised_irf = true,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p>then overlay the GIRF with 1000 draws:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    generalised_irf = true,
    generalised_irf_draws = 1000,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p>The lines are now less jittery due to the increased number of draws:</p><p><img src="../assets/girf_1000_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock GIRF with 1000 draws"/></p><p>then overlay the GIRF with 5000 draws:</p><pre><code class="language-julia hljs">plot_irf!(Gali_2015_chapter_3_nonlinear,
    generalised_irf = true,
    generalised_irf_draws = 5000,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p>The lines are even smoother with the further increase in draws:</p><p><img src="../assets/girf_5000_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock GIRF with 5000 draws"/></p><p>To fully cover the model&#39;s ergodic distribution, consider increasing the number of warmup iterations as well. The following example overlays the standard IRF for the pruned second-order solution with the GIRF using 5000 draws and 500 warmup iterations:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :pruned_second_order)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    generalised_irf = true,
    generalised_irf_draws = 5000,
    generalised_irf_warmup_iterations = 500,
    shocks = :eps_a,
    algorithm = :pruned_second_order)</code></pre><p><img src="../assets/girf_5000_500_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock GIRF with 5000 draws and 500 warmup"/></p><p>With this configuration, the difference between the GIRF and standard IRF is minimal. This suggests the average IRF (using sufficient amount of draws as well as warmup draws) is similar to the standard IRF but there is substantial state dependence in the model with a second-order pruned solution for a one-standard-deviation <code>eps_a</code> shock.</p><h2 id="Plot-Labels"><a class="docs-heading-anchor" href="#Plot-Labels">Plot Labels</a><a id="Plot-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Labels" title="Permalink"></a></h2><p>The <code>label</code> argument (type: <code>Union{String,Symbol,Real}</code>) controls labels that appear in plots when using the <code>plot_irf!</code> function to overlay multiple IRFs. By default, labels take on the values of the one dimensional input that differs and are sequential numbers in case the input differs along more than one dimension. Furthermore, custom labels can be provided using this argument. Acceptable inputs are a <code>String</code>, <code>Symbol</code>, or a <code>Real</code>.</p><p>Custom labels are particularly useful when inputs differ in complex ways (e.g., shock matrices or multiple input changes). For example, let&#39;s compare the IRF of the <code>Gali_2015_chapter_3_nonlinear</code> model for a 1 standard deviation <code>eps_a</code> shock with <code>Œ≤ = 0.99</code> and <code>œÑ = 0</code> to the IRF with <code>Œ≤ = 0.95</code> and <code>œÑ = 0.5</code> using custom labels <code>String</code> input:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    shocks = :eps_a,
    label = &quot;Std. params&quot;)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    shocks = :eps_a,
    label = &quot;Alt. params&quot;)</code></pre><p><img src="../assets/custom_labels_irf__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - eps_a shock with custom labels"/></p><p>The legend now displays the custom label names instead of sequential numbers (1 and 2). Additionally, the tables showing input differences and steady states use the custom labels in the first column instead of sequential numbers.</p><p>The same result can be achieved using <code>Symbol</code>s (though they are less expressive):</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    shocks = :eps_a,
    label = :standard)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    shocks = :eps_a,
    label = :alternative)</code></pre><p>or with <code>Real</code> inputs:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.99, :œÑ =&gt; 0.0),
    shocks = :eps_a,
    label = 0.99)

plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.95, :œÑ =&gt; 0.5),
    shocks = :eps_a,
    label = 0.95)</code></pre><h2 id="Plot-Type"><a class="docs-heading-anchor" href="#Plot-Type">Plot Type</a><a id="Plot-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Type" title="Permalink"></a></h2><p>The <code>plot_type</code> argument (default: <code>:compare</code>, type: <code>Symbol</code>) determines how IRFs are visualized when multiple scenarios are displayed. Two options are available:</p><ul><li><code>:compare</code> - Displays IRFs as separate lines for comparison across scenarios</li><li><code>:stack</code> - Stacks IRFs on top of each other to show cumulative effects</li></ul><p>The <code>:stack</code> option is particularly useful when analyzing scenarios composed of multiple shock series, as it shows how different shocks contribute to the overall response. The <code>:compare</code> option is better suited for comparing IRFs across different parameter values or model specifications.</p><h3 id="Using-:stack-to-layer-scenarios"><a class="docs-heading-anchor" href="#Using-:stack-to-layer-scenarios">Using <code>:stack</code> to layer scenarios</a><a id="Using-:stack-to-layer-scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Using-:stack-to-layer-scenarios" title="Permalink"></a></h3><p>When analyzing a scenario composed of multiple shocks, <code>:stack</code> visualizes the cumulative impact. For example, plot the combined effect of <code>eps_a</code> and <code>nu</code> shocks:</p><pre><code class="language-julia hljs"># First shock in the scenario
plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a)

# Add second shock to show cumulative effect
plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_nu,
    plot_type = :stack)</code></pre><p><img src="../assets/stack__Gali_2015_chapter_3_nonlinear__multiple_shocks__2.png" alt="Gali 2015 IRF - stacked shocks (eps_a and eps_nu)"/></p><p>The <code>:stack</code> visualization shows how each shock contributes to the total response, with the second shock&#39;s effect layered on top of the first, and the solid black line representing the total effect.</p><h3 id="Using-:compare-for-scenario-comparisons"><a class="docs-heading-anchor" href="#Using-:compare-for-scenario-comparisons">Using <code>:compare</code> for scenario comparisons</a><a id="Using-:compare-for-scenario-comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Using-:compare-for-scenario-comparisons" title="Permalink"></a></h3><p>When comparing IRFs across different scenarios, <code>:compare</code> displays the responses as separate lines:</p><pre><code class="language-julia hljs"># Baseline parameterization
plot_irf(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.99,),
    shocks = :eps_a)

# Alternative parameterization for comparison
plot_irf!(Gali_2015_chapter_3_nonlinear,
    parameters = (:Œ≤ =&gt; 0.95,),
    shocks = :eps_a,
    plot_type = :compare)</code></pre><p><img src="../assets/compare__Gali_2015_chapter_3_nonlinear__eps_a__2.png" alt="Gali 2015 IRF - comparing Œ≤ values"/></p><p>The <code>:compare</code> option (the default) makes it easy to see how parameter changes affect the IRF magnitude and persistence.</p><h2 id="Plot-Attributes"><a class="docs-heading-anchor" href="#Plot-Attributes">Plot Attributes</a><a id="Plot-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Attributes" title="Permalink"></a></h2><p>The <code>plot_attributes</code> argument (default: <code>Dict()</code>, type: <code>Dict</code>) accepts a dictionary of attributes passed on to the plotting function. See the Plots.jl documentation for details.</p><p>The color palette can be customized using the <code>plot_attributes</code> argument. The following example defines a custom color palette (inspired by the European Commission&#39;s economic reports) to plot and stack all IRFs for the <code>Gali_2015_chapter_3_nonlinear</code> model. First, define the custom color palette using hex color codes:</p><pre><code class="language-julia hljs">ec_color_palette =
[
    &quot;#FFD724&quot;,  # &quot;Sunflower Yellow&quot;
    &quot;#353B73&quot;,  # &quot;Navy Blue&quot;
    &quot;#2F9AFB&quot;,  # &quot;Sky Blue&quot;
    &quot;#B8AAA2&quot;,  # &quot;Taupe Grey&quot;
    &quot;#E75118&quot;,  # &quot;Vermilion&quot;
    &quot;#6DC7A9&quot;,  # &quot;Mint Green&quot;
    &quot;#F09874&quot;,  # &quot;Coral&quot;
    &quot;#907800&quot;   # &quot;Olive&quot;
]</code></pre><p>Next, retrieve all shocks defined in the model:</p><pre><code class="language-julia hljs">shocks = get_shocks(Gali_2015_chapter_3_nonlinear)
# 3-element Vector{String}:
#  &quot;eps_a&quot;
#  &quot;eps_nu&quot;
#  &quot;eps_z&quot;</code></pre><p>Then plot the IRF for the first shock:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = shocks[1])</code></pre><p>Finally, overlay the IRFs for the remaining shocks using the custom color palette:</p><pre><code class="language-julia hljs">for s in shocks[2:end]
    plot_irf!(Gali_2015_chapter_3_nonlinear,
        shocks = s,
        plot_attributes = Dict(:palette =&gt; ec_color_palette),
        plot_type = :stack)
end</code></pre><p><img src="../assets/custom_colors_irf__Gali_2015_chapter_3_nonlinear__multiple_shocks__2.png" alt="Gali 2015 IRF - all shocks with custom color palette"/></p><p>The colors of the shocks now follow the custom color palette.</p><p>Other attributes such as the font family can also be modified (see here for <a href="https://github.com/JuliaPlots/Plots.jl/blob/v1.41.1/src/backends/gr.jl#L61">GR font options</a>):</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    plot_attributes = Dict(:fontfamily =&gt; &quot;computer modern&quot;))</code></pre><p><img src="../assets/custom_font_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock with custom font"/></p><p>All text in the plot now uses the Computer Modern font. Note that font rendering inherits the constraints of the plotting backend (GR in this case)‚Äîfor example, the superscript <code>‚Å∫</code> is not rendered properly for this font.</p><h2 id="Plots-Per-Page"><a class="docs-heading-anchor" href="#Plots-Per-Page">Plots Per Page</a><a id="Plots-Per-Page-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-Per-Page" title="Permalink"></a></h2><p>The <code>plots_per_page</code> argument (default: <code>9</code>, type: <code>Int</code>) controls the number of subplots per page. When the number of variables exceeds this value, multiple pages are created. The following example selects 9 variables and sets <code>plots_per_page</code> to 2:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    variables = [:Y, :Pi, :R, :C, :N, :W_real, :MC, :i_ann, :A],
    shocks = :eps_a,
    plots_per_page = 2)</code></pre><p><img src="../assets/two_per_page_irf__Gali_2015_chapter_3_nonlinear__eps_a__1.png" alt="Gali 2015 IRF - eps_a shock (2 plots per page)"/></p><p>The first page displays the first two variables (sorted alphabetically) with two subplots for each shock. The title indicates the current page and the total number of pages.</p><h2 id="Display-Plots"><a class="docs-heading-anchor" href="#Display-Plots">Display Plots</a><a id="Display-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Display-Plots" title="Permalink"></a></h2><p>The <code>show_plots</code> argument (default: <code>true</code>, type: <code>Bool</code>), when <code>true</code>, displays the plots; otherwise, they are only returned as an object.</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    show_plots = false)</code></pre><h2 id="Saving-Plots"><a class="docs-heading-anchor" href="#Saving-Plots">Saving Plots</a><a id="Saving-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Plots" title="Permalink"></a></h2><p>The <code>save_plots</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, saves the plots to disk; otherwise, they are only displayed and returned as an object.</p><p>Related arguments control the saving behavior:</p><ul><li><code>save_plots_format</code> (default: <code>:pdf</code>, type: <code>Symbol</code>): output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> (default: <code>&quot;.&quot;</code>, type: <code>String</code>): path where plots are saved. If the path does not exist, it will be created automatically.</li><li><code>save_plots_name</code> (default: <code>&quot;irf&quot;</code>, type: <code>Union{String, Symbol}</code>): prefix prepended to the filename when saving plots.</li></ul><p>Each plot is saved as a separate file with a name indicating the prefix, model name, shocks, and a sequential number for multiple plots (e.g., <code>irf__ModelName__shock__1.pdf</code>).</p><p>The following example saves all IRFs for the <code>Gali_2015_chapter_3_nonlinear</code> model as PNG files in the <code>../plots</code> directory with <code>impulse_response</code> as the filename prefix:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    save_plots = true,
    save_plots_format = :png,
    save_plots_path = &quot;./../plots&quot;,
    save_plots_name = :impulse_response)</code></pre><p>The plots appear in the specified folder with the specified prefix. Each plot is saved in a separate file with a name reflecting the model, the shock, and a sequential index when the number of variables exceeds the plots per page.</p><h2 id="Variable-and-Shock-Renaming-(rename-dictionary)"><a class="docs-heading-anchor" href="#Variable-and-Shock-Renaming-(rename-dictionary)">Variable and Shock Renaming (rename dictionary)</a><a id="Variable-and-Shock-Renaming-(rename-dictionary)-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-and-Shock-Renaming-(rename-dictionary)" title="Permalink"></a></h2><p>The <code>rename_dictionary</code> argument (default: <code>Dict()</code>, type: <code>AbstractDict{&lt;:Union{Symbol, String}, &lt;:Union{Symbol, String}}</code>) maps variable or shock symbols to custom display names in plots. This is particularly useful when comparing models with different variable naming conventions, allowing them to be displayed with consistent labels.</p><p>For example, to rename variables for clearer display:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    rename_dictionary = Dict(:Y =&gt; &quot;Output&quot;, :Pi =&gt; &quot;Inflation&quot;, :R =&gt; &quot;Interest Rate&quot;))</code></pre><p><img src="../assets/rename_dict_irf__Gali_2015_chapter_3_nonlinear__eps_z__1.png" alt="Gali 2015 IRF - eps_z shock rename dictionary"/></p><p>This feature is especially valuable when overlaying IRFs from different models. Consider comparing FS2000 (which uses lowercase variable names like <code>c</code>) with <code>Gali_2015_chapter_3_nonlinear</code> (which uses uppercase like <code>C</code>). The <code>rename_dictionary</code> allows harmonizing these names when plotting them together:</p><pre><code class="language-julia hljs"># First model (FS2000) with lowercase variable names
plot_irf(FS2000,
    shocks = :e_a,
    rename_dictionary = Dict(:c =&gt; &quot;Consumption&quot;, :y =&gt; &quot;Output&quot;, :R =&gt; &quot;Interest Rate&quot;))

# Overlay second model (Gali_2015_chapter_3_nonlinear) with different naming, mapped to same display names
plot_irf!(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    rename_dictionary = Dict(:C =&gt; &quot;Consumption&quot;, :Y =&gt; &quot;Output&quot;, :R =&gt; &quot;Interest Rate&quot;))</code></pre><p><img src="../assets/rename_dict_irf__multiple_models__multiple_shocks__1.png" alt="FS2000 and Gali 2015 IRF - multiple models with rename dictionary"/></p><p>Both models now appear in the plot with consistent, readable labels, making comparison straightforward.</p><p>The <code>rename_dictionary</code> also works with shocks. For example, <code>Gali_2015_chapter_3_nonlinear</code> has shocks <code>eps_a</code> and <code>eps_nu</code>, while FS2000 has <code>e_a</code> and <code>e_m</code>. To compare these with consistent labels:</p><pre><code class="language-julia hljs"># Gali model with shocks eps_a and eps_nu
plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = [:eps_a, :eps_nu],
    rename_dictionary = Dict(:eps_a =&gt; &quot;Technology Shock&quot;, :eps_nu =&gt; &quot;Monetary Policy Shock&quot;))

# FS2000 model with shocks e_a and e_m  
plot_irf!(FS2000,
    shocks = [:e_a, :e_m],
    rename_dictionary = Dict(:e_a =&gt; &quot;Technology Shock&quot;, :e_m =&gt; &quot;Monetary Policy Shock&quot;))</code></pre><p><img src="../assets/rename_dict_shock_irf__multiple_models__Technology Shock__2.png" alt="FS2000 and Gali 2015 IRF - multiple models with shock rename dictionary"/></p><p>The <code>rename_dictionary</code> accepts flexible type combinations for keys and values‚Äîboth <code>Symbol</code> and <code>String</code> types work interchangeably:</p><pre><code class="language-julia hljs"># All of these are valid and equivalent:
Dict(:Y =&gt; &quot;Output&quot;)              # Symbol key, String value
Dict(&quot;Y&quot; =&gt; &quot;Output&quot;)             # String key, String value
Dict(:Y =&gt; :Output)               # Symbol key, Symbol value
Dict(&quot;Y&quot; =&gt; :Output)              # String key, Symbol value</code></pre><p>This flexibility is particularly useful for models like <code>Backus_Kehoe_Kydland_1992</code>, which uses <code>String</code> representations of variable and shock names (because of <code>{}</code>):</p><pre><code class="language-julia hljs"># Define the Backus model (abbreviated for clarity)
@model Backus_Kehoe_Kydland_1992 begin
    for co in [H, F]
        Y{co}[0] = ((LAMBDA{co}[0] * K{co}[-4]^theta{co} * N{co}[0]^(1-theta{co}))^(-nu{co}) + sigma{co} * Z{co}[-1]^(-nu{co}))^(-1/nu{co})
        K{co}[0] = (1-delta{co})*K{co}[-1] + S{co}[0]
        X{co}[0] = for lag in (-4+1):0 phi{co} * S{co}[lag] end
        A{co}[0] = (1-eta{co}) * A{co}[-1] + N{co}[0]
        L{co}[0] = 1 - alpha{co} * N{co}[0] - (1-alpha{co})*eta{co} * A{co}[-1]
        U{co}[0] = (C{co}[0]^mu{co}*L{co}[0]^(1-mu{co}))^gamma{co}
        psi{co} * mu{co} / C{co}[0]*U{co}[0] = LGM[0]
        psi{co} * (1-mu{co}) / L{co}[0] * U{co}[0] * (-alpha{co}) = - LGM[0] * (1-theta{co}) / N{co}[0] * (LAMBDA{co}[0] * K{co}[-4]^theta{co}*N{co}[0]^(1-theta{co}))^(-nu{co})*Y{co}[0]^(1+nu{co})

        for lag in 0:(4-1)  
            beta{co}^lag * LGM[lag]*phi{co}
        end +
        for lag in 1:4
            -beta{co}^lag * LGM[lag] * phi{co} * (1-delta{co})
        end = beta{co}^4 * LGM[+4] * theta{co} / K{co}[0] * (LAMBDA{co}[+4] * K{co}[0]^theta{co} * N{co}[+4]^(1-theta{co})) ^ (-nu{co})* Y{co}[+4]^(1+nu{co})

        LGM[0] = beta{co} * LGM[+1] * (1+sigma{co} * Z{co}[0]^(-nu{co}-1)*Y{co}[+1]^(1+nu{co}))
        NX{co}[0] = (Y{co}[0] - (C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1]))/Y{co}[0]
    end

    (LAMBDA{H}[0]-1) = rho{H}{H}*(LAMBDA{H}[-1]-1) + rho{H}{F}*(LAMBDA{F}[-1]-1) + Z_E{H} * E{H}[x]
    (LAMBDA{F}[0]-1) = rho{F}{F}*(LAMBDA{F}[-1]-1) + rho{F}{H}*(LAMBDA{H}[-1]-1) + Z_E{F} * E{F}[x]

    for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end
end

@parameters Backus_Kehoe_Kydland_1992 begin
    K_ss = 11
    K[ss] = K_ss | beta
    
    mu      =    0.34
    gamma   =    -1.0
    alpha   =    1
    eta     =    0.5
    theta   =    0.36
    nu      =    3
    sigma   =    0.01
    delta   =    0.025
    phi     =    1/4
    psi     =    0.5

    Z_E = 0.00852
    
    rho{H}{H} = 0.906
    rho{F}{F} = rho{H}{H}
    rho{H}{F} = 0.088
    rho{F}{H} = rho{H}{F}
end

# Backus model example showing String to String mapping
plot_irf(Backus_Kehoe_Kydland_1992,
    shocks = &quot;E{H}&quot;,
    rename_dictionary = Dict(&quot;C{H}&quot; =&gt; &quot;Home Consumption&quot;, 
                             &quot;C{F}&quot; =&gt; &quot;Foreign Consumption&quot;,
                             &quot;Y{H}&quot; =&gt; &quot;Home Output&quot;,
                             &quot;Y{F}&quot; =&gt; &quot;Foreign Output&quot;))</code></pre><p><img src="../assets/rename_dict_irf__Backus_Kehoe_Kydland_1992__E{H}__1.png" alt="Backus, Kehoe, Kydland 1992 IRF - E{H} shock with rename dictionary"/></p><p>Variables or shocks not included in the dictionary retain their default names. The renaming applies to all plot elements including legends, axis labels, and tables.</p><h2 id="Verbose-Output"><a class="docs-heading-anchor" href="#Verbose-Output">Verbose Output</a><a id="Verbose-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Verbose-Output" title="Permalink"></a></h2><p>The <code>verbose</code> argument (default: <code>false</code>, type: <code>Bool</code>), when <code>true</code>, enables verbose output related to solving the model</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    verbose = true)</code></pre><p>The code outputs information about solving the steady state blocks. When parameters change, the first-order solution is recomputed; otherwise, it uses the cached solution:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    parameters = :Œ≤ =&gt; 0.955,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.95       to 0.955
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 4.3825585462666584e-15
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 5.438959822042073e-16</code></pre><h2 id="Numerical-Tolerances"><a class="docs-heading-anchor" href="#Numerical-Tolerances">Numerical Tolerances</a><a id="Numerical-Tolerances-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Tolerances" title="Permalink"></a></h2><p>The <code>tol</code> argument (default: <code>Tolerances()</code>, type: <code>Tolerances</code>) defines various tolerances for the algorithm used to solve the model. See the Tolerances documentation for more details: <code>?Tolerances</code>. The tolerances used by the numerical solvers can be adjusted. The Tolerances object allows setting tolerances for the non-stochastic steady state solver (NSSS), Sylvester equations, Lyapunov equation, and quadratic matrix equation (QME). For example, to set tighter tolerances (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">custom_tol = Tolerances(qme_acceptance_tol = 1e-12,
    sylvester_acceptance_tol = 1e-12)

plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    tol = custom_tol,
    algorithm = :second_order,
    parameters = :Œ≤ =&gt; 0.9555,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.955      to 0.9555
# New parameters changed the steady state.
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 3.692979383228777e-15
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Quadratic matrix equation solver: schur - converged: true in 0 iterations to tolerance: 3.692979383228777e-15
# Sylvester equation - converged to tol 1.0e-12: true; iterations: 10; reached tol: 6.494758134185766e-17; algorithm: doubling
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16
# Block: 1, - Solved using previous solution; residual norm: 0.0
# Block: 2, - Solved using previous solution; residual norm: 7.021666937153402e-16</code></pre><p>This is useful when higher precision is needed or when the default tolerances are insufficient for convergence. Use this argument for specific needs or when encountering issues with the default solver.</p><h2 id="Quadratic-Matrix-Equation-Solver"><a class="docs-heading-anchor" href="#Quadratic-Matrix-Equation-Solver">Quadratic Matrix Equation Solver</a><a id="Quadratic-Matrix-Equation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Matrix-Equation-Solver" title="Permalink"></a></h2><p>The <code>quadratic_matrix_equation_algorithm</code> argument (default: <code>:schur</code>, type: <code>Symbol</code>) specifies the algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code> The quadratic matrix equation solver is used internally when solving the model to first order. Different algorithms are available. The <code>:schur</code> algorithm is generally faster and more reliable, while <code>:doubling</code> can be more precise in some cases (this example also changes parameters to force recomputation):</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    quadratic_matrix_equation_algorithm = :doubling,
    parameters = :Œ≤ =&gt; 0.95555,
    verbose = true)
# Parameter changes: 
#         Œ≤       from 0.9555     to 0.95555
# New parameters changed the steady state.
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver: doubling - converged: true in 8 iterations to tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>For most use cases, the default <code>:schur</code> algorithm is recommended. Use this argument for specific needs or when encountering issues with the default solver.</p><h2 id="Sylvester-Equation-Solver"><a class="docs-heading-anchor" href="#Sylvester-Equation-Solver">Sylvester Equation Solver</a><a id="Sylvester-Equation-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Sylvester-Equation-Solver" title="Permalink"></a></h2><p>[Default: selector that uses <code>:doubling</code> for smaller problems and switches to <code>:bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: Algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. The input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solution&#39;s Sylvester equation. When only one element is provided, it corresponds to the second-order perturbation solution&#39;s Sylvester equation. The algorithm to use can be specified for solving Sylvester equations in higher-order solutions. For example, select the <code>:bartels_stewart</code> algorithm for solving the second-order perturbation problem:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :second_order,
    sylvester_algorithm = :bartels_stewart,
    verbose = true)
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - converged to tol 1.0e-10: true; iterations: -1; reached tol: 6.19336731775721e-17; algorithm: bartels_stewart
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>For third-order solutions, different algorithms can be specified for the second- and third-order Sylvester equations using a <code>Tuple</code>:</p><pre><code class="language-julia hljs">plot_irf(Gali_2015_chapter_3_nonlinear,
    shocks = :eps_a,
    algorithm = :third_order,
    sylvester_algorithm = (:doubling, :bicgstab),
    verbose = true)
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - previous solution achieves relative tol of 3.838708060339852e-17
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Quadratic matrix equation solver previous solution has tolerance: 1.517007008035588e-16
# Sylvester equation - previous solution achieves relative tol of 3.838708060339852e-17
# Sylvester equation - converged to tol 1.0e-10: true; iterations: 23; reached tol: 8.328904812714592e-17; algorithm: bicgstab
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]
# Block: 1, - Solved with newton using previous solution - 0.0 - 0.0 - [4, 4]
# Block: 2, - Solved with newton using previous solution - 2.220446049250313e-16 - 1.2990825655800334e-16 - [3, 3]</code></pre><p>The choice of algorithm affects both speed and precision: <code>:doubling</code> and <code>:bartels_stewart</code> are generally faster, while <code>:bicgstab</code>, <code>:dqgmres</code>, and <code>:gmres</code> are better for large sparse problems. Use this argument for specific needs or when encountering issues with the default solver.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">¬´ Overview</a><a class="docs-footer-nextpage" href="../plot_solution/">Policy Functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 20:56">Thursday 27 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
