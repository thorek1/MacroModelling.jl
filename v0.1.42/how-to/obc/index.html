<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Occasionally binding constraints · MacroModelling.jl</title><meta name="title" content="Occasionally binding constraints · MacroModelling.jl"/><meta property="og:title" content="Occasionally binding constraints · MacroModelling.jl"/><meta property="twitter:title" content="Occasionally binding constraints · MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../../plotting/">Overview</a></li><li><a class="tocitem" href="../../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../../plot_conditional_forecast/">Conditional Forecasts</a></li><li><a class="tocitem" href="../../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../../plot_model_estimates/">Model Estimates</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../loops/">Programmatic model writing using for-loops</a></li><li class="is-active"><a class="tocitem" href>Occasionally binding constraints</a><ul class="internal"><li><a class="tocitem" href="#Example:-Effective-lower-bound-on-interest-rates"><span>Example: Effective lower bound on interest rates</span></a></li><li><a class="tocitem" href="#Example:-Borrowing-constraint"><span>Example: Borrowing constraint</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How-to guides</a></li><li class="is-active"><a href>Occasionally binding constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Occasionally binding constraints</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/how-to/obc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Occasionally-Binding-Constraints"><a class="docs-heading-anchor" href="#Occasionally-Binding-Constraints">Occasionally Binding Constraints</a><a id="Occasionally-Binding-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Occasionally-Binding-Constraints" title="Permalink"></a></h1><p>Occasionally binding constraints are a form of nonlinearity frequently used to model effects like the zero lower bound on interest rates, or borrowing constraints. Perturbation methods are not able to capture them as they are local approximations. Nonetheless, there are ways to combine the speed of perturbation solutions and the flexibility of occasionally binding constraints. <code>MacroModelling.jl</code> provides a convenient way to write down the constraints and automatically enforces the constraint equation with shocks. More specifically, the constraint equation is enforced for each periods unconditional forecast (default forecast horizon of 40 periods) by constraint equation specific anticipated shocks, while minimising the shock size.</p><p>This guide will demonstrate how to write down models containing occasionally binding constraints (e.g. effective lower bound and borrowing constraint), show some potential problems the user may encounter and how to overcome them, and go through some use cases.</p><p>Common problems that may occur are that no perturbation solution is found, or that the algorithm cannot find a combination of shocks which enforce the constraint equation. The former has to do with the fact that occasionally binding constraints can give rise to more than one steady state but only one is suitable for a perturbation solution. The latter has to do with the dynamics of the model and the fact that a finite amount of shocks is used to enforce the constraint equation.</p><p>Beyond the examples outlined in this guide there is a version of Smets and Wouters (2003) with the ELB in the models folder (filename: <code>SW03_obc.jl</code>).</p><h2 id="Example:-Effective-lower-bound-on-interest-rates"><a class="docs-heading-anchor" href="#Example:-Effective-lower-bound-on-interest-rates">Example: Effective lower bound on interest rates</a><a id="Example:-Effective-lower-bound-on-interest-rates-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Effective-lower-bound-on-interest-rates" title="Permalink"></a></h2><h3 id="Writing-a-model-with-occasionally-binding-constraints"><a class="docs-heading-anchor" href="#Writing-a-model-with-occasionally-binding-constraints">Writing a model with occasionally binding constraints</a><a id="Writing-a-model-with-occasionally-binding-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-a-model-with-occasionally-binding-constraints" title="Permalink"></a></h3><p>Taking the <a href="../../#gali2015">Galı́ (2015)</a>, Chapter 3 model containing a Taylor rule and implementing an effective lower bound on interest rates. The Taylor rule in the model: <code>R[0] = 1 / β * Pi[0] ^ ϕᵖⁱ * (Y[0] / Y[ss]) ^ ϕʸ * exp(nu[0])</code> needs to be modified so that <code>R[0]</code> never goes below an effective lower bound <code>R̄</code>. This can be done using the <code>max</code> operator: <code>R[0] = max(R̄ , 1 / β * Pi[0] ^ ϕᵖⁱ * (Y[0] / Y[ss]) ^ ϕʸ * exp(nu[0]))</code></p><p>The model definition after the change of the Taylor rule looks like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MacroModelling</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model Gali_2015_chapter_3_obc begin
           W_real[0] = C[0] ^ σ * N[0] ^ φ
       
           Q[0] = β * (C[1] / C[0]) ^ (-σ) * Z[1] / Z[0] / Pi[1]
       
           R[0] = 1 / Q[0]
       
           Y[0] = A[0] * (N[0] / S[0]) ^ (1 - α)
       
           R[0] = Pi[1] * realinterest[0]
       
           C[0] = Y[0]
       
           log(A[0]) = ρ_a * log(A[-1]) + std_a * eps_a[x]
       
           log(Z[0]) = ρ_z * log(Z[-1]) - std_z * eps_z[x]
       
           nu[0] = ρ_ν * nu[-1] + std_nu * eps_nu[x]
       
           MC[0] = W_real[0] / (S[0] * Y[0] * (1 - α) / N[0])
       
           1 = θ * Pi[0] ^ (ϵ - 1) + (1 - θ) * Pi_star[0] ^ (1 - ϵ)
       
           S[0] = (1 - θ) * Pi_star[0] ^ (( - ϵ) / (1 - α)) + θ * Pi[0] ^ (ϵ / (1 - α)) * S[-1]
       
           Pi_star[0] ^ (1 + ϵ * α / (1 - α)) = ϵ * x_aux_1[0] / x_aux_2[0] * (1 - τ) / (ϵ - 1)
       
           x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-σ) + β * θ * Pi[1] ^ (ϵ + α * ϵ / (1 - α)) * x_aux_1[1]
       
           x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-σ) + β * θ * Pi[1] ^ (ϵ - 1) * x_aux_2[1]
       
           log_y[0] = log(Y[0])
       
           log_W_real[0] = log(W_real[0])
       
           log_N[0] = log(N[0])
       
           pi_ann[0] = 4 * log(Pi[0])
       
           i_ann[0] = 4 * log(R[0])
       
           r_real_ann[0] = 4 * log(realinterest[0])
       
           M_real[0] = Y[0] / R[0] ^ η
       
           R[0] = max(R̄ , 1 / β * Pi[0] ^ ϕᵖⁱ * (Y[0] / Y[ss]) ^ ϕʸ * exp(nu[0]))
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        Gali_2015_chapter_3_obc
Variables
 Total:       68
  Auxiliary:  41
 States:      44
  Auxiliary:  40
 Jumpers:     5
  Auxiliary:  0
Shocks:       44
Parameters:   18</code></pre><p>In the background the system of equations is augmented by a series of anticipated shocks added to the equation containing the constraint (max/min operator). This explains the large number of auxiliary variables and shocks.</p><p>Next the parameters are defined including the new parameter defining the effective lower bound (which is set to 1, implementing a zero lower bound):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters Gali_2015_chapter_3_obc begin
           R̄ = 1.0
       
           σ = 1
       
           φ = 5
       
           ϕᵖⁱ = 1.5
       
           ϕʸ = 0.125
       
           θ = 0.75
       
           ρ_ν = 0.5
       
           ρ_z = 0.5
       
           ρ_a = 0.9
       
           β = 0.99
       
           η = 3.77
       
           α = 0.25
       
           ϵ = 9
       
           τ = 0
       
           std_a = .01
       
           std_z = .05
       
           std_nu = .0025
       end</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	1.355 seconds
Set up non-stochastic steady state problem:				4.999 seconds
Find non-stochastic steady state:					1.932 seconds
Take symbolic derivatives up to first order:				1.456 seconds
Model:        Gali_2015_chapter_3_obc
Variables
 Total:       68
  Auxiliary:  41
 States:      44
  Auxiliary:  40
 Jumpers:     5
  Auxiliary:  0
Shocks:       44
Parameters:   18</code></pre><h3 id="Verify-the-non-stochastic-steady-state"><a class="docs-heading-anchor" href="#Verify-the-non-stochastic-steady-state">Verify the non-stochastic steady state</a><a id="Verify-the-non-stochastic-steady-state-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-the-non-stochastic-steady-state" title="Permalink"></a></h3><p>Let&#39;s check out the non-stochastic steady state (NSSS):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; SS(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 68-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">68×19 Matrix{Float64}</span>:
                     <span class="sgr35">(:Steady_state)</span>  <span class="sgr35">(:R̄)</span>  …  <span class="sgr35">(:std_nu)</span>  <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:A)</span>                1.0              0.0      0.0        0.0
  <span class="sgr35">(:C)</span>                0.95058          0.0      0.0        0.0
  <span class="sgr35">(:MC)</span>               0.888889         0.0      0.0        0.0
  <span class="sgr35">(:M_real)</span>           0.915236         0.0      0.0        0.0
  <span class="sgr35">(:N)</span>                0.934655         0.0  …   0.0        0.0
  <span class="sgr35">(:Pi)</span>               1.0              0.0      0.0        0.0
   ⋮                                        ⋱
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁰⁾)</span>   0.0              0.0      0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁾)</span>    0.0              0.0      0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁵⁾)</span>    0.0              0.0  …   0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁶⁾)</span>    0.0              0.0      0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁷⁾)</span>    0.0              0.0      0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁸⁾)</span>    0.0              0.0      0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁹⁾)</span>    0.0              0.0      0.0        0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SS(Gali_2015_chapter_3_obc)(:R,:)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
1-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">19-element view(::Matrix{Float64}, 9, :)</span> with eltype Float64:
 <span class="sgr35">(:Steady_state)</span>      1.0101010101010102
 <span class="sgr35">(:R̄)</span>                 0.0
 <span class="sgr35">(:σ)</span>                -1.1289774298214605e-18
 <span class="sgr35">(:φ)</span>                -3.629562591980124e-36
 <span class="sgr35">(:ϕᵖⁱ)</span>               0.0
 <span class="sgr35">(:ϕʸ)</span>                0.0
 <span class="sgr35">(:θ)</span>                -8.359806062374903e-18
 <span class="sgr35">(:ρ_ν)</span>               0.0
  ⋮
 <span class="sgr35">(:α)</span>                 3.0909526765818123e-35
 <span class="sgr35">(:ϵ)</span>                 4.395610325759631e-36
 <span class="sgr35">(:τ)</span>                -2.342575669462868e-33
 <span class="sgr35">(:std_a)</span>             0.0
 <span class="sgr35">(:std_z)</span>             0.0
 <span class="sgr35">(:std_nu)</span>            0.0
 <span class="sgr35">(:activeᵒᵇᶜshocks)</span>   0.0</code></pre><p>There are a few things to note here. First, the NSSS values of the auxiliary variables related to the occasionally binding constraint are shown. Second, the NSSS value of <code>R</code> is 1.010101, and thereby the effective lower bound (ELB) is not binding in the NSSS. If the ELB were not binding, then the NSSS would not be a viable approximation point for perturbation. A perturbation solution can only be found if the effective lower bound is not binding in NSSS. Calling <code>get_solution</code> reveals that there is a stable solution at this NSSS:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_solution(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Steady_state__States__Shocks ∈ 89-element Vector{Symbol}</span>
→   <span class="sgr35">Variables ∈ 68-element Vector{Symbol}</span>
And data, <span class="sgr1">89×68 adjoint(::Matrix{Float64})</span> with eltype Float64:
                         <span class="sgr35">(:A)</span>          …  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁸⁾)</span>  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁹⁾)</span>
  <span class="sgr35">(:Steady_state)</span>         1.0              0.0               0.0
  <span class="sgr35">(:A₍₋₁₎)</span>                0.9              0.0               0.0
  <span class="sgr35">(:S₍₋₁₎)</span>                1.78267e-15      0.0               0.0
  <span class="sgr35">(:Z₍₋₁₎)</span>                8.92673e-16      0.0               0.0
  <span class="sgr35">(:nu₍₋₁₎)</span>              -1.32128e-15  …   0.0               0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻²²⁾₍₋₁₎)</span>   4.51369e-17      0.0               0.0
   ⋮                                   ⋱   ⋮
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁴⁰⁾₍ₓ₎)</span>     -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁴⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁵⁾₍ₓ₎)</span>      -0.0          …  -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁶⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁷⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁸⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁹⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0</code></pre><p>In case of a model or parameterisation that results in a NSSS where the ELB is binding, it is possible to add a restriction on the NSSS values so that the NSSS with binding ELB is excluded. With the above model, in order to exclude the non-viable NSSS the values of <code>R</code> needs to be restricted to be larger than the effective lower bound. This can be done by adding a constraint on the variable in the <code>@parameter</code> section. The model can be redefined:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model Gali_2015_chapter_3_obc begin
           W_real[0] = C[0] ^ σ * N[0] ^ φ
       
           Q[0] = β * (C[1] / C[0]) ^ (-σ) * Z[1] / Z[0] / Pi[1]
       
           R[0] = 1 / Q[0]
       
           Y[0] = A[0] * (N[0] / S[0]) ^ (1 - α)
       
           R[0] = Pi[1] * realinterest[0]
       
           C[0] = Y[0]
       
           log(A[0]) = ρ_a * log(A[-1]) + std_a * eps_a[x]
       
           log(Z[0]) = ρ_z * log(Z[-1]) - std_z * eps_z[x]
       
           nu[0] = ρ_ν * nu[-1] + std_nu * eps_nu[x]
       
           MC[0] = W_real[0] / (S[0] * Y[0] * (1 - α) / N[0])
       
           1 = θ * Pi[0] ^ (ϵ - 1) + (1 - θ) * Pi_star[0] ^ (1 - ϵ)
       
           S[0] = (1 - θ) * Pi_star[0] ^ (( - ϵ) / (1 - α)) + θ * Pi[0] ^ (ϵ / (1 - α)) * S[-1]
       
           Pi_star[0] ^ (1 + ϵ * α / (1 - α)) = ϵ * x_aux_1[0] / x_aux_2[0] * (1 - τ) / (ϵ - 1)
       
           x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-σ) + β * θ * Pi[1] ^ (ϵ + α * ϵ / (1 - α)) * x_aux_1[1]
       
           x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-σ) + β * θ * Pi[1] ^ (ϵ - 1) * x_aux_2[1]
       
           log_y[0] = log(Y[0])
       
           log_W_real[0] = log(W_real[0])
       
           log_N[0] = log(N[0])
       
           pi_ann[0] = 4 * log(Pi[0])
       
           i_ann[0] = 4 * log(R[0])
       
           r_real_ann[0] = 4 * log(realinterest[0])
       
           M_real[0] = Y[0] / R[0] ^ η
       
           R[0] = max(R̄ , 1 / β * Pi[0] ^ ϕᵖⁱ * (Y[0] / Y[ss]) ^ ϕʸ * exp(nu[0]))
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        Gali_2015_chapter_3_obc
Variables
 Total:       68
  Auxiliary:  41
 States:      44
  Auxiliary:  40
 Jumpers:     5
  Auxiliary:  0
Shocks:       44
Parameters:   18</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters Gali_2015_chapter_3_obc begin
           R̄ = 1.0
       
           σ = 1
       
           φ = 5
       
           ϕᵖⁱ = 1.5
       
           ϕʸ = 0.125
       
           θ = 0.75
       
           ρ_ν = 0.5
       
           ρ_z = 0.5
       
           ρ_a = 0.9
       
           β = 0.99
       
           η = 3.77
       
           α = 0.25
       
           ϵ = 9
       
           τ = 0
       
           std_a = .01
       
           std_z = .05
       
           std_nu = .0025
       
           R &gt; 1.000001
       end</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	1.309 seconds
Set up non-stochastic steady state problem:				2.867 seconds
Find non-stochastic steady state:					1.734 seconds
Take symbolic derivatives up to first order:				0.289 seconds
Model:        Gali_2015_chapter_3_obc
Variables
 Total:       68
  Auxiliary:  41
 States:      44
  Auxiliary:  40
 Jumpers:     5
  Auxiliary:  0
Shocks:       44
Parameters:   18</code></pre><p>and check the NSSS once more:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; SS(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 68-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">68×19 Matrix{Float64}</span>:
                     <span class="sgr35">(:Steady_state)</span>  …  <span class="sgr35">(:std_nu)</span>  <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:A)</span>                1.0                 0.0        0.0
  <span class="sgr35">(:C)</span>                0.95058             0.0        0.0
  <span class="sgr35">(:MC)</span>               0.888889            0.0        0.0
  <span class="sgr35">(:M_real)</span>           0.915236            0.0        0.0
  <span class="sgr35">(:N)</span>                0.934655        …   0.0        0.0
  <span class="sgr35">(:Pi)</span>               1.0                 0.0        0.0
   ⋮                                  ⋱
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁰⁾)</span>   0.0                 0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁾)</span>    0.0                 0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁵⁾)</span>    0.0             …   0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁶⁾)</span>    0.0                 0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁷⁾)</span>    0.0                 0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁸⁾)</span>    0.0                 0.0        0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁹⁾)</span>    0.0                 0.0        0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SS(Gali_2015_chapter_3_obc)(:R,:)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
1-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">19-element view(::Matrix{Float64}, 9, :)</span> with eltype Float64:
 <span class="sgr35">(:Steady_state)</span>      1.01010101010101
 <span class="sgr35">(:R̄)</span>                 1.1102230246251565e-16
 <span class="sgr35">(:σ)</span>                 2.3177620163173034e-19
 <span class="sgr35">(:φ)</span>                -1.4515261637662025e-36
 <span class="sgr35">(:ϕᵖⁱ)</span>               2.2428747972225396e-16
 <span class="sgr35">(:ϕʸ)</span>                0.0
 <span class="sgr35">(:θ)</span>                 4.3770041497312626e-17
 <span class="sgr35">(:ρ_ν)</span>               0.0
  ⋮
 <span class="sgr35">(:α)</span>                -2.239974610190368e-35
 <span class="sgr35">(:ϵ)</span>                -3.269568701066365e-33
 <span class="sgr35">(:τ)</span>                -1.4866862421832998e-33
 <span class="sgr35">(:std_a)</span>             0.0
 <span class="sgr35">(:std_z)</span>             0.0
 <span class="sgr35">(:std_nu)</span>            0.0
 <span class="sgr35">(:activeᵒᵇᶜshocks)</span>   0.0</code></pre><p>Now <code>R &gt; R̄</code> is obtained, so that the constraint is not binding in the NSSS and a stable first order solution can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_solution(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Steady_state__States__Shocks ∈ 89-element Vector{Symbol}</span>
→   <span class="sgr35">Variables ∈ 68-element Vector{Symbol}</span>
And data, <span class="sgr1">89×68 adjoint(::Matrix{Float64})</span> with eltype Float64:
                         <span class="sgr35">(:A)</span>          …  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁸⁾)</span>  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁹⁾)</span>
  <span class="sgr35">(:Steady_state)</span>         1.0              0.0               0.0
  <span class="sgr35">(:A₍₋₁₎)</span>                0.9              0.0               0.0
  <span class="sgr35">(:S₍₋₁₎)</span>                1.66476e-15      0.0               0.0
  <span class="sgr35">(:Z₍₋₁₎)</span>                7.51257e-16      0.0               0.0
  <span class="sgr35">(:nu₍₋₁₎)</span>              -1.67058e-15  …   0.0               0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻²²⁾₍₋₁₎)</span>   9.35866e-17      0.0               0.0
   ⋮                                   ⋱   ⋮
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁴⁰⁾₍ₓ₎)</span>     -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁴⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁵⁾₍ₓ₎)</span>      -0.0          …  -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁶⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁷⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁸⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝ⁽⁹⁾₍ₓ₎)</span>      -0.0             -0.0              -0.0</code></pre><h3 id="Generate-model-output"><a class="docs-heading-anchor" href="#Generate-model-output">Generate model output</a><a id="Generate-model-output-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-model-output" title="Permalink"></a></h3><p>Having defined the system with an occasionally binding constraint the model can simply be simulated by calling:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import StatsPlots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; import Random</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(20)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_simulations(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/sim_obc__Gali_2015_chapter_3_obc__simulation__1.png" alt="Simulation_elb"/></p><p>In the background an optimisation problem is set up to find the smallest shocks in magnitude which enforce the equation containing the occasionally binding constraint over the unconditional forecast horizon (default 40 periods) at each period of the simulation. The plots show multiple spells of a binding effective lower bound and many other variables are skewed as a result of the nonlinearity. It can happen that it is not possible to find a combination of shocks which enforce the occasionally binding constraint equation. In this case one solution can be to make the horizon larger over which the algorithm tries to enforce the equation. This can be done by setting the parameter at the beginning of the <code>@model</code> section: <code>@model Gali_2015_chapter_3_obc max_obc_horizon = 60 begin ... end</code>.</p><p>Next the effective lower bound will be changed to <code>0.99</code> and plotted once more:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(20)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_simulations(Gali_2015_chapter_3_obc, parameters = :R̄ =&gt; 0.99)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/sim_obc_elb__Gali_2015_chapter_3_obc__simulation__1.png" alt="Simulation_elb2"/></p><p>Now, the effect of the effective lower bound becomes less important as it binds less often.</p><p>If the occasionally binding constraint should be ignored simply call:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(20)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_simulations(Gali_2015_chapter_3_obc, ignore_obc = true)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/sim_ignore_obc__Gali_2015_chapter_3_obc__simulation__1.png" alt="Simulation_no_elb"/></p><p>and the simulation is based on the first order solution approximated around the NSSS, which is the same as the one for the model without the modified Taylor rule.</p><p>The impulse response functions can be plotted for the <code>eps_z</code> shock, while setting the parameter of the occasionally binding constraint back to <code>1</code>, as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(Gali_2015_chapter_3_obc, shocks = :eps_z, parameters = :R̄ =&gt; 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=4}</code></pre><p><img src="../../assets/obc_irf_higher_bound__Gali_2015_chapter_3_obc__eps_z__1.png" alt="IRF_elb"/></p><p>As can be seen <code>R</code> remains above the effective lower bound in the first period.</p><p>Next, the model is simulated using a series of shocks. E.g. three positive shocks to <code>eps_z</code> in periods 5, 10, and 15 in decreasing magnitude:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks = zeros(1,15)</code><code class="nohighlight hljs ansi" style="display:block;">1×15 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks[5] =  3.0</code><code class="nohighlight hljs ansi" style="display:block;">3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks[10] = 2.0</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks[15] = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sks = KeyedArray(shcks;  Shocks = [:eps_z], Periods = 1:15)  # KeyedArray is provided by the `AxisKeys` package</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Shocks ∈ 1-element Vector{Symbol}</span>
→   <span class="sgr34">Periods ∈ 15-element UnitRange{Int64}</span>
And data, <span class="sgr1">1×15 Matrix{Float64}</span>:
            <span class="sgr34">(1)</span>    <span class="sgr34">(2)</span>    <span class="sgr34">(3)</span>    <span class="sgr34">(4)</span>    …  <span class="sgr34">(12)</span>    <span class="sgr34">(13)</span>    <span class="sgr34">(14)</span>    <span class="sgr34">(15)</span>
  <span class="sgr35">(:eps_z)</span>    0.0    0.0    0.0    0.0        0.0     0.0     0.0     1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(Gali_2015_chapter_3_obc,
                   shocks = sks,
                   periods = 10)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=18}
 Plot{Plots.GRBackend() n=4}</code></pre><p><img src="../../assets/obc_irf__Gali_2015_chapter_3_obc__shock_matrix__1.png" alt="Shock_series_elb"/></p><p>The effective lower bound is binding after all three shocks but the length of the constraint being binding varies with the shock size and is completely endogenous.</p><p>Last but not least, the simulated moments of the model can be obtained (theoretical moments are not available):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(922)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sims = get_irf(Gali_2015_chapter_3_obc,
                       parameters = :R̄ =&gt; 0.99,
                       periods = 500,
                       shocks = :simulate,
                       levels = true)</code><code class="nohighlight hljs ansi" style="display:block;">3-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 23-element Vector{Symbol}</span>
→   <span class="sgr34">Periods ∈ 500-element UnitRange{Int64}</span>
◪   <span class="sgr35">Shocks ∈ 1-element Vector{Symbol}</span>
And data, <span class="sgr1">23×500×1 Array{Float64, 3}</span>:
<span class="sgr35">[:, :, 1] ~ (:, :, :simulate):</span>
                   <span class="sgr34">(1)</span>           …  <span class="sgr34">(499)</span>           <span class="sgr34">(500)</span>
  <span class="sgr35">(:A)</span>               0.988633           1.01169         1.00857
  <span class="sgr35">(:C)</span>               0.951397           0.967469        0.974794
  <span class="sgr35">(:MC)</span>              0.975835           0.932096        1.00908
  <span class="sgr35">(:M_real)</span>          0.884869           0.90571         0.909805
  <span class="sgr35">(:N)</span>               0.949892    …      0.942227        0.955719
  <span class="sgr35">(:Pi)</span>              1.00686            0.999289        1.00371
   ⋮                             ⋱      ⋮
  <span class="sgr35">(:nu)</span>             -0.00136231         0.00631971     -0.000417893
  <span class="sgr35">(:pi_ann)</span>          0.027424    …     -0.00284524      0.0148395
  <span class="sgr35">(:r_real_ann)</span>      0.0570976          0.0771843       0.0702597
  <span class="sgr35">(:realinterest)</span>    1.01437            1.01944         1.01769
  <span class="sgr35">(:x_aux_1)</span>         4.00671            3.31227         3.61352
  <span class="sgr35">(:x_aux_2)</span>         4.18805            3.75946         3.89232</code></pre><p>The mean and standard deviation of output can be examined:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import Statistics</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Statistics.mean(sims(:Y,:,:))</code><code class="nohighlight hljs ansi" style="display:block;">0.9418712489402045</code></pre><p>and</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Statistics.std(sims(:Y,:,:))</code><code class="nohighlight hljs ansi" style="display:block;">0.03653883616368068</code></pre><p>Compare this to the theoretical mean of the model without the occasionally binding constraint:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 23-element Vector{Symbol}</span>
→   <span class="sgr35">Mean_and_∂mean∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">23×19 Matrix{Float64}</span>:
                   <span class="sgr35">(:Mean)</span>       …  <span class="sgr35">(:std_nu)</span>  <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:A)</span>              1.0              0.0        0.0
  <span class="sgr35">(:C)</span>              0.95058          0.0        0.0
  <span class="sgr35">(:MC)</span>             0.888889         0.0        0.0
  <span class="sgr35">(:M_real)</span>         0.915236         0.0        0.0
  <span class="sgr35">(:N)</span>              0.934655     …   0.0        0.0
  <span class="sgr35">(:Pi)</span>             1.0              0.0        0.0
   ⋮                             ⋱
  <span class="sgr35">(:log_y)</span>         -0.0506831        0.0        0.0
  <span class="sgr35">(:nu)</span>             0.0              0.0        0.0
  <span class="sgr35">(:pi_ann)</span>        -4.44089e-16  …   0.0        0.0
  <span class="sgr35">(:r_real_ann)</span>     0.0402013        0.0        0.0
  <span class="sgr35">(:realinterest)</span>   1.0101           0.0        0.0
  <span class="sgr35">(:x_aux_1)</span>        3.452            0.0        0.0
  <span class="sgr35">(:x_aux_2)</span>        3.8835           0.0        0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015_chapter_3_obc)(:Y,:)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
1-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Mean_and_∂mean∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">19-element view(::Matrix{Float64}, 12, :)</span> with eltype Float64:
 <span class="sgr35">(:Mean)</span>              0.9505798249541407
 <span class="sgr35">(:R̄)</span>                 6.209800579046943e-18
 <span class="sgr35">(:σ)</span>                 0.006022296117038609
 <span class="sgr35">(:φ)</span>                 0.008029728156051456
 <span class="sgr35">(:ϕᵖⁱ)</span>               1.2295405146511822e-17
 <span class="sgr35">(:ϕʸ)</span>                0.0
 <span class="sgr35">(:θ)</span>                 0.0
 <span class="sgr35">(:ρ_ν)</span>               0.0
  ⋮
 <span class="sgr35">(:α)</span>                -0.09419214557727859
 <span class="sgr35">(:ϵ)</span>                 0.001650312196100938
 <span class="sgr35">(:τ)</span>                 0.1188224781192675
 <span class="sgr35">(:std_a)</span>             0.0
 <span class="sgr35">(:std_z)</span>             0.0
 <span class="sgr35">(:std_nu)</span>            0.0
 <span class="sgr35">(:activeᵒᵇᶜshocks)</span>   0.0</code></pre><p>and the theoretical standard deviation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015_chapter_3_obc)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 23-element Vector{Symbol}</span>
→   <span class="sgr35">Standard_deviation_and_∂standard_deviation∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">23×19 Matrix{Float64}</span>:
                   <span class="sgr35">(:Standard_deviation)</span>  …  <span class="sgr35">(:std_nu)</span>     <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:A)</span>              0.0229416                 6.18312e-30   0.0
  <span class="sgr35">(:C)</span>              0.0335717                 0.0963579     0.0
  <span class="sgr35">(:MC)</span>             0.216091                  0.837765      0.0
  <span class="sgr35">(:M_real)</span>         0.0592662                 0.254845      0.0
  <span class="sgr35">(:N)</span>              0.0378695             …   0.146816      0.0
  <span class="sgr35">(:Pi)</span>             0.0123588                 0.0334732     0.0
   ⋮                                      ⋱
  <span class="sgr35">(:log_y)</span>          0.0353171                 0.101368      0.0
  <span class="sgr35">(:nu)</span>             0.00288675                1.1547        0.0
  <span class="sgr35">(:pi_ann)</span>         0.049435              …   0.133893      0.0
  <span class="sgr35">(:r_real_ann)</span>     0.0564465                 0.253692      0.0
  <span class="sgr35">(:realinterest)</span>   0.0142542                 0.0640637     0.0
  <span class="sgr35">(:x_aux_1)</span>        0.951526                  1.44896       0.0
  <span class="sgr35">(:x_aux_2)</span>        0.516659                  0.269446      0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015_chapter_3_obc)(:Y,:)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
1-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Standard_deviation_and_∂standard_deviation∂parameter ∈ 19-element Vector{Symbol}</span>
And data, <span class="sgr1">19-element view(::Matrix{Float64}, 12, :)</span> with eltype Float64:
 <span class="sgr35">(:Standard_deviation)</span>   0.033571696779990515
 <span class="sgr35">(:R̄)</span>                   -1.9616832550974006e-17
 <span class="sgr35">(:σ)</span>                   -0.015188891670653567
 <span class="sgr35">(:φ)</span>                   -0.0008487527406969053
 <span class="sgr35">(:ϕᵖⁱ)</span>                 -0.0056092041468526
 <span class="sgr35">(:ϕʸ)</span>                  -0.03311342389433747
 <span class="sgr35">(:θ)</span>                    0.062355612947193356
 <span class="sgr35">(:ρ_ν)</span>                  0.0003287423120011611
  ⋮
 <span class="sgr35">(:α)</span>                    0.01479083688662281
 <span class="sgr35">(:ϵ)</span>                    0.0006244538126499094
 <span class="sgr35">(:τ)</span>                    0.004196462097498798
 <span class="sgr35">(:std_a)</span>                0.9241321458116615
 <span class="sgr35">(:std_z)</span>                0.48178961033413603
 <span class="sgr35">(:std_nu)</span>               0.09635792206682706
 <span class="sgr35">(:activeᵒᵇᶜshocks)</span>      0.0</code></pre><p>The mean of output is lower in the model with effective lower bound compared to the model without and the standard deviation is higher.</p><h2 id="Example:-Borrowing-constraint"><a class="docs-heading-anchor" href="#Example:-Borrowing-constraint">Example: Borrowing constraint</a><a id="Example:-Borrowing-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Borrowing-constraint" title="Permalink"></a></h2><h3 id="Model-definition"><a class="docs-heading-anchor" href="#Model-definition">Model definition</a><a id="Model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-definition" title="Permalink"></a></h3><p>Starting with a consumption-saving model containing a borrowing constraint (see [@citet cuba2019likelihood] for details). Output is exogenously given, and households can only borrow up to a fraction of output and decide between saving and consumption. The first order conditions of the model are:</p><p class="math-container">\[\begin{align*}
Y_t + B_t &amp;= C_t + R \, B_{t-1}\\
\log(Y_t) &amp;= \rho \, \log(Y_{t-1}) + \sigma \, \varepsilon_t\\
C_t^{-\gamma} &amp;= \beta \, R \, \mathbb{E}_t (C_{t+1}^{-\gamma}) + \lambda_t\\
0 &amp;= \lambda_t \, (B_t - mY_t)
\end{align*}\]</p><p>in order to write this model down the Karush-Kuhn-Tucker condition (last equation) needs to be expressed using a max (or min) operator, so that it becomes:</p><p class="math-container">\[0 = \max(B_t - mY_t, -\lambda_t)\]</p><p>This model containing an occasionally binding constraint can be written in a very convenient way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model borrowing_constraint begin
           Y[0] + B[0] = C[0] + R * B[-1]
       
           log(Y[0]) = ρ * log(Y[-1]) + σ * ε[x]
       
           C[0]^(-γ) = β * R * C[1]^(-γ) + λ[0]
       
           0 = max(B[0] - m * Y[0], -λ[0])
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        borrowing_constraint
Variables
 Total:       49
  Auxiliary:  41
 States:      42
  Auxiliary:  40
 Jumpers:     1
  Auxiliary:  0
Shocks:       42
Parameters:   7</code></pre><p>In the background the system of equations is augmented by a series of anticipated shocks added to the equation containing the constraint (max/min operator). This explains the large number of auxiliary variables and shocks.</p><p>Next the parameters are defined as usual:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters borrowing_constraint begin
           R = 1.05
           β = 0.945
           ρ = 0.9
           σ = 0.05
           m = 1
           γ = 1
       end</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	0.487 seconds
Set up non-stochastic steady state problem:				0.328 seconds
Find non-stochastic steady state:					0.831 seconds
Take symbolic derivatives up to first order:				0.755 seconds
Model:        borrowing_constraint
Variables
 Total:       49
  Auxiliary:  41
 States:      42
  Auxiliary:  40
 Jumpers:     1
  Auxiliary:  0
Shocks:       42
Parameters:   7</code></pre><h3 id="Working-with-the-model"><a class="docs-heading-anchor" href="#Working-with-the-model">Working with the model</a><a id="Working-with-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-the-model" title="Permalink"></a></h3><p>For the non-stochastic steady state (NSSS) to exist the constraint has to be binding (<code>B[0] = m * Y[0]</code>). This implies a wedge in the Euler equation (<code>λ &gt; 0</code>).</p><p>This can be checked by getting the NSSS:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; SS(borrowing_constraint)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 49-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 8-element Vector{Symbol}</span>
And data, <span class="sgr1">49×8 Matrix{Float64}</span>:
                     <span class="sgr35">(:Steady_state)</span>  …  <span class="sgr35">(:γ)</span>          <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:B)</span>                1.0                 0.0           0.0
  <span class="sgr35">(:C)</span>                0.95                0.0           0.0
  <span class="sgr35">(:Y)</span>                1.0                 0.0           0.0
  <span class="sgr35">(:Χᵒᵇᶜ⁺ꜝ¹ꜝ)</span>         0.0                 0.0           0.0
  <span class="sgr35">(:λ)</span>                0.00815789      …   0.000418445   0.0
  <span class="sgr35">(:χᵒᵇᶜ⁺ꜝ¹ꜝʳ)</span>       -0.00815789         -0.000418445   0.0
   ⋮                                  ⋱
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁰⁾)</span>   0.0                 0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁴⁾)</span>    0.0                 0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁵⁾)</span>    0.0             …   0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁶⁾)</span>    0.0                 0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁷⁾)</span>    0.0                 0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁸⁾)</span>    0.0                 0.0           0.0
  <span class="sgr35">(:ϵᵒᵇᶜ⁺ꜝ¹ꜝᴸ⁽⁻⁹⁾)</span>    0.0                 0.0           0.0</code></pre><p>A common task is to plot impulse response functions for positive and negative shocks. This should allow understanding the role of the constraint.</p><p>First, the StatsPlots package needs to be imported and then the positive shock can be plotted.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import StatsPlots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(borrowing_constraint)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/obc_irf__borrowing_constraint__ε__1.png" alt="Positive_shock"/></p><p>The constraint is no longer binding in the first five periods because <code>Y</code> and <code>B</code> do not increase by the same amount. They should move by the same amount in the case of a negative shock:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import StatsPlots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(borrowing_constraint, negative_shock = true)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/obc_neg_irf__borrowing_constraint__ε__1.png" alt="Negative_shock"/></p><p>and indeed in this case they move by the same amount. The difference between a positive and negative shock demonstrates the influence of the occasionally binding constraint.</p><p>Another common exercise is to plot the impulse response functions from a series of shocks. Assuming in period 10 there is a positive shock and in period 30 a negative one, and viewing the results for 50 more periods, this can be done as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks = zeros(1,30)</code><code class="nohighlight hljs ansi" style="display:block;">1×30 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks[10] =  .6</code><code class="nohighlight hljs ansi" style="display:block;">0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shcks[30] = -.6</code><code class="nohighlight hljs ansi" style="display:block;">-0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sks = KeyedArray(shcks;  Shocks = [:ε], Periods = 1:30)  # KeyedArray is provided by the `AxisKeys` package</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Shocks ∈ 1-element Vector{Symbol}</span>
→   <span class="sgr34">Periods ∈ 30-element UnitRange{Int64}</span>
And data, <span class="sgr1">1×30 Matrix{Float64}</span>:
        <span class="sgr34">(1)</span>    <span class="sgr34">(2)</span>    <span class="sgr34">(3)</span>    <span class="sgr34">(4)</span>    <span class="sgr34">(5)</span>    …  <span class="sgr34">(27)</span>    <span class="sgr34">(28)</span>    <span class="sgr34">(29)</span>    <span class="sgr34">(30)</span>
  <span class="sgr35">(:ε)</span>    0.0    0.0    0.0    0.0    0.0        0.0     0.0     0.0    -0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(borrowing_constraint, shocks = sks, periods = 50)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/obc_shocks_irf__borrowing_constraint__shock_matrix__1.png" alt="Simulation"/></p><p>In this case the difference between the shocks and the impact of the constraint become quite obvious. Comparing this with a version of the model that ignores the occasionally binding constraint, in order to plot the impulse response functions without dynamically enforcing the constraint simply write:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(borrowing_constraint, shocks = sks, periods = 50, ignore_obc = true)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=8}</code></pre><p><img src="../../assets/obc_shocks_irf_no_obc__borrowing_constraint__shock_matrix__1.png" alt="Simulation"/></p><p>Another interesting statistic is model moments. As there are no theoretical moments reliance on simulated data is necessary:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(17339053787832050337)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sims = get_irf(borrowing_constraint,
                       periods = 300,
                       shocks = :simulate,
                       levels = true)</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: No solution in period: 113
└ @ MacroModelling ~/work/MacroModelling.jl/MacroModelling.jl/src/MacroModelling.jl:8552
3-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr34">Periods ∈ 300-element UnitRange{Int64}</span>
◪   <span class="sgr35">Shocks ∈ 1-element Vector{Symbol}</span>
And data, <span class="sgr1">4×300×1 Array{Float64, 3}</span>:
<span class="sgr35">[:, :, 1] ~ (:, :, :simulate):</span>
        <span class="sgr34">(1)</span>         <span class="sgr34">(2)</span>          …  <span class="sgr34">(299)</span>           <span class="sgr34">(300)</span>
  <span class="sgr35">(:B)</span>    0.904661    0.871934          1.0             1.0
  <span class="sgr35">(:C)</span>    0.759321    0.793974          0.95            0.95
  <span class="sgr35">(:Y)</span>    0.904661    0.871934          1.0             1.0
  <span class="sgr35">(:λ)</span>    0.140821    0.0754388         0.00815789      0.00815789</code></pre><p>Let&#39;s look at the mean and standard deviation of borrowing:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import Statistics</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Statistics.mean(sims(:B,:,:))</code><code class="nohighlight hljs ansi" style="display:block;">0.9685598423932612</code></pre><p>and</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Statistics.std(sims(:B,:,:))</code><code class="nohighlight hljs ansi" style="display:block;">0.057061828187397176</code></pre><p>Compare this to the theoretical mean of the model without the occasionally binding constraint:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(borrowing_constraint)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Mean_and_∂mean∂parameter ∈ 8-element Vector{Symbol}</span>
And data, <span class="sgr1">4×8 Matrix{Float64}</span>:
        <span class="sgr35">(:Mean)</span>      <span class="sgr35">(:R)</span>      <span class="sgr35">(:β)</span>      …  <span class="sgr35">(:γ)</span>          <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:B)</span>   1.0          0.0       0.0          0.0           0.0
  <span class="sgr35">(:C)</span>   0.95        -1.0       0.0          0.0           0.0
  <span class="sgr35">(:Y)</span>   1.0          0.0       0.0          0.0           0.0
  <span class="sgr35">(:λ)</span>   0.00815789  -0.98615  -1.10526      0.000418445   0.0</code></pre><p>and the theoretical standard deviation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(borrowing_constraint)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Standard_deviation_and_∂standard_deviation∂parameter ∈ 8-element Vector{Symbol}</span>
And data, <span class="sgr1">4×8 Matrix{Float64}</span>:
        <span class="sgr35">(:Standard_deviation)</span>  …  <span class="sgr35">(:γ)</span>          <span class="sgr35">(:activeᵒᵇᶜshocks)</span>
  <span class="sgr35">(:B)</span>   0.114708                  6.04919e-18   0.0
  <span class="sgr35">(:C)</span>   0.131914                 -4.14238e-18   0.0
  <span class="sgr35">(:Y)</span>   0.114708                  0.0           0.0
  <span class="sgr35">(:λ)</span>   0.0703174                 0.0739243     0.0</code></pre><p>The mean and standard deviation of borrowing is lower in the model with occasionally binding constraints compared to the model without.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../loops/">« Programmatic model writing using for-loops</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 11:56">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
