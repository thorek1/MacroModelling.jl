# Available algorithms: 
# :doubling     - fast and precise
# :bartels_stewart     - fast for small matrices and precise, dense matrices only
# :bicgstab     - less precise
# :gmres        - less precise

# :iterative    - slow and precise
# :speedmapping - slow and very precise

# solves: A * X * A' + C = X
@stable default_mode = "disable" begin

function solve_lyapunov_equation(A::AbstractMatrix{T},
                                C::AbstractMatrix{T};
                                lyapunov_algorithm::Symbol = :doubling,
                                tol::AbstractFloat = 1e-14,
                                acceptance_tol::AbstractFloat = 1e-12,
                                verbose::Bool = false)::Union{Tuple{Matrix{T}, Bool}, Tuple{ThreadedSparseArrays.ThreadedSparseMatrixCSC{T, Int, SparseMatrixCSC{T, Int}}, Bool}} where T <: Float64
                                # timer::TimerOutput = TimerOutput(),
    # @timeit_debug timer "Solve lyapunov equation" begin
    # @timeit_debug timer "Choose matrix formats" begin
        
    if lyapunov_algorithm ‚â† :bartels_stewart
        A = choose_matrix_format(A)
    else
        # A = choose_matrix_format(A, density_threshold = 0.0)
        A = collect(A)
    end

    # C = choose_matrix_format(C, density_threshold = 0.0)
    C = collect(C) # C is always dense because the output will be dense in all of these cases as we use this function to compute dense covariance matrices
 
    # end # timeit_debug           
    # @timeit_debug timer "Solve" begin

    X, i, reached_tol = solve_lyapunov_equation(A, C, Val(lyapunov_algorithm), tol = tol) # timer = timer)

    if verbose
        println("Lyapunov equation - converged to tol $acceptance_tol: $(reached_tol < acceptance_tol); iterations: $i; reached tol: $reached_tol; algorithm: $lyapunov_algorithm")
    end
    
    if reached_tol > acceptance_tol && lyapunov_algorithm ‚â† :doubling
        C = collect(C)

        X, i, reached_tol = solve_lyapunov_equation(A, C, Val(:doubling), tol = tol) # timer = timer)

        if verbose
            println("Lyapunov equation - converged to tol $acceptance_tol: $(reached_tol < acceptance_tol); iterations: $i; reached tol: $reached_tol; algorithm: doubling")
        end
    end

    if reached_tol > acceptance_tol && lyapunov_algorithm ‚â† :bicgstab
        C = collect(C)

        X, i, reached_tol = solve_lyapunov_equation(A, C, Val(:bicgstab), tol = tol) # timer = timer)

        if verbose
            println("Lyapunov equation - converged to tol $acceptance_tol: $(reached_tol < acceptance_tol); iterations: $i; reached tol: $reached_tol; algorithm: bicgstab")
        end
    end

    if !(reached_tol < acceptance_tol) && lyapunov_algorithm ‚â† :bartels_stewart && length(C) < 5e7 # try sylvester if previous one didn't solve it
        A = collect(A)

        C = collect(C)

        X, i, reached_tol = solve_lyapunov_equation(A, C, Val(:bartels_stewart), tol = tol) # timer = timer)

        if verbose
            println("Lyapunov equation - converged to tol $acceptance_tol: $(reached_tol < acceptance_tol); iterations: $i; reached tol: $reached_tol; algorithm: bartels_stewart")
        end
    end
    # end # timeit_debug
    # end # timeit_debug
    
    # if (reached_tol > tol) println("Lyapunov failed: $reached_tol") end

    return X, reached_tol < acceptance_tol
end

end # dispatch_doctor

function rrule(::typeof(solve_lyapunov_equation),
                A::AbstractMatrix{Float64},
                C::AbstractMatrix{Float64};
                lyapunov_algorithm::Symbol = :doubling,
                tol::AbstractFloat = 1e-14,
                acceptance_tol::AbstractFloat = 1e-12,
                # timer::TimerOutput = TimerOutput(),
                verbose::Bool = false)

    P, solved = solve_lyapunov_equation(A, C, lyapunov_algorithm = lyapunov_algorithm, tol = tol, verbose = verbose)

    # pullback 
    # https://arxiv.org/abs/2011.11430  
    function solve_lyapunov_equation_pullback(‚àÇP)
        ‚àÇC, slvd = solve_lyapunov_equation(A', ‚àÇP[1], lyapunov_algorithm = lyapunov_algorithm,  tol = tol, verbose = verbose)
    
        solved = solved && slvd

        ‚àÇA = ‚àÇC * A * P' + ‚àÇC' * A * P

        return NoTangent(), ‚àÇA, ‚àÇC, NoTangent()
    end
    
    return (P, solved), solve_lyapunov_equation_pullback
end

@stable default_mode = "disable" begin

function solve_lyapunov_equation(  A::AbstractMatrix{‚Ñ±.Dual{Z,S,N}},
                                    C::AbstractMatrix{‚Ñ±.Dual{Z,S,N}};
                                    lyapunov_algorithm::Symbol = :doubling,
                                    tol::AbstractFloat = 1e-14,
                                    acceptance_tol::AbstractFloat = 1e-12,
                                    # timer::TimerOutput = TimerOutput(),
                                    verbose::Bool = false)::Tuple{Matrix{‚Ñ±.Dual{Z,S,N}}, Bool} where {Z,S,N}
    # unpack: AoS -> SoA
    AÃÇ = ‚Ñ±.value.(A)
    CÃÇ = ‚Ñ±.value.(C)

    PÃÇ, solved = solve_lyapunov_equation(AÃÇ, CÃÇ, lyapunov_algorithm = lyapunov_algorithm, tol = tol, verbose = verbose)

    AÃÉ = copy(AÃÇ)
    CÃÉ = copy(CÃÇ)
    
    PÃÉ = zeros(length(PÃÇ), N)
    
    # https://arxiv.org/abs/2011.11430  
    for i in 1:N
        AÃÉ .= ‚Ñ±.partials.(A, i)
        CÃÉ .= ‚Ñ±.partials.(C, i)

        X = AÃÉ * PÃÇ * AÃÇ' + AÃÇ * PÃÇ * AÃÉ' + CÃÉ

        if ‚Ñí.norm(X) < eps() continue end

        P, slvd = solve_lyapunov_equation(AÃÇ, X, lyapunov_algorithm = lyapunov_algorithm, tol = tol, verbose = verbose)
        
        solved = solved && slvd

        PÃÉ[:,i] = vec(P)
    end
    
    return reshape(map(PÃÇ, eachrow(PÃÉ)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end, size(PÃÇ)), solved
end



function solve_lyapunov_equation(   A::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    C::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    ::Val{:bartels_stewart};
                                    # timer::TimerOutput = TimerOutput(),
                                    tol::AbstractFloat = 1e-14)::Tuple{Matrix{T}, Int, T} where T <: AbstractFloat
    ùêÇ = try 
        MatrixEquations.lyapd(A, C)
    catch
        return C, 0, 1.0
    end
    
    # ùêÇ¬π = A * ùêÇ * A' + C

    # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π - ùêÇ) / denom   
    
    reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

    # if reached_tol > tol
    #     println("Lyapunov: lyapunov $reached_tol")
    # end

    return ùêÇ, 0, reached_tol # return info on convergence
end



function solve_lyapunov_equation(   A::AbstractSparseMatrix{T},
                                    C::AbstractSparseMatrix{T},
                                    ::Val{:doubling};
                                    # timer::TimerOutput = TimerOutput(),
                                    tol::Float64 = 1e-14)::Tuple{<:AbstractSparseMatrix{T}, Int, T} where T <: AbstractFloat
    ùêÇ  = copy(C)
    ùêÄ  = copy(A)

    max_iter = 500

    iters = max_iter

    for i in 1:max_iter
        ùêÇ¬π = ùêÄ * ùêÇ * ùêÄ' + ùêÇ

        ùêÄ = ùêÄ^2

        droptol!(ùêÄ, eps())

        if i % 2 == 0
            normdiff = ‚Ñí.norm(ùêÇ¬π - ùêÇ)
            if !isfinite(normdiff) || normdiff / max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π)) < tol
            # if isapprox(ùêÇ¬π, ùêÇ, rtol = tol)
                iters = i
                break 
            end
        end

        ùêÇ = ùêÇ¬π
    end

    # ùêÇ¬π = ùêÄ * ùêÇ * ùêÄ' + ùêÇ

    # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π - ùêÇ) / denom

    reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

    # if reached_tol > tol
    #     println("Lyapunov: doubling $reached_tol")
    # end

    return ùêÇ, iters, reached_tol # return info on convergence
end


function solve_lyapunov_equation(   A::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    C::AbstractSparseMatrix{T},
                                    ::Val{:doubling};
                                    # timer::TimerOutput = TimerOutput(),
                                    tol::Float64 = 1e-14)::Tuple{<:AbstractSparseMatrix{T}, Int, T} where T <: AbstractFloat
    ùêÇ  = copy(C)
    ùêÄ  = copy(A)

    ùêÄ¬≤ = similar(ùêÄ)

    max_iter = 500

    iters = max_iter

    for i in 1:max_iter
        ùêÇ¬π = ùêÄ * ùêÇ * ùêÄ' + ùêÇ

        ‚Ñí.mul!(ùêÄ¬≤, ùêÄ, ùêÄ)
        copyto!(ùêÄ, ùêÄ¬≤)

        # droptol!(ùêÄ, eps())

        if i % 2 == 0
            normdiff = ‚Ñí.norm(ùêÇ¬π - ùêÇ)
            if !isfinite(normdiff) || normdiff / max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π)) < tol
            # if isapprox(ùêÇ¬π, ùêÇ, rtol = tol)
                iters = i
                break 
            end
        end

        ùêÇ = ùêÇ¬π
    end

    # ùêÇ¬π = ùêÄ * ùêÇ * ùêÄ' + ùêÇ

    # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π - ùêÇ) / denom

    reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

    # if reached_tol > tol
    #     println("Lyapunov: doubling $reached_tol")
    # end

    return ùêÇ, iters, reached_tol # return info on convergence
end


function solve_lyapunov_equation(   A::AbstractSparseMatrix{T},
                                    C::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    ::Val{:doubling};
                                    # timer::TimerOutput = TimerOutput(),
                                    tol::Float64 = 1e-14)::Tuple{Matrix{T}, Int, T} where T <: AbstractFloat
    ùêÇ  = copy(C)
    ùêÄ  = copy(A)
    ùêÇA = collect(ùêÄ)    
    ùêÇ¬π = copy(C)

    max_iter = 500

    iters = max_iter

    for i in 1:max_iter
        # ùêÇ¬π .= ùêÄ * ùêÇ * ùêÄ' + ùêÇ
        ‚Ñí.mul!(ùêÇA, ùêÇ, ùêÄ')
        ‚Ñí.mul!(ùêÇ¬π, ùêÄ, ùêÇA, 1, 1)

        # ùêÄ *= ùêÄ
        ùêÄ = ùêÄ^2 # faster than A *= A
        # copyto!(ùêÇA,ùêÄ)
        # ùêÄ = sparse(ùêÄ * ùêÇA)
        # ùêÄ = sparse(ùêÇA * ùêÄ) # faster than sparse-dense matmul but slower than sparse sparse matmul
        
        droptol!(ùêÄ, eps())

        if i % 2 == 0
            normdiff = ‚Ñí.norm(ùêÇ¬π - ùêÇ)
            if !isfinite(normdiff) || normdiff / max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π)) < tol
            # if isapprox(ùêÇ¬π, ùêÇ, rtol = tol)
                iters = i
                break 
            end
        end

        copy!(ùêÇ,ùêÇ¬π)
        # ùêÇ = ùêÇ¬π
    end

    # ‚Ñí.mul!(ùêÇA, ùêÇ, A')
    # ‚Ñí.mul!(ùêÇ¬π, A, ùêÇA)
    # ‚Ñí.axpy!(1, C, ùêÇ¬π)

    # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

    # ‚Ñí.axpy!(-1, ùêÇ, ùêÇ¬π)

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π) / denom

    reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

    # if reached_tol > tol
    #     println("Lyapunov: doubling $reached_tol")
    # end

    return ùêÇ, iters, reached_tol # return info on convergence
end




function solve_lyapunov_equation(   A::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    C::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                    ::Val{:doubling};
                                    # timer::TimerOutput = TimerOutput(),
                                    tol::Float64 = 1e-14)::Tuple{Matrix{T}, Int, T} where T <: AbstractFloat
    ùêÇ  = copy(C)
    ùêÇ¬π = copy(C)
    ùêÄ  = copy(A)

    ùêÇA = similar(ùêÄ)
    ùêÄ¬≤ = similar(ùêÄ)

    max_iter = 500

    iters = max_iter

    for i in 1:max_iter
        ‚Ñí.mul!(ùêÇA, ùêÇ, ùêÄ')
        ‚Ñí.mul!(ùêÇ¬π, ùêÄ, ùêÇA, 1, 1)

        ‚Ñí.mul!(ùêÄ¬≤, ùêÄ, ùêÄ)
        copyto!(ùêÄ, ùêÄ¬≤)
        
        if i % 2 == 0
            normdiff = ‚Ñí.norm(ùêÇ¬π - ùêÇ)
            if !isfinite(normdiff) || normdiff / max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π)) < tol
            # if isapprox(ùêÇ¬π, ùêÇ, rtol = tol)
                iters = i
                break 
            end
        end

        copyto!(ùêÇ, ùêÇ¬π)
    end

    # ‚Ñí.mul!(ùêÇA, ùêÇ, A')
    # ‚Ñí.mul!(ùêÇ¬π, A, ùêÇA)
    # ‚Ñí.axpy!(1, C, ùêÇ¬π)

    # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

    # ‚Ñí.axpy!(-1, ùêÇ, ùêÇ¬π)

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π) / denom
    
    reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

    # if reached_tol > tol
    #     println("Lyapunov: doubling $reached_tol")
    # end

    return ùêÇ, iters, reached_tol # return info on convergence
end




function solve_lyapunov_equation(A::AbstractMatrix{T},
                                C::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                ::Val{:bicgstab};
                                # timer::TimerOutput = TimerOutput(),
                                tol::Float64 = 1e-14)::Tuple{Matrix{T}, Int, T} where T <: AbstractFloat
    tmpÃÑ = similar(C)
    ùêó = similar(C)

    function lyapunov!(sol,ùê±)
        copyto!(ùêó, ùê±)
        ‚Ñí.mul!(tmpÃÑ, ùêó, A')
        ‚Ñí.mul!(ùêó, A, tmpÃÑ, -1, 1)
        copyto!(sol, ùêó)
    end

    lyapunov = LinearOperators.LinearOperator(Float64, length(C), length(C), true, true, lyapunov!)

    ùêÇ, info = Krylov.bicgstab(lyapunov, [vec(C);], rtol = tol, atol = tol)

    copyto!(ùêó, ùêÇ)

    # ‚Ñí.mul!(tmpÃÑ, A, ùêó * A')
    # ‚Ñí.axpy!(1, C, tmpÃÑ)

    # denom = max(‚Ñí.norm(ùêó), ‚Ñí.norm(tmpÃÑ))

    # ‚Ñí.axpy!(-1, ùêó, tmpÃÑ)

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(tmpÃÑ) / denom

    reached_tol = ‚Ñí.norm(A * ùêó * A' + C - ùêó) / ‚Ñí.norm(ùêó)

    # if reached_tol > tol
    #     println("Lyapunov: bicgstab $reached_tol")
    # end

    return ùêó, info.niter, reached_tol
end


function solve_lyapunov_equation(A::AbstractMatrix{T},
                                C::Union{‚Ñí.Adjoint{T, Matrix{T}}, DenseMatrix{T}},
                                ::Val{:gmres};
                                # timer::TimerOutput = TimerOutput(),
                                tol::Float64 = 1e-14)::Tuple{Matrix{T}, Int, T} where T <: AbstractFloat
    tmpÃÑ = similar(C)
    ùêó = similar(C)

    function lyapunov!(sol,ùê±)
        copyto!(ùêó, ùê±)
        # ùêó = @view reshape(ùê±, size(ùêó))
        ‚Ñí.mul!(tmpÃÑ, ùêó, A')
        ‚Ñí.mul!(ùêó, A, tmpÃÑ, -1, 1)
        copyto!(sol, ùêó)
        # sol = @view reshape(ùêó, size(sol))
    end

    lyapunov = LinearOperators.LinearOperator(Float64, length(C), length(C), true, true, lyapunov!)

    ùêÇ, info = Krylov.gmres(lyapunov, [vec(C);], rtol = tol, atol = tol)

    copyto!(ùêó, ùêÇ)

    # ‚Ñí.mul!(tmpÃÑ, A, ùêó * A')
    # ‚Ñí.axpy!(1, C, tmpÃÑ)

    # denom = max(‚Ñí.norm(ùêó), ‚Ñí.norm(tmpÃÑ))

    # ‚Ñí.axpy!(-1, ùêó, tmpÃÑ)

    # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(tmpÃÑ) / denom

    reached_tol = ‚Ñí.norm(A * ùêó * A' + C - ùêó) / ‚Ñí.norm(ùêó)

    # if reached_tol > tol
    #     println("Lyapunov: gmres $reached_tol")
    # end

    return ùêó, info.niter, reached_tol
end


# function solve_lyapunov_equation(A::AbstractMatrix{Float64},
#                                 C::Union{‚Ñí.Adjoint{Float64,Matrix{Float64}},DenseMatrix{Float64}},
#                                 ::Val{:iterative};
#                                 tol::AbstractFloat = 1e-14,
#                                 timer::TimerOutput = TimerOutput())
#     ùêÇ  = copy(C)
#     ùêÇ¬π = copy(C)
#     ùêÇA = copy(C)
    
#     max_iter = 10000
    
#     iters = max_iter

#     for i in 1:max_iter
#         ‚Ñí.mul!(ùêÇA, ùêÇ, A')
#         ‚Ñí.mul!(ùêÇ¬π, A, ùêÇA)
#         ‚Ñí.axpy!(1, C, ùêÇ¬π)
    
#         if i % 10 == 0
#             normdiff = ‚Ñí.norm(ùêÇ¬π - ùêÇ)
#             if !isfinite(normdiff) || normdiff / max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π)) < tol
#             # if isapprox(ùêÇ¬π, ùêÇ, rtol = tol)
#                 iters = i
#                 break
#             end
#         end
    
#         copyto!(ùêÇ, ùêÇ¬π)
#     end

#     # ‚Ñí.mul!(ùêÇA, ùêÇ, A')
#     # ‚Ñí.mul!(ùêÇ¬π, A, ùêÇA)
#     # ‚Ñí.axpy!(1, C, ùêÇ¬π)

#     # denom = max(‚Ñí.norm(ùêÇ), ‚Ñí.norm(ùêÇ¬π))

#     # ‚Ñí.axpy!(-1, ùêÇ, ùêÇ¬π)

#     # reached_tol = denom == 0 ? 0.0 : ‚Ñí.norm(ùêÇ¬π) / denom
    
#     reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

#     # if reached_tol > tol
#     #     println("Lyapunov: iterative $reached_tol")
#     # end

#     return ùêÇ, iters, reached_tol # return info on convergence
# end


# function solve_lyapunov_equation(A::AbstractMatrix{Float64},
#                                     C::Union{‚Ñí.Adjoint{Float64,Matrix{Float64}},DenseMatrix{Float64}},
#                                     ::Val{:speedmapping};
#                                     tol::AbstractFloat = 1e-14,
#                                     timer::TimerOutput = TimerOutput())
#     ùêÇA = similar(C)

#     soll = speedmapping(C; 
#             m! = (X, x) -> begin
#                 ‚Ñí.mul!(ùêÇA, x, A')
#                 ‚Ñí.mul!(X, A, ùêÇA)
#                 ‚Ñí.axpy!(1, C, X)
#             end, stabilize = false, maps_limit = 1000, tol = tol)
    
#     ùêÇ = soll.minimizer

#     reached_tol = ‚Ñí.norm(A * ùêÇ * A' + C - ùêÇ) / ‚Ñí.norm(ùêÇ)

#     # if reached_tol > tol
#     #     println("Lyapunov: speedmapping $reached_tol")
#     # end

#     return ùêÇ, soll.maps, reached_tol
# end

end # dispatch_doctor