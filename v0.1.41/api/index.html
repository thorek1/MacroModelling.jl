<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MacroModelling.jl</title><meta name="title" content="API · MacroModelling.jl"/><meta property="og:title" content="API · MacroModelling.jl"/><meta property="twitter:title" content="API · MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.SS" href="#MacroModelling.SS"><code>MacroModelling.SS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1698-L1700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.SSS-Tuple" href="#MacroModelling.SSS-Tuple"><code>MacroModelling.SSS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1685-L1687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.autocorr" href="#MacroModelling.autocorr"><code>MacroModelling.autocorr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.ℳ}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2631-L2633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.check_residuals" href="#MacroModelling.check_residuals"><code>MacroModelling.check_residuals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.ℳ, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>get_non_stochastic_steady_state_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3685-L3687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.corr" href="#MacroModelling.corr"><code>MacroModelling.corr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.ℳ}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2496-L2498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.cov" href="#MacroModelling.cov"><code>MacroModelling.cov</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3178-L3180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_dynare" href="#MacroModelling.export_dynare"><code>MacroModelling.export_dynare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_mod_file" href="#MacroModelling.export_mod_file"><code>MacroModelling.export_mod_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L227-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_model" href="#MacroModelling.export_model"><code>MacroModelling.export_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L247-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.export_to_dynare" href="#MacroModelling.export_to_dynare"><code>MacroModelling.export_to_dynare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.fevd" href="#MacroModelling.fevd"><code>MacroModelling.fevd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2245-L2247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_IRF" href="#MacroModelling.get_IRF"><code>MacroModelling.get_IRF</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1394-L1396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_SS" href="#MacroModelling.get_SS"><code>MacroModelling.get_SS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1708-L1710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_SSS-Tuple" href="#MacroModelling.get_SSS-Tuple"><code>MacroModelling.get_SSS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1679-L1681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_autocorr" href="#MacroModelling.get_autocorr"><code>MacroModelling.get_autocorr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.ℳ}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2625-L2627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_autocorrelation-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_autocorrelation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_autocorrelation(
    𝓂;
    autocorrelation_periods,
    parameters,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the autocorrelations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>, Type: <code>UnitRange{Int}</code>]: periods for which to return the autocorrelation</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows and autocorrelation periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_autocorrelation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Autocorrelation_periods ∈ 5-element UnitRange{Int64}
And data, 4×5 Matrix{Float64}:
        (1)         (2)         (3)         (4)         (5)
  (:c)    0.966974    0.927263    0.887643    0.849409    0.812761
  (:k)    0.971015    0.931937    0.892277    0.853876    0.817041
  (:q)    0.32237     0.181562    0.148347    0.136867    0.129944
  (:z)    0.2         0.04        0.008       0.0016      0.00032</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_calibrated_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_calibrated_parameters(𝓂; values)
</code></pre><p>Returns the parameters (and optionally the values) which are determined by a calibration equation. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the calibrated parameters or <code>Vector{Pair{String, Float64}}</code> of the calibrated parameters and values if <code>values</code> is set to <code>true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_calibrated_parameters(RBC)
# output
1-element Vector{String}:
 &quot;δ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_calibration_equation_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_calibration_equation_parameters(𝓂)
</code></pre><p>Returns the parameters used in calibration equations which are not used in the equations of the model (see <code>capital_to_output</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_calibration_equation_parameters(RBC)
# output
1-element Vector{String}:
 &quot;capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_calibration_equations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_calibration_equations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_calibration_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_calibration_equations(𝓂)
</code></pre><p>Return the calibration equations declared in the <code>@parameters</code> block. Calibration equations are additional equations which are part of the non-stochastic steady state problem. The additional equation is matched with a calibated parameter which is part of the equations declared in the <code>@model</code> block and can be retrieved with: <code>get_calibrated_parameters</code></p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the output assumes the equations are equal to 0. As in, <code>k / (q * 4) - capital_to_output</code> implies <code>k / (q * 4) - capital_to_output = 0</code> and therefore: <code>k / (q * 4) = capital_to_output</code>.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the calibration equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_calibration_equations(RBC)
# output
1-element Vector{String}:
 &quot;k / (q * 4) - capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_conditional_forecast-Tuple{MacroModelling.ℳ, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}" href="#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.ℳ, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.get_conditional_forecast</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_conditional_forecast(
    𝓂,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    variables,
    conditions_in_levels,
    algorithm,
    levels,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the conditional forecast given restrictions on endogenous variables and shocks (optional). By default, the values represent absolute deviations from the relevant steady state (see <code>levels</code> for details). The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. A constrained minimisation problem is solved to find the combination of shocks with the smallest squared magnitude fulfilling the conditions.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as conditions. Note that you cannot condition variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which you specify conditions and all other variables are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing}</code>]: known values of shocks. This argument allows the user to include certain shock values. By entering restrictions on the shocks in this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the respective period. The input can have multiple formats, but for all types of entries the first dimension corresponds to shocks and the second dimension to the number of periods.  <code>shocks</code> can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. You can also use a <code>SparseMatrixCSC{Float64}</code> as input. In this case only non-zero elements are taken as certain shock values. Note that you cannot condition shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. You can use a <code>KeyedArray{Union{Nothing,Float64}}</code> where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, you can specify in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which you specify values and all other shocks are considered free. The same goes for the case when you use <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in deviations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(𝓂, shocks = :none, variables = :all, periods = 1)</code> returns a <code>KeyedArray</code> with all variables. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the non-stochastic steady state subtracted.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables  and shocks in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling
using SparseArrays, AxisKeys

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 2
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)
conditions[1,1] = .01
conditions[2,2] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

get_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables_and_shocks ∈ 9-element Vector{Symbol}
→   Periods ∈ 42-element UnitRange{Int64}
And data, 9×42 Matrix{Float64}:
                (1)            (2)           …  (41)            (42)
  (:A)            0.0313639      0.0134792         0.000221372     0.000199235
  (:Pi)           0.000780257    0.00020929       -0.000146071    -0.000140137
  (:R)            0.00117156     0.00031425       -0.000219325    -0.000210417
  (:c)            0.01           0.00600605        0.00213278      0.00203751
  (:k)            0.034584       0.0477482   …     0.0397631       0.0380482
  (:y)            0.0446375      0.02              0.00129544      0.001222
  (:z_delta)      0.00025        0.000225          3.69522e-6      3.3257e-6
  (:delta_eps)    0.05           0.0               0.0             0.0
  (:eps_z)        4.61234       -2.16887           0.0             0.0

# The same can be achieved with the other input formats:
# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# using SparseArrays
# conditions = spzeros(7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])
# shocks[1,1] = .05

# using SparseArrays
# shocks = spzeros(2,1)
# shocks[1,1] = .05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_conditional_variance_decomposition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_conditional_variance_decomposition(
    𝓂;
    periods,
    parameters,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the conditional variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>[1:20...,Inf]</code>, Type: <code>Union{Vector{Int},Vector{Float64},UnitRange{Int64}}</code>]: vector of periods for which to calculate the conditional variance decomposition. If the vector contains <code>Inf</code>, also the unconditional variance decomposition is calculated (same output as <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>get_variance_decomposition</code></a>).</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, shocks in columns, and periods as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_conditional_variance_decomposition(RBC_CME)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 7-element Vector{Symbol}
→   Shocks ∈ 2-element Vector{Symbol}
◪   Periods ∈ 21-element Vector{Float64}
And data, 7×2×21 Array{Float64, 3}:
[showing 3 of 21 slices]
[:, :, 1] ~ (:, :, 1.0):
              (:delta_eps)  (:eps_z)
  (:A)         0.0           1.0
  (:Pi)        0.00158668    0.998413
  (:R)         0.00158668    0.998413
  (:c)         0.0277348     0.972265
  (:k)         0.00869568    0.991304
  (:y)         0.0           1.0
  (:z_delta)   1.0           0.0

[:, :, 11] ~ (:, :, 11.0):
              (:delta_eps)  (:eps_z)
  (:A)         5.88653e-32   1.0
  (:Pi)        0.0245641     0.975436
  (:R)         0.0245641     0.975436
  (:c)         0.0175249     0.982475
  (:k)         0.00869568    0.991304
  (:y)         7.63511e-5    0.999924
  (:z_delta)   1.0           0.0

[:, :, 21] ~ (:, :, Inf):
              (:delta_eps)  (:eps_z)
  (:A)         9.6461e-31    1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2068">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_corr" href="#MacroModelling.get_corr"><code>MacroModelling.get_corr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.ℳ}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2490-L2492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_correlation-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_correlation-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_correlation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_correlation(
    𝓂;
    parameters,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the correlations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows and columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_correlation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   𝑉𝑎𝑟𝑖𝑎𝑏𝑙𝑒𝑠 ∈ 4-element Vector{Symbol}
And data, 4×4 Matrix{Float64}:
        (:c)       (:k)       (:q)       (:z)
  (:c)   1.0        0.999812   0.550168   0.314562
  (:k)   0.999812   1.0        0.533879   0.296104
  (:q)   0.550168   0.533879   1.0        0.965726
  (:z)   0.314562   0.296104   0.965726   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_cov" href="#MacroModelling.get_cov"><code>MacroModelling.get_cov</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3172-L3174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_covariance-Tuple" href="#MacroModelling.get_covariance-Tuple"><code>MacroModelling.get_covariance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false, derivatives = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3166-L3168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_dynamic_auxiliary_variables-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_dynamic_auxiliary_variables-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_dynamic_auxiliary_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dynamic_auxiliary_variables(𝓂)
</code></pre><p>Returns the auxiliary variables, without timing subscripts, part of the augmented system of equations describing the model dynamics. Augmented means that, in case of variables with leads or lags larger than 1, or exogenous shocks with leads or lags, the system is augemented by auxiliary variables containing variables or shocks in lead or lag. Because the original equations included variables with leads or lags certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxiliary variable is created for <code>c/q</code>).</p><p>See <code>get_dynamic_equations</code> for more details on the auxiliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the auxiliary parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_dynamic_auxiliary_variables(RBC)
# output
3-element Vector{String}:
 &quot;kᴸ⁽⁻²⁾&quot;
 &quot;kᴸ⁽⁻³⁾&quot;
 &quot;kᴸ⁽⁻¹⁾&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_dynamic_equations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_dynamic_equations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_dynamic_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dynamic_equations(𝓂)
</code></pre><p>Return the augmented system of equations describing the model dynamics. Augmented means that, in case of variables with leads or lags larger than 1, or exogenous shocks with leads or lags, the system is augemented by auxiliary equations containing variables in lead or lag. The augmented system features only variables which are in the present <code>[0]</code>, future <code>[1]</code>, or past <code>[-1]</code>. For example, <code>Δk_4q[0] = log(k[0]) - log(k[-3])</code> contains <code>k[-3]</code>. By introducing 2 auxiliary variables (<code>kᴸ⁽⁻¹⁾</code> and <code>kᴸ⁽⁻²⁾</code> with <code>ᴸ</code> being the lead/lag operator) and augmenting the system (<code>kᴸ⁽⁻²⁾[0] = kᴸ⁽⁻¹⁾[-1]</code> and <code>kᴸ⁽⁻¹⁾[0] = k[-1]</code>) we can ensure that the timing is smaller than 1 in absolute terms: <code>Δk_4q[0] - (log(k[0]) - log(kᴸ⁽⁻²⁾[-1]))</code>.</p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the output assumes the equations are equal to 0. As in, <code>kᴸ⁽⁻¹⁾[0] - k[-1]</code> implies <code>kᴸ⁽⁻¹⁾[0] - k[-1] = 0</code> and therefore: <code>kᴸ⁽⁻¹⁾[0] = k[-1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the dynamic model equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_dynamic_equations(RBC)
# output
12-element Vector{String}:
 &quot;1 / c[0] - (β / c[1]) * (α * ex&quot; ⋯ 25 bytes ⋯ &quot; - 1) + (1 - exp(z{δ}[1]) * δ))&quot;
 &quot;(c[0] + k[0]) - ((1 - exp(z{δ}[0]) * δ) * k[-1] + q[0])&quot;
 &quot;q[0] - exp(z{TFP}[0]) * k[-1] ^ α&quot;
 &quot;eps_news{TFP}[0] - eps_news{TFP}[x]&quot;
 &quot;z{TFP}[0] - (ρ{TFP} * z{TFP}[-1] + σ{TFP} * (eps{TFP}[x] + eps_news{TFP}[-1]))&quot;
 &quot;eps_news{δ}[0] - eps_news{δ}[x]&quot;
 &quot;z{δ}[0] - (ρ{δ} * z{δ}[-1] + σ{δ} * (eps{δ}[x] + eps_news{δ}[-1]))&quot;
 &quot;Δc_share[0] - (log(c[0] / q[0]) - log(c[-1] / q[-1]))&quot;
 &quot;kᴸ⁽⁻³⁾[0] - kᴸ⁽⁻²⁾[-1]&quot;
 &quot;kᴸ⁽⁻²⁾[0] - kᴸ⁽⁻¹⁾[-1]&quot;
 &quot;kᴸ⁽⁻¹⁾[0] - k[-1]&quot;
 &quot;Δk_4q[0] - (log(k[0]) - log(kᴸ⁽⁻³⁾[-1]))&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_equations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_equations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_equations(𝓂)
</code></pre><p>Return the equations of the model. In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parsed equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_equations(RBC)
# output
7-element Vector{String}:
 &quot;1 / c[0] = (β / c[1]) * (α * ex&quot; ⋯ 25 bytes ⋯ &quot; - 1) + (1 - exp(z{δ}[1]) * δ))&quot;
 &quot;c[0] + k[0] = (1 - exp(z{δ}[0]) * δ) * k[-1] + q[0]&quot;
 &quot;q[0] = exp(z{TFP}[0]) * k[-1] ^ α&quot;
 &quot;z{TFP}[0] = ρ{TFP} * z{TFP}[-1]&quot; ⋯ 18 bytes ⋯ &quot;TFP}[x] + eps_news{TFP}[x - 1])&quot;
 &quot;z{δ}[0] = ρ{δ} * z{δ}[-1] + σ{δ} * (eps{δ}[x] + eps_news{δ}[x - 1])&quot;
 &quot;Δc_share[0] = log(c[0] / q[0]) - log(c[-1] / q[-1])&quot;
 &quot;Δk_4q[0] = log(k[0]) - log(k[-4])&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_shocks-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_shocks-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_shocks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_estimated_shocks(
    𝓂,
    data;
    parameters,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the estimated shocks based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the variables, and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Only works for the Kalman filter. The inversion filter only returns filtered shocks/variables.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with shocks in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

simulation = simulate(RBC)

get_estimated_shocks(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Shocks ∈ 1-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
And data, 1×40 Matrix{Float64}:
               (1)          (2)         (3)         (4)         …  (37)         (38)        (39)         (40)
  (:eps_z₍ₓ₎)    0.0603617    0.614652   -0.519048    0.711454       -0.873774     1.27918    -0.929701    -0.2255</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variable_standard_deviations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_estimated_variable_standard_deviations(
    𝓂,
    data;
    parameters,
    data_in_levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the standard deviations of the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) estimates of the model variables based on the provided data and first order solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Only works for the Kalman filter. The inversion filter only returns filtered shocks/variables.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with standard deviations in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

simulation = simulate(RBC)

get_estimated_variable_standard_deviations(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Standard_deviations ∈ 4-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
And data, 4×40 Matrix{Float64}:
        (1)           (2)            (3)            (4)            …  (38)            (39)            (40)
  (:c)    1.23202e-9    1.84069e-10    8.23181e-11    8.23181e-11        8.23181e-11     8.23181e-11     0.0
  (:k)    0.00509299    0.000382934    2.87922e-5     2.16484e-6         1.6131e-9       9.31323e-10     1.47255e-9
  (:q)    0.0612887     0.0046082      0.000346483    2.60515e-5         1.31709e-9      1.31709e-9      9.31323e-10
  (:z)    0.00961766    0.000723136    5.43714e-5     4.0881e-6          3.08006e-10     3.29272e-10     2.32831e-10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_estimated_variables-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}" href="#MacroModelling.get_estimated_variables-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_estimated_variables(
    𝓂,
    data;
    parameters,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the estimated variables (in levels by default, see <code>levels</code> keyword argument) based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the variables, and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Only works for the Kalman filter. The inversion filter only returns filtered shocks/variables.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

simulation = simulate(RBC)

get_estimated_variables(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
And data, 4×40 Matrix{Float64}:
        (1)           (2)           (3)           (4)          …  (37)          (38)            (39)           (40)
  (:c)    5.92901       5.92797       5.92847       5.92048          5.95845       5.95697         5.95686        5.96173
  (:k)   47.3185       47.3087       47.3125       47.2392          47.6034       47.5969         47.5954        47.6402
  (:q)    6.87159       6.86452       6.87844       6.79352          7.00476       6.9026          6.90727        6.95841
  (:z)   -0.00109471   -0.00208056    4.43613e-5   -0.0123318        0.0162992     0.000445065     0.00119089     0.00863586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_fevd" href="#MacroModelling.get_fevd"><code>MacroModelling.get_fevd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2233-L2235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_first_order_solution-Tuple" href="#MacroModelling.get_first_order_solution-Tuple"><code>MacroModelling.get_first_order_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>get_solution</code></a> with <code>algorithm = :first_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1880-L1882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_forecast_error_variance_decomposition" href="#MacroModelling.get_forecast_error_variance_decomposition"><code>MacroModelling.get_forecast_error_variance_decomposition</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2239-L2241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_girf-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_girf-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_girf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a> with <code>generalised_irf = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1429-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irf-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_irf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_irf(
    𝓂;
    periods,
    algorithm,
    parameters,
    variables,
    shocks,
    negative_shock,
    generalised_irf,
    initial_state,
    levels,
    shock_size,
    ignore_obc,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return impulse response functions (IRFs) of the model. By default, the values represent absolute deviations from the relevant steady state (see <code>levels</code> for details). The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions.</p><p>If the model contains occasionally binding constraints and <code>ignore_obc = false</code> they are enforced using shocks.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>:all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>:all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate IRFs for a negative shock.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear (higher order perturbation) solutions only. Reference steady state for deviations is the stochastic steady state. <code>initial_state</code> has no effect on generalised IRFs. Occasionally binding constraint are not respected for generalised IRF.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). In this case the initial state must be given in deviations from the non-stochastic steady state. In all other cases the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(𝓂, shocks = :none, variables = :all, periods = 1)</code> returns a <code>KeyedArray</code> with all variables. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>shock_size</code> [Default: <code>1</code>, Type: <code>Real</code>]: affects the size of shocks as long as they are not set to <code>:none</code>.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, periods in columns, and shocks as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_irf(RBC)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
◪   Shocks ∈ 1-element Vector{Symbol}
And data, 4×40×1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :eps_z):
        (1)           (2)           …  (39)            (40)
  (:c)    0.00674687    0.00729773        0.00146962      0.00140619
  (:k)    0.0620937     0.0718322         0.0146789       0.0140453
  (:q)    0.0688406     0.0182781         0.00111425      0.00106615
  (:z)    0.01          0.002             2.74878e-29     5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1077">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irf-Union{Tuple{S}, Tuple{MacroModelling.ℳ, Vector{S}}} where S&lt;:Real" href="#MacroModelling.get_irf-Union{Tuple{S}, Tuple{MacroModelling.ℳ, Vector{S}}} where S&lt;:Real"><code>MacroModelling.get_irf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_irf(
    𝓂,
    parameters;
    periods,
    variables,
    shocks,
    negative_shock,
    initial_state,
    levels,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm
)
</code></pre><p>Return impulse response functions (IRFs) of the model. Function to use when differentiating IRFs with respect to parameters.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameters</code> [Type: <code>Vector</code>]: Parameter values in alphabetical order (sorted by parameter name).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>:all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>:all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate IRFs for a negative shock.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: The initial state defines the starting point for the model (in levels, not deviations). The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(𝓂, shocks = :none, variables = :all, periods = 1)</code> returns a <code>KeyedArray</code> with all variables. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{&lt;:AbstractFloat, 3}</code> with variables in rows, periods in columns, and shocks as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_irf(RBC, RBC.parameter_values)
# output
4×40×1 Array{Float64, 3}:
[:, :, 1] =
 0.00674687  0.00729773  0.00715114  0.00687615  …  0.00146962   0.00140619
 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453
 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615
 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L910">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_irfs" href="#MacroModelling.get_irfs"><code>MacroModelling.get_irfs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1389-L1391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_jump_variables-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_jump_variables-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_jump_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_jump_variables(𝓂)
</code></pre><p>Returns the jump variables of the model. Jump variables occur in the future and not in the past or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the jump variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_jump_variables(RBC)
# output
3-element Vector{String}:
 &quot;c&quot;
 &quot;z{TFP}&quot;
 &quot;z{δ}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L821">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_loglikelihood-Union{Tuple{U}, Tuple{S}, Tuple{MacroModelling.ℳ, KeyedArray{Float64}, Vector{S}}} where {S&lt;:Real, U&lt;:AbstractFloat}" href="#MacroModelling.get_loglikelihood-Union{Tuple{U}, Tuple{S}, Tuple{MacroModelling.ℳ, KeyedArray{Float64}, Vector{S}}} where {S&lt;:Real, U&lt;:AbstractFloat}"><code>MacroModelling.get_loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_loglikelihood(
    𝓂,
    data,
    parameter_values;
    algorithm,
    filter,
    on_failure_loglikelihood,
    warmup_iterations,
    presample_periods,
    initial_covariance,
    filter_algorithm,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm,
    sylvester_algorithm,
    verbose
)
</code></pre><p>Return the loglikelihood of the model given the data and parameters provided. The loglikelihood is either calculated based on the inversion or the Kalman filter (depending on the <code>filter</code> keyword argument). In case of a nonlinear solution algorithm the inversion filter will be used. The data must be provided as a <code>KeyedArray{Float64}</code> with the names of the variables to be matched in rows and the periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</p><p>This function is differentiable (so far for the Kalman filter only) and can be used in gradient based sampling or optimisation.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the variables, and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>presample_periods</code> [Default: <code>0</code>, Type: <code>Int</code>]: periods at the beginning of the data for which the loglikelihood is discarded.</li><li><code>initial_covariance</code> [Default: <code>:theoretical</code>, Type: <code>Symbol</code>]: defines the method to initialise the Kalman filters covariance matrix. It can be initialised with the theoretical long run values (option <code>:theoretical</code>) or large values (10.0) along the diagonal (option <code>:diagonal</code>).</li><li><code>on_failure_loglikelihood</code> [Default: <code>-Inf</code>, Type: <code>AbstractFloat</code>]: value to return if the loglikelihood calculation fails. Setting this to a finite value can avoid errors in codes that rely on finite loglikelihood values, such as e.g. slice samplers (in Pigeons.jl).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>&lt;:AbstractFloat</code> loglikelihood </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

simulated_data = simulate(RBC)

get_loglikelihood(RBC, simulated_data([:k], :, :simulate), RBC.parameter_values)
# output
58.24780188977981</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_mean-Tuple" href="#MacroModelling.get_mean-Tuple"><code>MacroModelling.get_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>mean = true</code>, and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false, covariance = false</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3184-L3186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_moments-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_moments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_moments(
    𝓂;
    parameters,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    variables,
    derivatives,
    parameter_derivatives,
    algorithm,
    silent,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the first and second moments of endogenous variables using the first, pruned second, or pruned third order perturbation solution. By default returns: non-stochastic steady state (NSSS), and standard deviations, but can optionally return variances, and covariance matrix. Derivatives of the moments (except for covariance) can also be provided by setting <code>derivatives</code> to <code>true</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>non_stochastic_steady_state</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return SS of endogenous variables</li><li><code>mean</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return mean of endogenous variables (the mean for the linearised solutoin is the NSSS)</li><li><code>standard_deviation</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return standard deviation of endogenous variables</li><li><code>variance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return variance of endogenous variables</li><li><code>covariance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return covariance matrix of endogenous variables</li><li><code>variables</code> [Default: <code>:all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Symbol,KeyedArray}</code> containing the selected moments. All moments have variables as rows and the moment as the first column followed by partial derivatives wrt parameters. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

moments = get_moments(RBC);

moments[:non_stochastic_steady_state]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:ρ)     (:δ)      (:α)       (:β)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre><pre><code class="language-julia hljs">moments[:standard_deviation]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Standard_deviation_and_∂standard_deviation∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Standard_deviation)  (:std_z)  …  (:δ)       (:α)       (:β)
  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789
  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323
  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08
  (:z)   0.0102062              1.02062      0.0        0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_non_stochastic_steady_state-Tuple" href="#MacroModelling.get_non_stochastic_steady_state-Tuple"><code>MacroModelling.get_non_stochastic_steady_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> with <code>stochastic = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1667-L1669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.ℳ, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}" href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.ℳ, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>MacroModelling.get_non_stochastic_steady_state_residuals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_non_stochastic_steady_state_residuals(
    𝓂,
    values;
    parameters,
    tol,
    verbose
)
</code></pre><p>Calculate the residuals of the non-stochastic steady state equations of the model for a given set of values. Values not provided, will be filled with the non-stochastic steady state values corresponding to the current parameters.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>values</code> [Type: <code>Union{Vector{Float64}, Dict{Symbol, Float64}, Dict{String, Float64}, KeyedArray{Float64, 1}}</code>]: A Vector, Dict, or KeyedArray containing the values of the variables and calibrated parameters in the non-stochastic steady state equations (including calibration equations). The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) containing the absolute values of the residuals of the non-stochastic steady state equations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    k[ss] / q[ss] = 2.5 | α
    β = 0.95
end

steady_state = SS(RBC, derivatives = false)

get_non_stochastic_steady_state_residuals(RBC, steady_state)
# output
1-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Equation ∈ 5-element Vector{Symbol}
And data, 5-element Vector{Float64}:
 (:Equation₁)             0.0
 (:Equation₂)             0.0
 (:Equation₃)             0.0
 (:Equation₄)             0.0
 (:CalibrationEquation₁)  0.0

get_non_stochastic_steady_state_residuals(RBC, [1.1641597, 3.0635781, 1.2254312, 0.0, 0.18157895])
# output
1-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Equation ∈ 5-element Vector{Symbol}
And data, 5-element Vector{Float64}:
 (:Equation₁)             2.7360991250446887e-10
 (:Equation₂)             6.199999980083248e-8
 (:Equation₃)             2.7897102183871425e-8
 (:Equation₄)             0.0
 (:CalibrationEquation₁)  8.160392850342646e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_nonnegativity_auxiliary_variables-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_nonnegativity_auxiliary_variables-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_nonnegativity_auxiliary_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nonnegativity_auxiliary_variables(𝓂)
</code></pre><p>Returns the auxiliary variables, without timing subscripts, added to the non-stochastic steady state problem because certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxiliary variable is created for <code>c/q</code>).</p><p>See <code>get_steady_state_equations</code> for more details on the auxiliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the auxiliary parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_nonnegativity_auxiliary_variables(RBC)
# output
2-element Vector{String}:
 &quot;➕₁&quot;
 &quot;➕₂&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L610">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_parameters-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_parameters(𝓂; values)
</code></pre><p>Returns the parameters (and optionally the values) which have an impact on the model dynamics but do not depend on other parameters and are not determined by calibration equations. </p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>σ</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters or <code>Vector{Pair{String, Float64}}</code> of parameters and values if <code>values</code> is set to <code>true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_parameters(RBC)
# output
7-element Vector{String}:
 &quot;σ{TFP}&quot;
 &quot;σ{δ}&quot;
 &quot;ρ{TFP}&quot;
 &quot;ρ{δ}&quot;
 &quot;capital_to_output&quot;
 &quot;alpha&quot;
 &quot;β&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_parameters_defined_by_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_parameters_defined_by_parameters(𝓂)
</code></pre><p>Returns the parameters which are defined by other parameters which are not necessarily used in the equations of the model (see <code>α</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_parameters_defined_by_parameters(RBC)
# output
1-element Vector{String}:
 &quot;α&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_parameters_defining_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_parameters_defining_parameters(𝓂)
</code></pre><p>Returns the parameters which define other parameters in the <code>@parameters</code> block which are not necessarily used in the equations of the model (see <code>alpha</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_parameters_defining_parameters(RBC)
# output
1-element Vector{String}:
 &quot;alpha&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_parameters_in_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_parameters_in_equations(𝓂)
</code></pre><p>Returns the parameters contained in the model equations. Note that these parameters might be determined by other parameters or calibration equations defined in the <code>@parameters</code> block.</p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>σ</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_parameters_in_equations(RBC)
# output
7-element Vector{String}:
 &quot;α&quot;
 &quot;β&quot;
 &quot;δ&quot;
 &quot;ρ{TFP}&quot;
 &quot;ρ{δ}&quot;
 &quot;σ{TFP}&quot;
 &quot;σ{δ}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_perturbation_solution-Tuple" href="#MacroModelling.get_perturbation_solution-Tuple"><code>MacroModelling.get_perturbation_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1895-L1897">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_residuals" href="#MacroModelling.get_residuals"><code>MacroModelling.get_residuals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.ℳ, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>get_non_stochastic_steady_state_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3680-L3682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_second_order_solution-Tuple" href="#MacroModelling.get_second_order_solution-Tuple"><code>MacroModelling.get_second_order_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>get_solution</code></a> with <code>algorithm = :second_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1885-L1887">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_shock_decomposition-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}" href="#MacroModelling.get_shock_decomposition-Tuple{MacroModelling.ℳ, KeyedArray{Float64}}"><code>MacroModelling.get_shock_decomposition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_shock_decomposition(
    𝓂,
    data;
    parameters,
    filter,
    algorithm,
    data_in_levels,
    warmup_iterations,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the shock decomposition in absolute deviations from the relevant steady state. The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. The deviations are based on the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) or inversion filter using the provided data and solution of the model. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>. </p><p>In case of pruned second and pruned third order perturbation algorithms the decomposition additionally contains a term <code>Nonlinearities</code>. This term represents the nonlinear interaction between the states in the periods after the shocks arrived and in the case of pruned third order, the interaction between (pruned second order) states and contemporaneous shocks.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and time in columns. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>filter</code> [Default: <code>:kalman</code>, Type: <code>Symbol</code>]: filter used to compute the variables, and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected, the inversion filter is used.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Only works for the Kalman filter. The inversion filter only returns filtered shocks/variables.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, shocks in columns, and periods as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

simulation = simulate(RBC)

get_shock_decomposition(RBC,simulation([:c],:,:simulate))
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Shocks ∈ 2-element Vector{Symbol}
◪   Periods ∈ 40-element UnitRange{Int64}
And data, 4×2×40 Array{Float64, 3}:
[showing 3 of 40 slices]
[:, :, 1] ~ (:, :, 1):
        (:eps_z₍ₓ₎)   (:Initial_values)
  (:c)   0.000407252  -0.00104779
  (:k)   0.00374808   -0.0104645
  (:q)   0.00415533   -0.000807161
  (:z)   0.000603617  -1.99957e-6

[:, :, 21] ~ (:, :, 21):
        (:eps_z₍ₓ₎)  (:Initial_values)
  (:c)   0.026511    -0.000433619
  (:k)   0.25684     -0.00433108
  (:q)   0.115858    -0.000328764
  (:z)   0.0150266    0.0

[:, :, 40] ~ (:, :, 40):
        (:eps_z₍ₓ₎)  (:Initial_values)
  (:c)   0.0437976   -0.000187505
  (:k)   0.4394      -0.00187284
  (:q)   0.00985518  -0.000142164
  (:z)  -0.00366442   8.67362e-19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_shocks-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_shocks-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_shocks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_shocks(𝓂)
</code></pre><p>Returns the exogenous shocks.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>eps</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the exogenous shocks.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_shocks(RBC)
# output
4-element Vector{String}:
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{δ}&quot;
 &quot;eps{TFP}&quot;
 &quot;eps{δ}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_simulation-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_simulation-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_simulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1419-L1421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_simulations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_simulations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_simulations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1424-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_solution-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_solution(
    𝓂;
    parameters,
    algorithm,
    silent,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the solution of the model. In the linear case it returns the non-stochastic steady state (NSSS) followed by the linearised solution of the model. In the nonlinear case (higher order perturbation) the function returns a multidimensional array with the endogenous variables as the second dimension and the state variables, shocks, and perturbation parameter (:Volatility) as the other dimensions.</p><p>The values of the output represent the NSSS in the case of a linear solution and below it the effect that deviations from the NSSS of the respective past states, shocks, and perturbation parameter have (perturbation parameter = 1) on the present value (NSSS deviation) of the model variables.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with the endogenous variables including the auxiliary endogenous and exogenous variables (due to leads and lags &gt; 1) as columns. The rows and other dimensions (depending on the chosen perturbation order) include the NSSS for the linear case only, followed by the states, and exogenous shocks. Subscripts following variable names indicate the timing (e.g. <code>variable₍₋₁₎</code>  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. <code>variableᴸ⁽²⁾</code> indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_solution(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Steady_state__States__Shocks ∈ 4-element Vector{Symbol}
→   Variables ∈ 4-element Vector{Symbol}
And data, 4×4 adjoint(::Matrix{Float64}) with eltype Float64:
                   (:c)         (:k)        (:q)        (:z)
  (:Steady_state)   5.93625     47.3903      6.88406     0.0
  (:k₍₋₁₎)          0.0957964    0.956835    0.0726316  -0.0
  (:z₍₋₁₎)          0.134937     1.24187     1.37681     0.2
  (:eps_z₍ₓ₎)       0.00674687   0.0620937   0.0688406   0.01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1726">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_solution-Union{Tuple{S}, Tuple{MacroModelling.ℳ, Vector{S}}} where S&lt;:Real" href="#MacroModelling.get_solution-Union{Tuple{S}, Tuple{MacroModelling.ℳ, Vector{S}}} where S&lt;:Real"><code>MacroModelling.get_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_solution(
    𝓂,
    parameters;
    algorithm,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the components of the solution of the model: non-stochastic steady state (NSSS), and solution martrices corresponding to the order of the solution. Note that all returned objects have the variables in rows and the solution matrices have as columns the state variables followed by the perturbation/volatility parameter for higher order solution matrices and lastly the exogenous shocks. Higher order perturbation matrices are sparse and have the Kronecker product of the forementioned elements as columns. The last element, a Boolean indicates whether the solution is numerically accurate. Function to use when differentiating IRFs with respect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code> consisting of a <code>Vector</code> containing the NSSS, followed by a <code>Matrix</code> containing the first order solution matrix. In case of higher order solutions, <code>SparseMatrixCSC</code> represent the higher order solution matrices. The last element is a <code>Bool</code> indicating the correctness of the solution provided.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_solution(RBC, RBC.parameter_values)
# output
([5.936252888048724, 47.39025414828808, 6.884057971014486, 0.0], 
 [0.09579643002421227 0.1349373930517757 0.006746869652588215; 
  0.9568351489231555 1.241874201151121 0.06209371005755664; 
  0.07263157894736819 1.376811594202897 0.06884057971014486; 
  0.0 0.19999999999999998 0.01], true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1903">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_ss" href="#MacroModelling.get_ss"><code>MacroModelling.get_ss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1713-L1715">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_standard_deviation-Tuple" href="#MacroModelling.get_standard_deviation-Tuple"><code>MacroModelling.get_standard_deviation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3138-L3140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_state_variables-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_state_variables-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_state_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_state_variables(𝓂)
</code></pre><p>Returns the state variables of the model. State variables occur in the past and not in the future or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the state variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_state_variables(RBC)
# output
10-element Vector{String}:
 &quot;c&quot;
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{δ}&quot;
 &quot;k&quot;
 &quot;kᴸ⁽⁻²⁾&quot;
 &quot;kᴸ⁽⁻³⁾&quot;
 &quot;kᴸ⁽⁻¹⁾&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{δ}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L763">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_statistics-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T" href="#MacroModelling.get_statistics-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MacroModelling.get_statistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_statistics(
    𝓂,
    parameter_values;
    parameters,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    autocorrelation,
    autocorrelation_periods,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the first and second moments of endogenous variables using either the linearised solution or the pruned second or pruned third order perturbation solution. By default returns a <code>Dict</code> with: non-stochastic steady state (NSSS), and standard deviations, but can also return variances, and covariance matrix. Values are returned in the order given for the specific moment. Function to use when differentiating model moments with respect to parameters.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values. If <code>parameter_names</code> is not explicitly defined, <code>parameter_values</code> are assumed to correspond to the parameters and the order of the parameters declared in the <code>@parameters</code> block.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Type: <code>Vector{Symbol}</code>]: Corresponding names in the same order as <code>parameter_values</code>.</li><li><code>non_stochastic_steady_state</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the NSSS of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>mean</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the mean of selected variables (the mean for the linearised solution is the NSSS). Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>standard_deviation</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the standard deviation of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>variance</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the variance of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>covariance</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the covariance of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>autocorrelation</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the autocorrelation of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or &quot;y&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>, Type = <code>UnitRange{Int}</code>]: periods for which to return the autocorrelation of selected variables</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code> with the name of the statistics and the corresponding vectors (NSSS, mean, standard deviation, variance) or matrices (covariance, autocorrelation).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_statistics(RBC, RBC.parameter_values, parameters = RBC.parameters, standard_deviation = RBC.var)
# output
Dict{Symbol, AbstractArray{Float64}} with 1 entry:
  :standard_deviation =&gt; [0.0266642, 0.264677, 0.0739325, 0.0102062]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_std" href="#MacroModelling.get_std"><code>MacroModelling.get_std</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3144-L3146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_stdev" href="#MacroModelling.get_stdev"><code>MacroModelling.get_stdev</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3149-L3151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_steady_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_steady_state(
    𝓂;
    parameters,
    derivatives,
    stochastic,
    algorithm,
    parameter_derivatives,
    return_variables_only,
    verbose,
    silent,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the (non-stochastic) steady state, calibrated parameters, and derivatives with respect to model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>stochastic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return stochastic steady state using second order perturbation if no other higher order perturbation algorithm is provided in <code>algorithm</code>.</li><li><code>return_variables_only</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return only variables and not calibrated parameters.</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: function of size of problem, with smaller problems: <code>:doubling</code>, and larger problems: <code>:bicgstab</code>, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can be up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows. The columns show the (non-stochastic) steady state and parameters for which derivatives are taken. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

get_steady_state(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}
→   Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:ρ)     (:δ)      (:α)       (:β)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_steady_state_equations-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_steady_state_equations-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_steady_state_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_steady_state_equations(𝓂)
</code></pre><p>Return the non-stochastic steady state (NSSS) equations of the model. The difference to the equations as they were written in the <code>@model</code> block is that exogenous shocks are set to <code>0</code>, time subscripts are eliminated (e.g. <code>c[-1]</code> becomes <code>c</code>), trivial simplifications are carried out (e.g. <code>log(k) - log(k) = 0</code>), and auxiliary variables are added for expressions that cannot become negative. </p><p>Auxiliary variables facilitate the solution of the NSSS problem. The package substitutes expressions which cannot become negative with auxiliary variables and adds another equation to the system of equations determining the NSSS. For example, <code>log(c/q)</code> cannot be negative and <code>c/q</code> is substituted by an auxiliary variable <code>➕₁</code> and an additional equation is added: <code>➕₁ = c / q</code>.</p><p>Note that the output assumes the equations are equal to 0. As in, <code>-z{δ} * ρ{δ} + z{δ}</code> implies <code>-z{δ} * ρ{δ} + z{δ} = 0</code> and therefore: <code>z{δ} * ρ{δ} = z{δ}</code>.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the NSSS equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_steady_state_equations(RBC)
# output
9-element Vector{String}:
 &quot;(-β * ((k ^ (α - 1) * α * exp(z{TFP}) - δ * exp(z{δ})) + 1)) / c + 1 / c&quot;
 &quot;((c - k * (-δ * exp(z{δ}) + 1)) + k) - q&quot;
 &quot;-(k ^ α) * exp(z{TFP}) + q&quot;
 &quot;-z{TFP} * ρ{TFP} + z{TFP}&quot;
 &quot;-z{δ} * ρ{δ} + z{δ}&quot;
 &quot;➕₁ - c / q&quot;
 &quot;➕₂ - c / q&quot;
 &quot;(Δc_share - log(➕₁)) + log(➕₂)&quot;
 &quot;Δk_4q - 0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_stochastic_steady_state-Tuple" href="#MacroModelling.get_stochastic_steady_state-Tuple"><code>MacroModelling.get_stochastic_steady_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1673-L1675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_third_order_solution-Tuple" href="#MacroModelling.get_third_order_solution-Tuple"><code>MacroModelling.get_third_order_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>get_solution</code></a> with <code>algorithm = :third_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1890-L1892">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_var" href="#MacroModelling.get_var"><code>MacroModelling.get_var</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3126-L3128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_var_decomp" href="#MacroModelling.get_var_decomp"><code>MacroModelling.get_var_decomp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>get_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2381-L2383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variables-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_variables-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_variables(𝓂)
</code></pre><p>Returns the variables of the model without timing subscripts and not including auxiliary variables.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z{TFP}[1]) * k[0]^(α - 1) + (1 - exp(z{δ}[1]) * δ))
    c[0] + k[0] = (1 - exp(z{δ}[0])δ) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^α
    for shock in [TFP, δ]
        z{shock}[0] = ρ{shock} * z{shock}[-1] + σ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Δc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Δk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    σ = 0.01
    ρ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | δ
    alpha = .5
    α = alpha
    β = 0.95
end

get_variables(RBC)
# output
7-element Vector{String}:
 &quot;c&quot;
 &quot;k&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{δ}&quot;
 &quot;Δc_share&quot;
 &quot;Δk_4q&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/inspect.jl#L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variance-Tuple" href="#MacroModelling.get_variance-Tuple"><code>MacroModelling.get_variance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3120-L3122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.get_variance_decomposition-Tuple{MacroModelling.ℳ}" href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.ℳ}"><code>MacroModelling.get_variance_decomposition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_variance_decomposition(
    𝓂;
    parameters,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>:schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>:doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code></li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, and shocks in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_variance_decomposition(RBC_CME)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 7-element Vector{Symbol}
→   Shocks ∈ 2-element Vector{Symbol}
And data, 7×2 Matrix{Float64}:
              (:delta_eps)  (:eps_z)
  (:A)         9.78485e-31   1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L2253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.import_dynare" href="#MacroModelling.import_dynare"><code>MacroModelling.import_dynare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L127-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.import_model" href="#MacroModelling.import_model"><code>MacroModelling.import_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L122-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.simulate-Tuple{MacroModelling.ℳ}" href="#MacroModelling.simulate-Tuple{MacroModelling.ℳ}"><code>MacroModelling.simulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.ℳ}"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1414-L1416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.ss-Tuple" href="#MacroModelling.ss-Tuple"><code>MacroModelling.ss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1718-L1720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.sss-Tuple" href="#MacroModelling.sss-Tuple"><code>MacroModelling.sss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1691-L1693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.std" href="#MacroModelling.std"><code>MacroModelling.std</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3161-L3163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.stdev" href="#MacroModelling.stdev"><code>MacroModelling.stdev</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3155-L3157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.steady_state" href="#MacroModelling.steady_state"><code>MacroModelling.steady_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L1703-L1705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.translate_dynare_file" href="#MacroModelling.translate_dynare_file"><code>MacroModelling.translate_dynare_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L117-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.translate_mod_file-Tuple{AbstractString}" href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>MacroModelling.translate_mod_file</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_mod_file(path_to_mod_file)
</code></pre><p>Reads in a <code>dynare</code> .mod-file, adapts the syntax, tries to capture parameter definitions, and writes a julia file in the same folder containing the model equations and parameters in <code>MacroModelling.jl</code> syntax. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>dynare</code> to <code>MacroModelling.jl</code>. </p><p>The recommended workflow is to use this function to translate a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p>Note that this function copies the .mod-file to a temporary folder and executes it there. All references within that .mod-file are therefore not valid (because those filesare not copied) and must be made copied into the .mod-file.</p><p><strong>Arguments</strong></p><ul><li><code>path_to_mod_file</code> [Type: <code>AbstractString</code>]: path including filename of the .mod-file to be translated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.var" href="#MacroModelling.var"><code>MacroModelling.var</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.ℳ}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/get_functions.jl#L3132-L3134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_dynare_file" href="#MacroModelling.write_dynare_file"><code>MacroModelling.write_dynare_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L232-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}" href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>MacroModelling.write_mod_file</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_mod_file(m)
</code></pre><p>Writes a <code>dynare</code> .mod-file in the current working directory. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>MacroModelling.jl</code> to <code>dynare</code>. </p><p>The recommended workflow is to use this function to write a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_to_dynare" href="#MacroModelling.write_to_dynare"><code>MacroModelling.write_to_dynare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L242-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.write_to_dynare_file" href="#MacroModelling.write_to_dynare_file"><code>MacroModelling.write_to_dynare_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.ℳ}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/dynare.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.@model-Tuple{Any, Vararg{Any}}" href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@model</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parses the model equations and assigns them to an object.</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: name of the object to be created containing the model information.</li><li><code>ex</code>: equations</li></ul><p><strong>Optional arguments to be placed between <code>𝓂</code> and <code>ex</code></strong></p><ul><li><code>max_obc_horizon</code> [Default: <code>40</code>, Type: <code>Int</code>]: maximum length of anticipated shocks and corresponding unconditional forecast horizon over which the occasionally binding constraint is to be enforced. Increase this number if no solution is found to enforce the constraint.</li></ul><p>Variables must be defined with their time subscript in square brackets. Endogenous variables can have the following:</p><ul><li>present: <code>c[0]</code></li><li>non-stochastic steady state: <code>c[ss]</code> instead of <code>ss</code> any of the following is also a valid flag for the non-stochastic steady state: <code>ss</code>, <code>stst</code>, <code>steady</code>, <code>steadystate</code>, <code>steady_state</code>, and the parser is case-insensitive (<code>SS</code> or <code>sTst</code> will work as well).</li><li>past: <code>c[-1]</code> or any negative Integer: e.g. <code>c[-12]</code></li><li>future: <code>c[1]</code> or any positive Integer: e.g. <code>c[16]</code> or <code>c[+16]</code></li></ul><p>Signed integers are recognised and parsed as such.</p><p>Exogenous variables (shocks) can have the following:</p><ul><li>present: <code>eps_z[x]</code> instead of <code>x</code> any of the following is also a valid flag for exogenous variables: <code>ex</code>, <code>exo</code>, <code>exogenous</code>, and the parser is case-insensitive (<code>Ex</code> or <code>exoGenous</code> will work as well).</li><li>past: <code>eps_z[x-1]</code></li><li>future: <code>eps_z[x+1]</code></li></ul><p>Parameters enter the equations without square brackets.</p><p>If an equation contains a <code>max</code> or <code>min</code> operator, then the default dynamic (first order) solution of the model will enforce the occasionally binding constraint. You can choose to ignore it by setting <code>ignore_obc = true</code> in the relevant function calls.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Parameters and variables can be indexed using curly braces: e.g. <code>c{H}[0]</code>, <code>eps_z{F}[x]</code>, or <code>α{H}</code>.</p><p><code>for</code> loops can be used to write models programmatically. They can either be used to generate expressions where you iterate over the time index or the index in curly braces:</p><ul><li>generate equation with different indices in curly braces: <code>for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end</code></li><li>generate multiple equations with different indices in curly braces: <code>for co in [H, F] K{co}[0] = (1-delta{co}) * K{co}[-1] + S{co}[0] end</code></li><li>generate equation with different time indices: <code>Y_annual[0] = for lag in -3:0 Y[lag] end</code> or <code>R_annual[0] = for operator = :*, lag in -3:0 R[lag] end</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>. The macro creates the model <code>𝓂</code> in the calling scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/macros.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MacroModelling.@parameters-Tuple{Any, Vararg{Any}}" href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@parameters</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Adds parameter values and calibration equations to the previously defined model. Allows to provide an initial guess for the non-stochastic steady state (NSSS).</p><p><strong>Arguments</strong></p><ul><li><code>𝓂</code>: name of the object previously created containing the model information.</li><li><code>ex</code>: parameter, parameters values, and calibration equations</li></ul><p>Parameters can be defined in either of the following ways:</p><ul><li>plain number: <code>δ = 0.02</code></li><li>expression containing numbers: <code>δ = 1/50</code></li><li>expression containing other parameters: <code>δ = 2 * std_z</code> in this case it is irrelevant if <code>std_z</code> is defined before or after. The definitions including other parameters are treated as a system of equations and solved accordingly.</li><li>expressions containing a target parameter and an equations with endogenous variables in the non-stochastic steady state, and other parameters, or numbers: <code>k[ss] / (4 * q[ss]) = 1.5 | δ</code> or <code>α | 4 * q[ss] = δ * k[ss]</code> in this case the target parameter will be solved simultaneously with the non-stochastic steady state using the equation defined with it.</li></ul><p><strong>Optional arguments to be placed between <code>𝓂</code> and <code>ex</code></strong></p><ul><li><code>guess</code> [Type: <code>Dict{Symbol, &lt;:Real}, Dict{String, &lt;:Real}}</code>]: Guess for the non-stochastic steady state. The keys must be the variable (and calibrated parameters) names and the values the guesses. Missing values are filled with standard starting values.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print more information about how the non-stochastic steady state is solved</li><li><code>silent</code> [Default: <code>false</code>, Type: <code>Bool</code>]: do not print any information</li><li><code>symbolic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: try to solve the non-stochastic steady state symbolically and fall back to a numerical solution if not possible</li><li><code>perturbation_order</code> [Default: <code>1</code>, Type: <code>Int</code>]: take derivatives only up to the specified order at this stage. In case you want to work with higher order perturbation later on, respective derivatives will be taken at that stage.</li><li><code>simplify</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to eliminate redundant variables and simplify the non-stochastic steady state (NSSS) problem. Setting this to <code>false</code> can speed up the process, but might make it harder to find the NSSS. If the model does not parse at all (at step 1 or 2), setting this option to <code>false</code> might solve it.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC verbose = true begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

@model RBC_calibrated begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC_calibrated verbose = true guess = Dict(:k =&gt; 3) begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    k[ss] / q[ss] = 2.5 | α
    β = 0.95
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Variables and parameters indexed with curly braces can be either referenced specifically (e.g. <code>c{H}[ss]</code>) or generally (e.g. <code>alpha</code>). If they are referenced generally the parse assumes all instances (indices) are meant. For example, in a model where <code>alpha</code> has two indices <code>H</code> and <code>F</code>, the expression <code>alpha = 0.3</code> is interpreted as two expressions: <code>alpha{H} = 0.3</code> and <code>alpha{F} = 0.3</code>. The same goes for calibration equations.</p><p><strong>Returns</strong></p><ul><li><code>Nothing</code>. The macro assigns parameter values and calibration equations to <code>𝓂</code> in the calling scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/e7e92dcf6ec650bb82c31a6f470d5c47d775d1b4/src/macros.jl#L982">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how-to/obc/">« Occasionally binding constraints</a><a class="docs-footer-nextpage" href="../call_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 07:25">Monday 4 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
