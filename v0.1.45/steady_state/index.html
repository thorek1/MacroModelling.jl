<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Steady State · MacroModelling.jl</title><meta name="title" content="Steady State · MacroModelling.jl"/><meta property="og:title" content="Steady State · MacroModelling.jl"/><meta property="twitter:title" content="Steady State · MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../plotting/">Overview</a></li><li><a class="tocitem" href="../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../plot_conditional_forecast/">Conditional Forecasts</a></li><li><a class="tocitem" href="../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../plot_model_estimates/">Model Estimates</a></li></ul></li><li class="is-active"><a class="tocitem" href>Steady State</a><ul class="internal"><li><a class="tocitem" href="#Automatic-Steady-State-Solver"><span>Automatic Steady State Solver</span></a></li><li><a class="tocitem" href="#Custom-Steady-State-Functions"><span>Custom Steady State Functions</span></a></li><li><a class="tocitem" href="#When-to-Use-Custom-Steady-State-Functions"><span>When to Use Custom Steady State Functions</span></a></li><li><a class="tocitem" href="#Delayed-Parameter-Declaration"><span>Delayed Parameter Declaration</span></a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Steady State</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Steady State</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/steady_state.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Steady-State"><a class="docs-heading-anchor" href="#Steady-State">Steady State</a><a id="Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State" title="Permalink"></a></h1><p>The non stochastic steady state (NSSS) of a DSGE model is the equilibrium point where all variables remain constant over time (in the absence of shocks). Computing the NSSS is a crucial first step before solving the model using perturbation methods.</p><p><code>MacroModelling.jl</code> offers an automated way to solving for the NSSS, along with the flexibility to define custom steady state functions when needed.</p><h2 id="Automatic-Steady-State-Solver"><a class="docs-heading-anchor" href="#Automatic-Steady-State-Solver">Automatic Steady State Solver</a><a id="Automatic-Steady-State-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Steady-State-Solver" title="Permalink"></a></h2><p>The algorithm proceeds through several steps designed to maximize efficiency and robustness:</p><h3 id="Step-1:-Eliminate-Redundant-Variables"><a class="docs-heading-anchor" href="#Step-1:-Eliminate-Redundant-Variables">Step 1: Eliminate Redundant Variables</a><a id="Step-1:-Eliminate-Redundant-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Eliminate-Redundant-Variables" title="Permalink"></a></h3><p>The algorithm first identifies and eliminates redundant variables from the system. Variables that are necessary in dynamic equations but redundant in steady state are removed to simplify the problem (e.g. <code>c</code> is redundant in <code>1 / c = beta / c * k ^ alpha + (1 - delta)</code>).</p><h3 id="Step-2:-Partition-into-Independent-Blocks"><a class="docs-heading-anchor" href="#Step-2:-Partition-into-Independent-Blocks">Step 2: Partition into Independent Blocks</a><a id="Step-2:-Partition-into-Independent-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Partition-into-Independent-Blocks" title="Permalink"></a></h3><p>The reduced system is partitioned into independent blocks that can be solved separately. This block decomposition exploits the sparsity structure of the model equations, allowing smaller subproblems to be solved in sequence rather than tackling the full system at once.</p><h3 id="Step-3:-Attempt-Symbolic-Solution"><a class="docs-heading-anchor" href="#Step-3:-Attempt-Symbolic-Solution">Step 3: Attempt Symbolic Solution</a><a id="Step-3:-Attempt-Symbolic-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Attempt-Symbolic-Solution" title="Permalink"></a></h3><p>For each block, the algorithm attempts a full or partial symbolic solution using computer algebra (using <code>sympy</code>). When possible, closed-form solutions are obtained, which:</p><ul><li>Provide exact solutions</li><li>Enable faster computation</li></ul><h3 id="Step-4:-Create-Auxiliary-Variables-for-Domain-Constrained-Terms"><a class="docs-heading-anchor" href="#Step-4:-Create-Auxiliary-Variables-for-Domain-Constrained-Terms">Step 4: Create Auxiliary Variables for Domain-Constrained Terms</a><a id="Step-4:-Create-Auxiliary-Variables-for-Domain-Constrained-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Create-Auxiliary-Variables-for-Domain-Constrained-Terms" title="Permalink"></a></h3><p>For terms with domain constraints (e.g., <code>log(x+y)</code>, <code>x^y</code>), auxiliary variables are created to handle these constraints explicitly. This transformation helps numerical solvers to find solutions while ensuring that numerical solutions respect domain requirements.</p><h3 id="Step-5:-Custom-Nonlinear-Equations-Solver"><a class="docs-heading-anchor" href="#Step-5:-Custom-Nonlinear-Equations-Solver">Step 5: Custom Nonlinear Equations Solver</a><a id="Step-5:-Custom-Nonlinear-Equations-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Custom-Nonlinear-Equations-Solver" title="Permalink"></a></h3><p>For blocks that cannot be solved symbolically, a custom system of nonlinear equations solver is employed. This solver is a Levenberg-Marquardt (LM) type algorithm with line-search that includes:</p><ul><li><strong>Box constraints</strong>: Respect the domain constraints of variables as well as user defined bounds from the <code>@parameters</code> macro (e.g. <code>c &gt; 0</code>, <code>r &lt; 0.2</code>, or <code>1 &lt; π &lt; 1.1</code>). User defined bounds can be helpful to guide the solver toward plausible values.</li><li><strong>Domain transformation</strong>: A hyperbolic sine transformation is applied that transforms the geometry of the problem and increases the likelihood of finding a solution</li><li><strong>Adaptive failure recovery</strong>: Upon failure, the solver optimizes over the LM parameters and starting points to find a solution</li></ul><h3 id="Step-6:-Select-Optimal-Solver-Parameters"><a class="docs-heading-anchor" href="#Step-6:-Select-Optimal-Solver-Parameters">Step 6: Select Optimal Solver Parameters</a><a id="Step-6:-Select-Optimal-Solver-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Select-Optimal-Solver-Parameters" title="Permalink"></a></h3><p>The algorithm selects solver parameters and starting points that maximise speed for the specific model structure. This adaptive approach ensures efficient computation across diverse model specifications.</p><h3 id="Guiding-and-Validating-the-Internal-Solver"><a class="docs-heading-anchor" href="#Guiding-and-Validating-the-Internal-Solver">Guiding and Validating the Internal Solver</a><a id="Guiding-and-Validating-the-Internal-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Guiding-and-Validating-the-Internal-Solver" title="Permalink"></a></h3><p>Additional information can guide the automatic solver toward convergence and validate the result:</p><ul><li><p>Supply starting values via the <code>guess</code> argument of <code>@parameters</code>, e.g. <code>@parameters RBC guess = Dict(:k =&gt; 3.0, :c =&gt; 1.0) begin ... end</code>.</p></li><li><p>Add bounds directly in the <code>@parameters</code> block using inequalities (e.g. <code>c &gt; 0</code>, <code>r &lt; 0.2</code>, or <code>1 &lt; π &lt; 1.1</code>) to restrict the search space and steer the solver toward plausible values.</p></li><li><p>After solving, verify that the steady state satisfies all equations by calling <code>check_residuals</code>, for example:</p><pre><code class="language-julia hljs">ss = get_steady_state(RBC)
check_residuals(RBC, ss)</code></pre><p>which returns steady-state equation residuals in absolute value.</p></li></ul><h2 id="Custom-Steady-State-Functions"><a class="docs-heading-anchor" href="#Custom-Steady-State-Functions">Custom Steady State Functions</a><a id="Custom-Steady-State-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Steady-State-Functions" title="Permalink"></a></h2><p>For models where the internal solver fails, or when analytical solutions are available (often faster to compute), a custom steady state function can be provided. There are two primary ways to specify this:</p><h3 id="Method-1:-Via-the-@parameters-Macro"><a class="docs-heading-anchor" href="#Method-1:-Via-the-@parameters-Macro">Method 1: Via the <code>@parameters</code> Macro</a><a id="Method-1:-Via-the-@parameters-Macro-1"></a><a class="docs-heading-anchor-permalink" href="#Method-1:-Via-the-@parameters-Macro" title="Permalink"></a></h3><p>After defining the model one can specify a custom steady state function and pass it on to the <code>@parameters</code> macro. The function should accept a vector of parameter values and return a vector of variables followed by calibration parameters. The input and output needs to follow the correct ordering of parameters and variables. The order of the parameters can be obtained using <code>get_parameters(m)</code>, and the order of the output follows <code>get_variables(m)</code> and <code>get_calibrated_parameters(m)</code>. Practically, one can call the model and parameter macros without defining the custom steady state function, then get the order from the above functions calls and based on this order define the custom steady state function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MacroModelling</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Define the model
       @model RBC begin
           1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
           c[0] + k[0] = (1 - δ) * k[-1] + q[0]
           q[0] = exp(z[0]) * k[-1]^α
           z[0] = ρᶻ * z[-1] + σᶻ * ϵᶻ[x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Define a steady state function
       function my_ss(parameters)
           # parameters is ordered as: m.parameters (e.g., [:α, :β, :δ, :ρᶻ, :σᶻ])
           α, β, δ, ρᶻ, σᶻ = parameters
       
           # Compute steady state values
           k_ss = ((1/β - 1 + δ) / α)^(1/(α-1))
           q_ss = k_ss^α
           c_ss = q_ss - δ*k_ss
           z_ss = 0.0
       
           # Return values in variable order: m.var (e.g., [:c, :k, :q, :z])
           return [c_ss, k_ss, q_ss, z_ss]
       end</code><code class="nohighlight hljs ansi" style="display:block;">my_ss (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters RBC steady_state_function = my_ss begin
           σᶻ= 0.01
           ρᶻ= 0.2
           δ = 0.02
           α = 0.5
           β = 0.95
       end</code><code class="nohighlight hljs ansi" style="display:block;">Take symbolic derivatives up to first order:				0.025 seconds
Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5</code></pre><p>The model can now be used as usual, and the custom steady state function will be called automatically:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ss = get_steady_state(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: Could not find non-stochastic steady state. Solution error: 10.395147630349634 &gt; 1.0e-12
└ @ MacroModelling ~/work/MacroModelling.jl/MacroModelling.jl/src/get_functions.jl:1518
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}</span>
And data, <span class="sgr1">4×6 Matrix{Float64}</span>:
        <span class="sgr35">(:Steady_state)</span>  <span class="sgr35">(:σᶻ)</span>  <span class="sgr35">(:ρᶻ)</span>  <span class="sgr35">(:δ)</span>  <span class="sgr35">(:α)</span>  <span class="sgr35">(:β)</span>
  <span class="sgr35">(:c)</span>   0.941181         0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:k)</span>   0.00234136       0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:q)</span>   0.941228         0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:z)</span>   0.0              0.0    0.0    0.0   0.0   0.0</code></pre><p>One can also use a non-allocating version of the steady state function that modifies a pre-allocated output vector in place. This function should accept two arguments: an output vector and a vector of parameter values. The output vector should be modified in place to contain the steady state values.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Define the model
       @model RBC begin
           1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
           c[0] + k[0] = (1 - δ) * k[-1] + q[0]
           q[0] = exp(z[0]) * k[-1]^α
           z[0] = ρᶻ * z[-1] + σᶻ * ϵᶻ[x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Define a steady state function
       function my_ss_inplace!(ss, parameters)
           # parameters is ordered as: m.parameters (e.g., [:α, :β, :δ, :ρᶻ, :σᶻ])
           α, β, δ, ρᶻ, σᶻ = parameters
           # Compute steady state values
           k_ss = ((1/β - 1 + δ) / α)^(1/(α-1))
           q_ss = k_ss^α
           c_ss = q_ss - δ*k_ss
           z_ss = 0.0
       
           ss[1] = c_ss
           ss[2] = k_ss
           ss[3] = q_ss
           ss[4] = z_ss
       end</code><code class="nohighlight hljs ansi" style="display:block;">my_ss_inplace! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters RBC steady_state_function = my_ss_inplace! begin
           σᶻ= 0.01
           ρᶻ= 0.2
           δ = 0.02
           α = 0.5
           β = 0.95
       end</code><code class="nohighlight hljs ansi" style="display:block;">Take symbolic derivatives up to first order:				0.025 seconds
Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_SS(RBC)  # uses the in-place version</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: Could not find non-stochastic steady state. Solution error: 10.395147630349634 &gt; 1.0e-12
└ @ MacroModelling ~/work/MacroModelling.jl/MacroModelling.jl/src/get_functions.jl:1518
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}</span>
And data, <span class="sgr1">4×6 Matrix{Float64}</span>:
        <span class="sgr35">(:Steady_state)</span>  <span class="sgr35">(:σᶻ)</span>  <span class="sgr35">(:ρᶻ)</span>  <span class="sgr35">(:δ)</span>  <span class="sgr35">(:α)</span>  <span class="sgr35">(:β)</span>
  <span class="sgr35">(:c)</span>   0.941181         0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:k)</span>   0.00234136       0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:q)</span>   0.941228         0.0    0.0    0.0   0.0   0.0
  <span class="sgr35">(:z)</span>   0.0              0.0    0.0    0.0   0.0   0.0</code></pre><h3 id="Method-2:-Via-Function-Arguments"><a class="docs-heading-anchor" href="#Method-2:-Via-Function-Arguments">Method 2: Via Function Arguments</a><a id="Method-2:-Via-Function-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Method-2:-Via-Function-Arguments" title="Permalink"></a></h3><p>All functions that accept a <code>parameters</code> argument also accept a <code>steady_state_function</code> argument:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Pass the steady state function to specific function calls
       get_irf(RBC, steady_state_function = my_ss)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: AssertionError: Could not find non-stochastic steady state.</code></pre><p>To revert to the internal solver and clear any previously set custom function on the model, pass <code>nothing</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(RBC, steady_state_function = nothing)</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	0.059 seconds
Set up non-stochastic steady state problem:				0.176 seconds
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Standard_deviation_and_∂standard_deviation∂parameter ∈ 6-element Vector{Symbol}</span>
And data, <span class="sgr1">4×6 Matrix{Float64}</span>:
        <span class="sgr35">(:Standard_deviation)</span>  <span class="sgr35">(:σᶻ)</span>     …  <span class="sgr35">(:δ)</span>       <span class="sgr35">(:α)</span>       <span class="sgr35">(:β)</span>
  <span class="sgr35">(:c)</span>   0.0266642              2.66642     -0.384359   0.2626     0.144789
  <span class="sgr35">(:k)</span>   0.264677              26.4677      -5.74194    2.99332    6.30323
  <span class="sgr35">(:q)</span>   0.0739325              7.39325     -0.974722   0.726551   1.08
  <span class="sgr35">(:z)</span>   0.0102062              1.02062      0.0        0.0        0.0</code></pre><h2 id="When-to-Use-Custom-Steady-State-Functions"><a class="docs-heading-anchor" href="#When-to-Use-Custom-Steady-State-Functions">When to Use Custom Steady State Functions</a><a id="When-to-Use-Custom-Steady-State-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Custom-Steady-State-Functions" title="Permalink"></a></h2><p>Consider a custom steady state function when:</p><ol><li><strong>Analytical solution available</strong>: Analytical solutions are more accurate and faster than numerical solutions</li><li><strong>Internal solver struggles</strong>: Complex models may have multiple equilibria or convergence issues</li><li><strong>Performance is critical</strong>: For estimation with many likelihood evaluations, custom functions can speed up computation</li><li><strong>Debugging</strong>: To verify that model equations are correct by comparing against known solutions</li></ol><p>The internal solver is robust and works well for most models, so start with the automatic solver and only switch to a custom function if needed.</p><h2 id="Delayed-Parameter-Declaration"><a class="docs-heading-anchor" href="#Delayed-Parameter-Declaration">Delayed Parameter Declaration</a><a id="Delayed-Parameter-Declaration-1"></a><a class="docs-heading-anchor-permalink" href="#Delayed-Parameter-Declaration" title="Permalink"></a></h2><p>There are cases when one does not want to define all parameter values at the time of model definition. In such cases, one can define a model without parameters (as otherwise defined in the parameter macro) and add them in subsequent function call instead. This is particularly useful if one wants to use parameters from a file, database, or estimation routine. In such cases, one can define the model as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model RBC begin
           1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
           c[0] + k[0] = (1 - δ) * k[-1] + q[0]
           q[0] = exp(z[0]) * k[-1]^α
           z[0] = ρᶻ * z[-1] + σᶻ * ϵᶻ[x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5</code></pre><p>Then, one can run the parameter macro without specifying parameter values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters RBC begin
       end</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: Model has been set up with incomplete parameter definitions. Missing parameters: [:α, :β, :δ, :ρᶻ, :σᶻ]. The non-stochastic steady state and perturbation solution cannot be computed until all parameters are defined. Provide missing parameter values via the `parameters` keyword argument in functions like `get_irf`, `get_SS`, `simulate`, etc.
└ @ Main ~/work/MacroModelling.jl/MacroModelling.jl/src/macros.jl:1610
Model:        RBC
Variables
 Total:       4
  Auxiliary:  0
 States:      2
  Auxiliary:  0
 Jumpers:     2
  Auxiliary:  0
Shocks:       1
Parameters:   5
 Missing:     5</code></pre><p>Later, one can define the parameter values when needed. For example, to get the steady state one can define the parameter values as a <code>Dict</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ss = get_steady_state(RBC, parameters = Dict(:α =&gt; 0.5, :β =&gt; 0.95, :δ =&gt; 0.02, :ρᶻ =&gt; 0.2, :σᶻ =&gt; 0.01))</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	0.048 seconds
Set up non-stochastic steady state problem:				0.121 seconds
Find non-stochastic steady state:					0.24 seconds
Take symbolic derivatives up to first order:				0.048 seconds
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
↓   <span class="sgr35">Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}</span>
→   <span class="sgr35">Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}</span>
And data, <span class="sgr1">4×6 Matrix{Float64}</span>:
        <span class="sgr35">(:Steady_state)</span>   <span class="sgr35">(:α)</span>        <span class="sgr35">(:δ)</span>     <span class="sgr35">(:ρᶻ)</span>  <span class="sgr35">(:σᶻ)</span>    <span class="sgr35">(:β)</span>
  <span class="sgr35">(:c)</span>   5.93625          55.786    -116.072    0.0    0.0     76.1014
  <span class="sgr35">(:k)</span>  47.3903          555.264   -1304.95     0.0    0.0   1445.93
  <span class="sgr35">(:q)</span>   6.88406          66.8912    -94.7805   0.0    0.0    105.02
  <span class="sgr35">(:z)</span>   0.0               0.0         0.0      0.0    0.0      0.0</code></pre><p>The user has the full flexibility to define the parameter values in any way they see fit, and integrate it into their workflow.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plot_model_estimates/">« Model Estimates</a><a class="docs-footer-nextpage" href="../how-to/loops/">Programmatic model writing using for-loops »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 11 January 2026 23:53">Sunday 11 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
