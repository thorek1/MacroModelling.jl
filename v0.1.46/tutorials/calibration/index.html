<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calibration / method of moments (for higher order perturbation solutions) - Gali (2015) ¬∑ MacroModelling.jl</title><meta name="title" content="Calibration / method of moments (for higher order perturbation solutions) - Gali (2015) ¬∑ MacroModelling.jl"/><meta property="og:title" content="Calibration / method of moments (for higher order perturbation solutions) - Gali (2015) ¬∑ MacroModelling.jl"/><meta property="twitter:title" content="Calibration / method of moments (for higher order perturbation solutions) - Gali (2015) ¬∑ MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li class="is-active"><a class="tocitem" href>Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a><ul class="internal"><li><a class="tocitem" href="#Define-the-model"><span>Define the model</span></a></li><li><a class="tocitem" href="#Define-the-parameters"><span>Define the parameters</span></a></li><li><a class="tocitem" href="#Linear-solution"><span>Linear solution</span></a></li><li><a class="tocitem" href="#Nonlinear-solutions"><span>Nonlinear solutions</span></a></li></ul></li><li><a class="tocitem" href="../estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../../plotting/">Overview</a></li><li><a class="tocitem" href="../../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../../plot_conditional_forecast/">Conditional Forecasts</a></li><li><a class="tocitem" href="../../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../../plot_model_estimates/">Model Estimates</a></li></ul></li><li><a class="tocitem" href="../../steady_state/">Steady State</a></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/tutorials/calibration.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Calibration-/-method-of-moments-Gali-(2015)"><a class="docs-heading-anchor" href="#Calibration-/-method-of-moments-Gali-(2015)">Calibration / method of moments - Gali (2015)</a><a id="Calibration-/-method-of-moments-Gali-(2015)-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-/-method-of-moments-Gali-(2015)" title="Permalink"></a></h1><p>This tutorial is intended to show the workflow to calibrate a model using the method of moments. The tutorial is based on a standard model of monetary policy and will showcase the use of gradient based optimisers and 2nd and 3rd order pruned solutions.</p><h2 id="Define-the-model"><a class="docs-heading-anchor" href="#Define-the-model">Define the model</a><a id="Define-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-model" title="Permalink"></a></h2><p>The first step is always to name the model and write down the equations. For the <a href="../../#gali2015">Galƒ±ÃÅ (2015)</a>, Chapter 3 this would go as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MacroModelling</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model Gali_2015 begin
           W_real[0] = C[0] ^ œÉ * N[0] ^ œÜ
       
           Q[0] = Œ≤ * (C[1] / C[0]) ^ (-œÉ) * Z[1] / Z[0] / Pi[1]
       
           R[0] = 1 / Q[0]
       
           Y[0] = A[0] * (N[0] / S[0]) ^ (1 - Œ±)
       
           R[0] = Pi[1] * realinterest[0]
       
           R[0] = 1 / Œ≤ * Pi[0] ^ œï·µñ‚Å± * (Y[0] / Y[ss]) ^ œï ∏ * exp(nu[0])
       
           C[0] = Y[0]
       
           log(A[0]) = œÅ_a * log(A[-1]) + std_a * eps_a[x]
       
           log(Z[0]) = œÅ_z * log(Z[-1]) - std_z * eps_z[x]
       
           nu[0] = œÅ_ŒΩ * nu[-1] + std_nu * eps_nu[x]
       
           MC[0] = W_real[0] / (S[0] * Y[0] * (1 - Œ±) / N[0])
       
           1 = Œ∏ * Pi[0] ^ (œµ - 1) + (1 - Œ∏) * Pi_star[0] ^ (1 - œµ)
       
           S[0] = (1 - Œ∏) * Pi_star[0] ^ (( - œµ) / (1 - Œ±)) + Œ∏ * Pi[0] ^ (œµ / (1 - Œ±)) * S[-1]
       
           Pi_star[0] ^ (1 + œµ * Œ± / (1 - Œ±)) = œµ * x_aux_1[0] / x_aux_2[0] * (1 - œÑ) / (œµ - 1)
       
           x_aux_1[0] = MC[0] * Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ + Œ± * œµ / (1 - Œ±)) * x_aux_1[1]
       
           x_aux_2[0] = Y[0] * Z[0] * C[0] ^ (-œÉ) + Œ≤ * Œ∏ * Pi[1] ^ (œµ - 1) * x_aux_2[1]
       
           log_y[0] = log(Y[0])
       
           log_W_real[0] = log(W_real[0])
       
           log_N[0] = log(N[0])
       
           pi_ann[0] = 4 * log(Pi[0])
       
           i_ann[0] = 4 * log(R[0])
       
           r_real_ann[0] = 4 * log(realinterest[0])
       
           M_real[0] = Y[0] / R[0] ^ Œ∑
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:        Gali_2015
Variables
 Total:       23
  Auxiliary:  0
 States:      4
  Auxiliary:  0
 Jumpers:     5
  Auxiliary:  0
Shocks:       3
Parameters:   16</code></pre><p>First, the package is loaded and then the <a href="../../api/#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> macro is used to define the model. The first argument after <a href="../../api/#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which are written down between <code>begin</code> and <code>end</code>. Equations can contain an equality sign or the expression is assumed to equal 0. Equations cannot span multiple lines (unless the expression is wrapped in brackets) and the timing of endogenous variables are expressed in the square brackets following the variable name (e.g. <code>[-1]</code> for the past period). Exogenous variables (shocks) are followed by a keyword in square brackets indicating them being exogenous (in this case <code>[x]</code>). Note that names can leverage julia&#39;s unicode capabilities (e.g. alpha can be written as Œ±).</p><h2 id="Define-the-parameters"><a class="docs-heading-anchor" href="#Define-the-parameters">Define the parameters</a><a id="Define-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-parameters" title="Permalink"></a></h2><p>Next the parameters of the model need to be added. The macro <a href="../../api/#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> takes care of this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters Gali_2015 begin
           œÉ = 1
       
           œÜ = 5
       
           œï·µñ‚Å± = 1.5
       
           œï ∏ = 0.125
       
           Œ∏ = 0.75
       
           œÅ_ŒΩ = 0.5
       
           œÅ_z = 0.5
       
           œÅ_a = 0.9
       
           Œ≤ = 0.99
       
           Œ∑ = 3.77
       
           Œ± = 0.25
       
           œµ = 9
       
           œÑ = 0
       
           std_a = .01
       
           std_z = .05
       
           std_nu = .0025
       end</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non-stochastic steady state problem:	1.06 seconds
Set up non-stochastic steady state problem:				0.592 seconds
Find non-stochastic steady state:					2.189 seconds
Take symbolic derivatives up to first order:				0.109 seconds
Model:        Gali_2015
Variables
 Total:       23
  Auxiliary:  0
 States:      4
  Auxiliary:  0
 Jumpers:     5
  Auxiliary:  0
Shocks:       3
Parameters:   16</code></pre><p>The block defining the parameters above only describes the simple parameter definitions the same way values are assigned (e.g. <code>Œ± = .25</code>).</p><p>Note that one parameter definition per line is required.</p><h2 id="Linear-solution"><a class="docs-heading-anchor" href="#Linear-solution">Linear solution</a><a id="Linear-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solution" title="Permalink"></a></h2><h3 id="Inspect-model-moments"><a class="docs-heading-anchor" href="#Inspect-model-moments">Inspect model moments</a><a id="Inspect-model-moments-1"></a><a class="docs-heading-anchor-permalink" href="#Inspect-model-moments" title="Permalink"></a></h3><p>Given the equations and parameters, everything is available for the package to generate the theoretical model moments. The mean of the linearised model can be retrieved as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Mean_and_‚àÇmean‚àÇparameter ‚àà 17-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó17 Matrix{Float64}</span>:
                   <span class="sgr35">(:Mean)</span>       ‚Ä¶  <span class="sgr35">(:std_a)</span>  <span class="sgr35">(:std_z)</span>  <span class="sgr35">(:std_nu)</span>
  <span class="sgr35">(:A)</span>              1.0              0.0       0.0       0.0
  <span class="sgr35">(:C)</span>              0.95058          0.0       0.0       0.0
  <span class="sgr35">(:MC)</span>             0.888889         0.0       0.0       0.0
  <span class="sgr35">(:M_real)</span>         0.915236         0.0       0.0       0.0
  <span class="sgr35">(:N)</span>              0.934655     ‚Ä¶   0.0       0.0       0.0
  <span class="sgr35">(:Pi)</span>             1.0              0.0       0.0       0.0
   ‚ãÆ                             ‚ã±   ‚ãÆ
  <span class="sgr35">(:log_y)</span>         -0.0506831        0.0       0.0       0.0
  <span class="sgr35">(:nu)</span>             0.0              0.0       0.0       0.0
  <span class="sgr35">(:pi_ann)</span>        -3.10862e-15  ‚Ä¶   0.0       0.0       0.0
  <span class="sgr35">(:r_real_ann)</span>     0.0402013        0.0       0.0       0.0
  <span class="sgr35">(:realinterest)</span>   1.0101           0.0       0.0       0.0
  <span class="sgr35">(:x_aux_1)</span>        3.452            0.0       0.0       0.0
  <span class="sgr35">(:x_aux_2)</span>        3.8835           0.0       0.0       0.0</code></pre><p>and the standard deviation like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_standard_deviation(Gali_2015)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 17-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó17 Matrix{Float64}</span>:
                   <span class="sgr35">(:Standard_deviation)</span>  ‚Ä¶  <span class="sgr35">(:std_z)</span>      <span class="sgr35">(:std_nu)</span>
  <span class="sgr35">(:A)</span>              0.0229416                 1.58221e-29   1.53692e-30
  <span class="sgr35">(:C)</span>              0.0335717                 0.48179       0.0963579
  <span class="sgr35">(:MC)</span>             0.216091                  4.18882       0.837765
  <span class="sgr35">(:M_real)</span>         0.0592662                 0.491332      0.254845
  <span class="sgr35">(:N)</span>              0.0378695             ‚Ä¶   0.734082      0.146816
  <span class="sgr35">(:Pi)</span>             0.0123588                 0.167366      0.0334732
   ‚ãÆ                                      ‚ã±
  <span class="sgr35">(:log_y)</span>          0.0353171                 0.506838      0.101368
  <span class="sgr35">(:nu)</span>             0.00288675                1.38707e-28   1.1547
  <span class="sgr35">(:pi_ann)</span>         0.049435              ‚Ä¶   0.669465      0.133893
  <span class="sgr35">(:r_real_ann)</span>     0.0564465                 1.09678       0.253692
  <span class="sgr35">(:realinterest)</span>   0.0142542                 0.276965      0.0640637
  <span class="sgr35">(:x_aux_1)</span>        0.951526                  9.39926       1.44896
  <span class="sgr35">(:x_aux_2)</span>        0.516659                  2.99988       0.269446</code></pre><p>Alternatively, <code>std</code> or <code>get_std</code> can be used to achieve the same effect.</p><p>Another interesting output is the autocorrelation of the model variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_autocorrelation(Gali_2015)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr34">Autocorrelation_periods ‚àà 5-element UnitRange{Int64}</span>
And data, <span class="sgr1">23√ó5 Matrix{Float64}</span>:
                   <span class="sgr34">(1)</span>         <span class="sgr34">(2)</span>         ‚Ä¶  <span class="sgr34">(4)</span>          <span class="sgr34">(5)</span>
  <span class="sgr35">(:A)</span>               0.9         0.81           0.6561       0.59049
  <span class="sgr35">(:C)</span>               0.610108    0.404152       0.225901     0.185193
  <span class="sgr35">(:MC)</span>              0.508432    0.261805       0.0750132    0.0430389
  <span class="sgr35">(:M_real)</span>          0.729895    0.571853       0.403664     0.352666
  <span class="sgr35">(:N)</span>               0.508432    0.261805  ‚Ä¶    0.0750132    0.0430389
  <span class="sgr35">(:Pi)</span>              0.626445    0.427023       0.250145     0.208033
   ‚ãÆ                                       ‚ã±                 ‚ãÆ
  <span class="sgr35">(:log_y)</span>           0.610108    0.404152       0.225901     0.185193
  <span class="sgr35">(:nu)</span>              0.5         0.25           0.0625       0.03125
  <span class="sgr35">(:pi_ann)</span>          0.626445    0.427023  ‚Ä¶    0.250145     0.208033
  <span class="sgr35">(:r_real_ann)</span>      0.506897    0.259655       0.0727346    0.0408922
  <span class="sgr35">(:realinterest)</span>    0.506897    0.259655       0.0727346    0.0408922
  <span class="sgr35">(:x_aux_1)</span>         0.700916    0.531282       0.360659     0.31215
  <span class="sgr35">(:x_aux_2)</span>         0.783352    0.646693       0.482995     0.427405</code></pre><p>or the covariance:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_covariance(Gali_2015)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">ùëâùëéùëüùëñùëéùëèùëôùëíùë† ‚àà 23-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó23 Matrix{Float64}</span>:
                   <span class="sgr35">(:A)</span>          <span class="sgr35">(:C)</span>          ‚Ä¶  <span class="sgr35">(:x_aux_1)</span>   <span class="sgr35">(:x_aux_2)</span>
  <span class="sgr35">(:A)</span>              0.000526316   0.000404089     -0.0154711   -0.00997609
  <span class="sgr35">(:C)</span>              0.000404089   0.00112706       0.00730576   0.000310327
  <span class="sgr35">(:MC)</span>            -0.000719776   0.0055578        0.16467      0.0732626
  <span class="sgr35">(:M_real)</span>         0.00103078   -0.000276243     -0.0554553   -0.0300455
  <span class="sgr35">(:N)</span>             -0.000126139   0.000973992  ‚Ä¶   0.028858     0.0128391
  <span class="sgr35">(:Pi)</span>            -0.000159411   0.000169707      0.0115462    0.00587158
   ‚ãÆ                                           ‚ã±
  <span class="sgr35">(:log_y)</span>          0.000425097   0.00118565       0.00768558   0.000326461
  <span class="sgr35">(:nu)</span>            -1.58345e-17  -8.20937e-6      -0.00016948  -5.38539e-5
  <span class="sgr35">(:pi_ann)</span>        -0.000637646   0.000678826  ‚Ä¶   0.0461849    0.0234863
  <span class="sgr35">(:r_real_ann)</span>    -0.000170039   0.00143464       0.0418524    0.0185996
  <span class="sgr35">(:realinterest)</span>  -4.29391e-5    0.000362283      0.0105688    0.00469687
  <span class="sgr35">(:x_aux_1)</span>       -0.0154711     0.00730576       0.905402     0.480501
  <span class="sgr35">(:x_aux_2)</span>       -0.00997609    0.000310327      0.480501     0.266936</code></pre><h3 id="Parameter-sensitivities"><a class="docs-heading-anchor" href="#Parameter-sensitivities">Parameter sensitivities</a><a id="Parameter-sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-sensitivities" title="Permalink"></a></h3><p>Before calibrating the model, examine how parameter changes affect model moments. MacroModelling.jl provides partial derivatives of model moments with respect to model parameters. This model is medium-sized, and derivatives are shown automatically. In this example, the sensitivity of the mean of all variables with respect to the production function parameter <code>œÉ</code> can be obtained like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015, parameter_derivatives = :œÉ)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Mean_and_‚àÇmean‚àÇparameter ‚àà 2-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó2 Matrix{Float64}</span>:
                   <span class="sgr35">(:Mean)</span>       <span class="sgr35">(:œÉ)</span>
  <span class="sgr35">(:A)</span>              1.0          -1.36868e-17
  <span class="sgr35">(:C)</span>              0.95058       0.0060223
  <span class="sgr35">(:MC)</span>             0.888889     -4.01927e-17
  <span class="sgr35">(:M_real)</span>         0.915236      0.00579838
  <span class="sgr35">(:N)</span>              0.934655      0.00789521
  <span class="sgr35">(:Pi)</span>             1.0           3.16441e-19
   ‚ãÆ
  <span class="sgr35">(:log_y)</span>         -0.0506831     0.00633539
  <span class="sgr35">(:nu)</span>             0.0           2.14672e-19
  <span class="sgr35">(:pi_ann)</span>        -3.10862e-15   0.0
  <span class="sgr35">(:r_real_ann)</span>     0.0402013     6.65606e-19
  <span class="sgr35">(:realinterest)</span>   1.0101        1.68082e-19
  <span class="sgr35">(:x_aux_1)</span>        3.452         0.174958
  <span class="sgr35">(:x_aux_2)</span>        3.8835        0.196828</code></pre><p>or for multiple parameters:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015, parameter_derivatives = [:œÉ, :Œ±, :Œ≤, :œï·µñ‚Å±, :œÜ])</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Mean_and_‚àÇmean‚àÇparameter ‚àà 6-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó6 Matrix{Float64}</span>:
                   <span class="sgr35">(:Mean)</span>       <span class="sgr35">(:œÉ)</span>          ‚Ä¶  <span class="sgr35">(:Œ≤)</span>          <span class="sgr35">(:Œ±)</span>
  <span class="sgr35">(:A)</span>              1.0          -1.36868e-17      1.59813e-16  -1.45993e-16
  <span class="sgr35">(:C)</span>              0.95058       0.0060223        4.64356e-15  -0.0941921
  <span class="sgr35">(:MC)</span>             0.888889     -4.01927e-17      3.10312e-14  -1.28507e-15
  <span class="sgr35">(:M_real)</span>         0.915236      0.00579838       3.48529      -0.09069
  <span class="sgr35">(:N)</span>              0.934655      0.00789521   ‚Ä¶   5.14487e-15  -0.207701
  <span class="sgr35">(:Pi)</span>             1.0           3.16441e-19      4.25296e-16  -1.8372e-35
   ‚ãÆ                                           ‚ã±   ‚ãÆ
  <span class="sgr35">(:log_y)</span>         -0.0506831     0.00633539       4.996e-15    -0.0990891
  <span class="sgr35">(:nu)</span>             0.0           2.14672e-19      0.0           1.19167e-35
  <span class="sgr35">(:pi_ann)</span>        -3.10862e-15   0.0          ‚Ä¶   1.66533e-15   0.0
  <span class="sgr35">(:r_real_ann)</span>     0.0402013     6.65606e-19     -4.0404        5.47553e-35
  <span class="sgr35">(:realinterest)</span>   1.0101        1.68082e-19     -1.0203        1.38271e-35
  <span class="sgr35">(:x_aux_1)</span>        3.452         0.174958        10.0544       -1.2876e-13
  <span class="sgr35">(:x_aux_2)</span>        3.8835        0.196828        11.3112        1.26677e-17</code></pre><p>The same can be done for standard deviation or variance, and all parameters:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015, parameter_derivatives = get_parameters(Gali_2015))</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 17-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó17 Matrix{Float64}</span>:
                   <span class="sgr35">(:Standard_deviation)</span>  ‚Ä¶  <span class="sgr35">(:std_z)</span>      <span class="sgr35">(:std_nu)</span>
  <span class="sgr35">(:A)</span>              0.0229416                 1.58221e-29   1.53692e-30
  <span class="sgr35">(:C)</span>              0.0335717                 0.48179       0.0963579
  <span class="sgr35">(:MC)</span>             0.216091                  4.18882       0.837765
  <span class="sgr35">(:M_real)</span>         0.0592662                 0.491332      0.254845
  <span class="sgr35">(:N)</span>              0.0378695             ‚Ä¶   0.734082      0.146816
  <span class="sgr35">(:Pi)</span>             0.0123588                 0.167366      0.0334732
   ‚ãÆ                                      ‚ã±
  <span class="sgr35">(:log_y)</span>          0.0353171                 0.506838      0.101368
  <span class="sgr35">(:nu)</span>             0.00288675                1.38707e-28   1.1547
  <span class="sgr35">(:pi_ann)</span>         0.049435              ‚Ä¶   0.669465      0.133893
  <span class="sgr35">(:r_real_ann)</span>     0.0564465                 1.09678       0.253692
  <span class="sgr35">(:realinterest)</span>   0.0142542                 0.276965      0.0640637
  <span class="sgr35">(:x_aux_1)</span>        0.951526                  9.39926       1.44896
  <span class="sgr35">(:x_aux_2)</span>        0.516659                  2.99988       0.269446</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_variance(Gali_2015, parameter_derivatives = get_parameters(Gali_2015))</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Most of the time is spent calculating derivatives wrt parameters. If they are not needed, add `derivatives = false` as an argument to the function call.
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 23-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Variance_and_‚àÇvariance‚àÇparameter ‚àà 17-element Vector{Symbol}</span>
And data, <span class="sgr1">23√ó17 Matrix{Real}</span>:
                   <span class="sgr35">(:Variance)</span>   <span class="sgr35">(:œÉ)</span>          ‚Ä¶  <span class="sgr35">(:std_z)</span>      <span class="sgr35">(:std_nu)</span>
  <span class="sgr35">(:A)</span>              0.000526316  -1.6242e-19       7.25967e-31   7.05187e-32
  <span class="sgr35">(:C)</span>              0.00112706   -0.00101983       0.032349      0.0064698
  <span class="sgr35">(:MC)</span>             0.0466953    -0.0394622        1.81033       0.362067
  <span class="sgr35">(:M_real)</span>         0.00351248   -0.000388635      0.0582387     0.0302074
  <span class="sgr35">(:N)</span>              0.0014341    -0.00150695   ‚Ä¶   0.0555986     0.0111197
  <span class="sgr35">(:Pi)</span>             0.000152739  -6.64228e-5       0.00413688    0.000827376
   ‚ãÆ                                           ‚ã±
  <span class="sgr35">(:log_y)</span>          0.0012473    -0.00114444       0.0358        0.00716001
  <span class="sgr35">(:nu)</span>             8.33333e-6   -4.67972e-22      8.00825e-31   0.00666667
  <span class="sgr35">(:pi_ann)</span>         0.00244382   -0.00106276   ‚Ä¶   0.06619       0.013238
  <span class="sgr35">(:r_real_ann)</span>     0.0031862    -0.00279404       0.123819      0.02864
  <span class="sgr35">(:realinterest)</span>   0.000203181  -0.000178173      0.00789579    0.00182635
  <span class="sgr35">(:x_aux_1)</span>        0.905402     -0.00995817      17.8873        2.75744
  <span class="sgr35">(:x_aux_2)</span>        0.266936      0.100826         3.09983       0.278423</code></pre><p>This information can be used to calibrate certain values to targets. For example, assuming higher real wages (<code>:W_real</code>), and lower inflation volatility are desired. Since there are too many variables and parameters to be shown here, only a subset of them is printed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi])</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Mean_and_‚àÇmean‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Mean)</span>    <span class="sgr35">(:œÉ)</span>          <span class="sgr35">(:Œ±)</span>         <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       1.0        3.16441e-19  -1.8372e-35   0.0
  <span class="sgr35">(:W_real)</span>   0.678025  -0.00143185   -0.820546     0.0</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi])</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Standard_deviation)</span>  <span class="sgr35">(:œÉ)</span>         <span class="sgr35">(:Œ±)</span>        <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       0.0123588             -0.00268728  -0.0166021   0.390677
  <span class="sgr35">(:W_real)</span>   0.156462              -0.0674815    0.141894    0.0348056</code></pre><p>Looking at the sensitivity table it can be seen that lowering the production function parameter <code>:Œ±</code> will increase real wages, but at the same time it will increase inflation volatility. This effect could be compensated by decreasing the standard deviation of the total factor productivity shock <code>:std_a</code>.</p><h3 id="Method-of-moments"><a class="docs-heading-anchor" href="#Method-of-moments">Method of moments</a><a id="Method-of-moments-1"></a><a class="docs-heading-anchor-permalink" href="#Method-of-moments" title="Permalink"></a></h3><p>Instead of doing this by hand a target can also be set and an optimiser can find the corresponding parameter values. In order to do that targets need to be defined, and an optimisation problem needs to be set up.</p><p>The targets are:</p><ul><li>Mean of <code>W_real = 0.7</code></li><li>Standard deviation of <code>Pi = 0.01</code></li></ul><p>For the optimisation problem the L-BFGS algorithm implemented in <code>Optim.jl</code> is used. This optimisation algorithm is very efficient and gradient based. Note that all model outputs are differentiable with respect to the parameters using automatic and implicit differentiation.</p><p>The package provides functions specialised for the use with gradient based code (e.g. gradient-based optimisers or samplers). For model statistics <code>get_statistics</code> can be used to get the mean of real wages and the standard deviation of inflation like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_statistics(Gali_2015, Gali_2015.parameter_values, parameters = Gali_2015.parameters, mean = [:W_real], standard_deviation = [:Pi])</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: FieldError: type MacroModelling.‚Ñ≥ has no field `parameters`, available fields: `model_name`, `parameter_values`, `NSSS`, `equations`, `caches`, `constants`, `workspaces`, `functions`, `counters`</code></pre><p>First the model object is passed on, followed by the parameter values and the parameter names the values correspond to. Then the desired outputs are defined: for the mean real wages are wanted and for the standard deviation inflation is wanted. Outputs for variance, covariance, or autocorrelation can also be obtained the same way as for the mean and standard deviation.</p><p>Next, a function measuring how close the model is to the target for given values of <code>:Œ±</code> and <code>:std_a</code> can be defined:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function distance_to_target(parameter_value_inputs)
           model_statistics = get_statistics(Gali_2015, parameter_value_inputs, parameters = [:Œ±, :std_a], mean = [:W_real], standard_deviation = [:Pi])
           targets = [0.7, 0.01]
           return sum(abs2, vcat(model_statistics[:mean], model_statistics[:standard_deviation]) - targets)
       end</code><code class="nohighlight hljs ansi" style="display:block;">distance_to_target (generic function with 1 method)</code></pre><p>Now the function can be tested with the current parameter values. In case the parameter values are not known they can also be looked up like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_parameters(Gali_2015, values = true)</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{Pair{String, Float64}}:
      &quot;œÉ&quot; =&gt; 1.0
      &quot;œÜ&quot; =&gt; 5.0
    &quot;œï·µñ‚Å±&quot; =&gt; 1.5
     &quot;œï ∏&quot; =&gt; 0.125
      &quot;Œ∏&quot; =&gt; 0.75
    &quot;œÅ_ŒΩ&quot; =&gt; 0.5
    &quot;œÅ_z&quot; =&gt; 0.5
    &quot;œÅ_a&quot; =&gt; 0.9
      &quot;Œ≤&quot; =&gt; 0.99
      &quot;Œ∑&quot; =&gt; 3.77
      &quot;Œ±&quot; =&gt; 0.25
      &quot;œµ&quot; =&gt; 9.0
      &quot;œÑ&quot; =&gt; 0.0
  &quot;std_a&quot; =&gt; 0.01
  &quot;std_z&quot; =&gt; 0.05
 &quot;std_nu&quot; =&gt; 0.0025</code></pre><p>this allows testing the distance function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; distance_to_target([0.25, 0.01])</code><code class="nohighlight hljs ansi" style="display:block;">0.0004884527635317799</code></pre><p>Next pass it on to an optimiser and find the parameters corresponding to the best fit like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Optim, LineSearches</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol = Optim.optimize(distance_to_target,
                               [0,0],
                               [1,1],
                               [0.25, 0.01],
                               Optim.Fminbox(Optim.LBFGS(linesearch = LineSearches.BackTracking(order = 3))))</code><code class="nohighlight hljs ansi" style="display:block;"> * Status: success

 * Candidate solution
    Final objective value:     5.107257e-07

 * Found with
    Algorithm:     Fminbox with L-BFGS

 * Convergence measures
    |x - x&#39;|               = 1.70e-07 ‚â∞ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 7.62e-07 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|         = 9.83e-16 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 1.92e-09 ‚â∞ 0.0e+00
    |g(x)|                 = 5.36e-09 ‚â§ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    5
    f(x) calls:    38
    ‚àáf(x) calls:   33</code></pre><p>The first argument to the optimisation call is the function defined previously, followed by lower and upper bounds, the starting values, and finally the algorithm. For the algorithm <code>Fminbox</code> has to be added because bounds are present (optional) and the specific line search method is set to speed up convergence (recommended but optional).</p><p>The output shows that the optimisation almost perfectly matches the target and the values of the parameters found by the optimiser are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.minimizer</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.22330255707129626
 1.6390336271990582e-9</code></pre><p>slightly lower for both parameters (in line with the previous insights from the sensitivities).</p><p>Combine the method of moments with estimation by adding the distance to the target as a penalty term to the posterior log-likelihood.</p><h2 id="Nonlinear-solutions"><a class="docs-heading-anchor" href="#Nonlinear-solutions">Nonlinear solutions</a><a id="Nonlinear-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-solutions" title="Permalink"></a></h2><p>Up to this point the linearised solution of the model was used. The package also provides nonlinear solutions and can calculate the theoretical model moments for pruned second and third order perturbation solutions. This can be of interest because nonlinear solutions capture volatility effects (at second order) and asymmetries (at third order). Furthermore, the moments of the data are often non-gaussian while linear solutions with gaussian noise can only generate gaussian distributions of model variables. Nonetheless, already pruned second order solutions produce non-gaussian skewness and kurtosis with gaussian noise.</p><p>From a user perspective little changes other than specifying that the solution algorithm is <code>:pruned_second_order</code> or <code>:pruned_third_order</code>.</p><p>For example the mean for the pruned second order solution can be obtained as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_mean(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi], algorithm = :pruned_second_order)</code><code class="nohighlight hljs ansi" style="display:block;">Take symbolic derivatives up to second order:				1.46 seconds
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Mean_and_‚àÇmean‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Mean)</span>    <span class="sgr35">(:œÉ)</span>         <span class="sgr35">(:Œ±)</span>        <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       1.00915   -0.00566881   0.0136518   0.509002
  <span class="sgr35">(:W_real)</span>   0.650863   0.0135465   -0.823786   -1.15286</code></pre><p>Note that the mean of real wages is lower, while inflation is higher. The effect of volatility can be seen with the partial derivatives for the shock standard deviations being non-zero. Larger shocks sizes drive down the mean of real wages while they increase inflation.</p><p>The mean of the variables does not change if pruned third order perturbation is used by construction but the standard deviation does. Consider the standard deviations for the pruned second order solution first:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi], algorithm = :pruned_second_order)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Standard_deviation)</span>  <span class="sgr35">(:œÉ)</span>         <span class="sgr35">(:Œ±)</span>        <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       0.0134547             -0.00218051  -0.0124107   0.561568
  <span class="sgr35">(:W_real)</span>   0.174772              -0.0802741    0.193677    1.40047</code></pre><p>for both inflation and real wages the volatility is higher and the standard deviation of the total factor productivity shock <code>std_a</code> has a much larger impact on the standard deviation of real wages compared to the linear solution.</p><p>At third order the results are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi], algorithm = :pruned_third_order)</code><code class="nohighlight hljs ansi" style="display:block;">Take symbolic derivatives up to third order:				3.232 seconds
2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Standard_deviation)</span>  <span class="sgr35">(:œÉ)</span>         <span class="sgr35">(:Œ±)</span>        <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       0.0306702              0.00118209   0.0666339   3.54003
  <span class="sgr35">(:W_real)</span>   0.259961              -0.147647     0.597069    9.1828</code></pre><p>standard deviations of inflation is more than two times as high and for real wages it is also substantially higher. Furthermore, standard deviations of shocks matter even more for the volatility of the endogenous variables.</p><p>These results make it clear that capturing the nonlinear interactions by using nonlinear solutions has important implications for the model moments and by extension the model dynamics.</p><h3 id="Method-of-moments-for-nonlinear-solutions"><a class="docs-heading-anchor" href="#Method-of-moments-for-nonlinear-solutions">Method of moments for nonlinear solutions</a><a id="Method-of-moments-for-nonlinear-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Method-of-moments-for-nonlinear-solutions" title="Permalink"></a></h3><p>Matching the theoretical moments of the nonlinear model solution to the data is no more complicated for the user than in the linear solution case (see above).</p><p>Define the target value and function and let an optimiser find the parameters minimising the distance to the target.</p><p>Keeping the targets:</p><ul><li>Mean of <code>W_real = 0.7</code></li><li>Standard deviation of <code>Pi = 0.01</code></li></ul><p>the target function needs to specify that a nonlinear solution algorithm is used (e.g. pruned third order):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function distance_to_target(parameter_value_inputs)
           model_statistics = get_statistics(Gali_2015, parameter_value_inputs, algorithm = :pruned_third_order, parameters = [:Œ±, :std_a], mean = [:W_real], standard_deviation = [:Pi])
           targets = [0.7, 0.01]
           return sum(abs2, vcat(model_statistics[:mean], model_statistics[:standard_deviation]) - targets)
       end</code><code class="nohighlight hljs ansi" style="display:block;">distance_to_target (generic function with 1 method)</code></pre><p>and then use the same code to optimise as in the linear solution case:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol = Optim.optimize(distance_to_target,
                               [0,0],
                               [1,1],
                               [0.25, 0.01],
                               Optim.Fminbox(Optim.LBFGS(linesearch = LineSearches.BackTracking(order = 3))))</code><code class="nohighlight hljs ansi" style="display:block;"> * Status: success

 * Candidate solution
    Final objective value:     2.703124e-05

 * Found with
    Algorithm:     Fminbox with L-BFGS

 * Convergence measures
    |x - x&#39;|               = 2.96e-06 ‚â∞ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 1.50e-05 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|         = 3.15e-09 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 1.16e-04 ‚â∞ 0.0e+00
    |g(x)|                 = 3.12e-09 ‚â§ 1.0e-08

 * Work counters
    Seconds run:   17  (vs limit Inf)
    Iterations:    3
    f(x) calls:    60
    ‚àáf(x) calls:   34</code></pre><p>the calculations take substantially longer and the solution does not get as close to the target as for the linear solution case. The parameter values minimising the distance are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.minimizer</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1972280580455649
 3.0031738779086124e-9</code></pre><p>lower than for the linear solution case and the theoretical moments given these parameter are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_statistics(Gali_2015, sol.minimizer, algorithm = :pruned_third_order, parameters = [:Œ±, :std_a], mean = [:W_real], standard_deviation = [:Pi])</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Symbol, AbstractArray{Float64}} with 2 entries:
  :mean               =&gt; [0.699956]
  :standard_deviation =&gt; [0.015199]</code></pre><p>The solution does not match the standard deviation of inflation very well.</p><p>Potentially the partial derivatives change a lot for small changes in parameters and even though the partial derivatives for standard deviation of inflation were large wrt <code>std_a</code> they might be small for values returned from the optimisation. This can be checked with:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_std(Gali_2015, parameter_derivatives = [:œÉ, :std_a, :Œ±], variables = [:W_real,:Pi], algorithm = :pruned_third_order, parameters = [:Œ±, :std_a] .=&gt; sol.minimizer)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional <span class="sgr1">KeyedArray(NamedDimsArray(...))</span> with keys:
‚Üì   <span class="sgr35">Variables ‚àà 2-element Vector{Symbol}</span>
‚Üí   <span class="sgr35">Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 4-element Vector{Symbol}</span>
And data, <span class="sgr1">2√ó4 Matrix{Float64}</span>:
             <span class="sgr35">(:Standard_deviation)</span>  <span class="sgr35">(:œÉ)</span>         <span class="sgr35">(:Œ±)</span>         <span class="sgr35">(:std_a)</span>
  <span class="sgr35">(:Pi)</span>       0.015199              -0.00757059  -0.00699053   0.103974
  <span class="sgr35">(:W_real)</span>   0.202941              -0.137095     0.31342      0.731875</code></pre><p>and indeed it seems also the second derivative is large since the first derivative changed significantly.</p><p>Another parameter to try is <code>œÉ</code>. It has a positive impact on the mean of real wages and a negative impact on standard deviation of inflation.</p><p>The target function needs to be redefined and optimised. Note that the previous call made a permanent change of parameters (as do all calls where parameters are explicitly set) and now <code>std_a</code> is set to 2.91e-9 and no longer 0.01.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function distance_to_target(parameter_value_inputs)
           model_statistics = get_statistics(Gali_2015, parameter_value_inputs, algorithm = :pruned_third_order, parameters = [:Œ±, :œÉ], mean = [:W_real], standard_deviation = [:Pi])
           targets = [0.7, 0.01]
           return sum(abs2, vcat(model_statistics[:mean], model_statistics[:standard_deviation]) - targets)
       end</code><code class="nohighlight hljs ansi" style="display:block;">distance_to_target (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol = Optim.optimize(distance_to_target,
                               [0,0],
                               [1,3],
                               [0.25, 1],
                               Optim.Fminbox(Optim.LBFGS(linesearch = LineSearches.BackTracking(order = 3))))</code><code class="nohighlight hljs ansi" style="display:block;"> * Status: success

 * Candidate solution
    Final objective value:     1.566885e-12

 * Found with
    Algorithm:     Fminbox with L-BFGS

 * Convergence measures
    |x - x&#39;|               = 2.55e-08 ‚â∞ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 1.20e-08 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|         = 1.25e-11 ‚â∞ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 8.89e-01 ‚â∞ 0.0e+00
    |g(x)|                 = 6.91e-09 ‚â§ 1.0e-08

 * Work counters
    Seconds run:   17  (vs limit Inf)
    Iterations:    3
    f(x) calls:    41
    ‚àáf(x) calls:   41</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol.minimizer</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.20874123864995744
 2.1236961113311383</code></pre><p>Given the new value for <code>std_a</code> and optimising over <code>œÉ</code> allows matching the target exactly.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sw03/">¬´ Work with a more complex model - Smets and Wouters (2003)</a><a class="docs-footer-nextpage" href="../estimation/">Estimate a model using gradient based samplers - Schorfheide (2000) ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 19:43">Friday 30 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
