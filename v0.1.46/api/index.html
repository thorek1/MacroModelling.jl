<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ MacroModelling.jl</title><meta name="title" content="API ¬∑ MacroModelling.jl"/><meta property="og:title" content="API ¬∑ MacroModelling.jl"/><meta property="twitter:title" content="API ¬∑ MacroModelling.jl"/><meta name="description" content="Documentation for MacroModelling.jl."/><meta property="og:description" content="Documentation for MacroModelling.jl."/><meta property="twitter:description" content="Documentation for MacroModelling.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">Write your first simple model - RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Work with a more complex model - Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../tutorials/calibration/">Calibration / method of moments (for higher order perturbation solutions) - Gali (2015)</a></li><li><a class="tocitem" href="../tutorials/estimation/">Estimate a model using gradient based samplers - Schorfheide (2000)</a></li></ul></li><li><span class="tocitem">Plotting</span><ul><li><a class="tocitem" href="../plotting/">Overview</a></li><li><a class="tocitem" href="../plot_irf/">Impulse Response Functions</a></li><li><a class="tocitem" href="../plot_solution/">Policy Functions</a></li><li><a class="tocitem" href="../plot_conditional_forecast/">Conditional Forecasts</a></li><li><a class="tocitem" href="../plot_conditional_variance_decomposition/">Variance Decomposition</a></li><li><a class="tocitem" href="../plot_model_estimates/">Model Estimates</a></li></ul></li><li><a class="tocitem" href="../steady_state/">Steady State</a></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../how-to/loops/">Programmatic model writing using for-loops</a></li><li><a class="tocitem" href="../how-to/obc/">Occasionally binding constraints</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article><details class="docstring" open="true"><summary id="MacroModelling.Find_shocks_workspace-Tuple{}"><a class="docstring-binding" href="#MacroModelling.Find_shocks_workspace-Tuple{}"><code>MacroModelling.Find_shocks_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Find_shocks_workspace(;T::Type = Float64)</code></pre><p>Create a workspace for find<em>shocks conditional forecast with lazy buffer allocation. All buffers are initialized to 0-dimensional objects and resized on-demand via ensure</em>find<em>shocks</em>buffers!.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L161-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Inversion_workspace-Tuple{}"><a class="docstring-binding" href="#MacroModelling.Inversion_workspace-Tuple{}"><code>MacroModelling.Inversion_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Inversion_workspace(;T::Type = Float64)</code></pre><p>Create a workspace for inversion filter computations with lazy buffer allocation. All buffers are initialized to 0-dimensional objects and resized on-demand via ensure<em>inversion</em>buffers!.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L446-L451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Kalman_workspace-Tuple{}"><a class="docstring-binding" href="#MacroModelling.Kalman_workspace-Tuple{}"><code>MacroModelling.Kalman_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Kalman_workspace(;T::Type = Float64)</code></pre><p>Create a workspace for Kalman filter computations with lazy buffer allocation. All buffers are initialized to 0-dimensional objects and resized on-demand via ensure<em>kalman</em>buffers!.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L549-L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Lyapunov_workspace-Tuple{Int64}"><a class="docstring-binding" href="#MacroModelling.Lyapunov_workspace-Tuple{Int64}"><code>MacroModelling.Lyapunov_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Lyapunov_workspace(n::Int; T::Type = Float64)</code></pre><p>Create a workspace for the Lyapunov equation solver with lazy buffer allocation. <code>n</code> is the dimension of the square matrices. Buffers are initialized to 0-dimensional objects and resized on-demand when the corresponding algorithm is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L240-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Nonlinear_solver_workspace-Union{Tuple{T}, Tuple{Vector{T}, AbstractMatrix{T}, LinearSolve.LinearCache, LinearSolve.LinearCache}} where T&lt;:Real"><a class="docstring-binding" href="#MacroModelling.Nonlinear_solver_workspace-Union{Tuple{T}, Tuple{Vector{T}, AbstractMatrix{T}, LinearSolve.LinearCache, LinearSolve.LinearCache}} where T&lt;:Real"><code>MacroModelling.Nonlinear_solver_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Create a workspace for nonlinear solvers (Levenberg-Marquardt and Newton).</p><p><strong>Arguments</strong></p><ul><li><code>func_buffer::Vector{T}</code>: Pre-allocated buffer for function evaluation</li><li><code>jac_buffer::AbstractMatrix{T}</code>: Pre-allocated buffer for Jacobian</li><li><code>chol_buffer::LinearCache</code>: Pre-allocated Cholesky factorization cache</li><li><code>lu_buffer::LinearCache</code>: Pre-allocated LU factorization cache</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L103-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Qme_workspace-Tuple{Int64}"><a class="docstring-binding" href="#MacroModelling.Qme_workspace-Tuple{Int64}"><code>MacroModelling.Qme_workspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Qme_workspace(n::Int; T::Type = Float64)</code></pre><p>Create a pre-allocated workspace for the quadratic matrix equation doubling algorithm. <code>n</code> is the dimension of the square matrices (nVars - nPresent_only).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L209-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.SS"><a class="docstring-binding" href="#MacroModelling.SS"><code>MacroModelling.SS</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1661-L1663">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.SSS-Tuple"><a class="docstring-binding" href="#MacroModelling.SSS-Tuple"><code>MacroModelling.SSS</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1648-L1650">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Second_order_indices-Tuple{}"><a class="docstring-binding" href="#MacroModelling.Second_order_indices-Tuple{}"><code>MacroModelling.Second_order_indices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Second_order_indices()</code></pre><p>Create an empty <code>second_order_indices</code> struct with all fields initialized to empty/zero values. These will be lazily populated by various ensure_*! functions as needed.</p><p>See <a href="@ref"><code>second_order_indices</code></a> for field documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L2-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Third_order_indices-Tuple{}"><a class="docstring-binding" href="#MacroModelling.Third_order_indices-Tuple{}"><code>MacroModelling.Third_order_indices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Third_order_indices()</code></pre><p>Create an empty <code>third_order_indices</code> struct with all fields initialized to empty/zero values. These will be lazily populated by various ensure_*! functions as needed.</p><p>See <a href="@ref"><code>third_order_indices</code></a> for field documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L54-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.apply_custom_name-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{R, AbstractDict{S, T}}} where {R&lt;:Union{String, Symbol}, S, T}"><a class="docstring-binding" href="#MacroModelling.apply_custom_name-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{R, AbstractDict{S, T}}} where {R&lt;:Union{String, Symbol}, S, T}"><code>MacroModelling.apply_custom_name</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_custom_name(symbol::Symbol, custom_names::Dict{Symbol, String})</code></pre><p>Apply custom name from dictionary if available, otherwise use default name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L3267-L3271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.autocorr"><a class="docstring-binding" href="#MacroModelling.autocorr"><code>MacroModelling.autocorr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2638-L2640">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.check_residuals"><a class="docstring-binding" href="#MacroModelling.check_residuals"><code>MacroModelling.check_residuals</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.‚Ñ≥, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>get_non_stochastic_steady_state_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3800-L3802">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.corr"><a class="docstring-binding" href="#MacroModelling.corr"><code>MacroModelling.corr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2502-L2504">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.cov"><a class="docstring-binding" href="#MacroModelling.cov"><code>MacroModelling.cov</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3235-L3237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_find_shocks_buffers!-Union{Tuple{T}, Tuple{MacroModelling.find_shocks_workspace{T}, Int64}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_find_shocks_buffers!-Union{Tuple{T}, Tuple{MacroModelling.find_shocks_workspace{T}, Int64}} where T"><code>MacroModelling.ensure_find_shocks_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_find_shocks_buffers!(ws::find_shocks_workspace{T}, n_exo::Int; third_order::Bool = false) where T</code></pre><p>Ensure the find<em>shocks workspaces are allocated for the given number of shocks. Only allocates 3rd order buffers if third</em>order=true. Buffer sizes: kron<em>buffer (n</em>exo^2), kron<em>buffer2 (n</em>exo^2 √ó n<em>exo),                kron</em>buffer¬≤ (n<em>exo^3), kron</em>buffer3 (n<em>exo^3 √ó n</em>exo), kron<em>buffer4 (n</em>exo^3 √ó n_exo^2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L407-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_inversion_buffers!-Union{Tuple{T}, Tuple{MacroModelling.inversion_workspace{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_inversion_buffers!-Union{Tuple{T}, Tuple{MacroModelling.inversion_workspace{T}, Int64, Int64}} where T"><code>MacroModelling.ensure_inversion_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_inversion_buffers!(ws::inversion_workspace{T}, n_exo::Int, n_past::Int; third_order::Bool = false) where T</code></pre><p>Ensure the inversion workspaces are allocated for the given dimensions. Only allocates 3rd order buffers if third_order=true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L481-L486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_inversion_workspace!-Tuple{Any}"><a class="docstring-binding" href="#MacroModelling.ensure_inversion_workspace!-Tuple{Any}"><code>MacroModelling.ensure_inversion_workspace!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_inversion_workspace!(ùìÇ; third_order::Bool = false)</code></pre><p>Ensure the inversion filter workspace is properly sized for the model. Dimensions are based on nExo (number of shocks) and nPast<em>not</em>future<em>and</em>mixed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1274-L1279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_kalman_buffers!-Union{Tuple{T}, Tuple{MacroModelling.kalman_workspace{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_kalman_buffers!-Union{Tuple{T}, Tuple{MacroModelling.kalman_workspace{T}, Int64, Int64}} where T"><code>MacroModelling.ensure_kalman_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_kalman_buffers!(ws::kalman_workspace{T}, n_obs::Int, n_states::Int) where T</code></pre><p>Ensure the Kalman workspaces are allocated for the given dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L570-L574">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_kalman_workspace!-Tuple{Any}"><a class="docstring-binding" href="#MacroModelling.ensure_kalman_workspace!-Tuple{Any}"><code>MacroModelling.ensure_kalman_workspace!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_kalman_workspace!(ùìÇ)</code></pre><p>Ensure the Kalman filter workspace is available. Returns the workspace for use. Actual buffer resizing happens lazily in ensure<em>kalman</em>buffers! when dimensions are known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1289-L1294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_bicgstab_solver!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_bicgstab_solver!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><code>MacroModelling.ensure_lyapunov_bicgstab_solver!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_bicgstab_solver!(ws::lyapunov_workspace{T}) where T</code></pre><p>Ensure the bicgstab solver workspace is allocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L311-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_doubling_buffers!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_doubling_buffers!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><code>MacroModelling.ensure_lyapunov_doubling_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_doubling_buffers!(ws::lyapunov_workspace{T}) where T</code></pre><p>Ensure the doubling algorithm buffers are allocated in the workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L267-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_gmres_solver!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_gmres_solver!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><code>MacroModelling.ensure_lyapunov_gmres_solver!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_gmres_solver!(ws::lyapunov_workspace{T}) where T</code></pre><p>Ensure the gmres solver workspace is allocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L325-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_krylov_buffers!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_krylov_buffers!-Union{Tuple{MacroModelling.lyapunov_workspace{T}}, Tuple{T}} where T"><code>MacroModelling.ensure_lyapunov_krylov_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_krylov_buffers!(ws::lyapunov_workspace{T}) where T</code></pre><p>Ensure the Krylov method buffers are allocated in the workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L292-L296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_workspace!-Tuple{MacroModelling.workspaces, Int64, Symbol}"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_workspace!-Tuple{MacroModelling.workspaces, Int64, Symbol}"><code>MacroModelling.ensure_lyapunov_workspace!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_workspace!(workspaces, n, order::Symbol)</code></pre><p>Ensure the Lyapunov workspace for the specified moment order is properly sized. <code>n</code> is the dimension of the square matrices. <code>order</code> should be <code>:first_order</code>, <code>:second_order</code>, or <code>:third_order</code>. If the workspace is the wrong size, it will be reallocated. Note: buffers are still lazily allocated when algorithms are actually used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1228-L1236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_lyapunov_workspace_1st_order!-Tuple{Any}"><a class="docstring-binding" href="#MacroModelling.ensure_lyapunov_workspace_1st_order!-Tuple{Any}"><code>MacroModelling.ensure_lyapunov_workspace_1st_order!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_lyapunov_workspace_1st_order!(ùìÇ)</code></pre><p>Ensure the first-order Lyapunov workspace is properly sized for the model. The dimension is <code>nVars</code> (size of the covariance matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1261-L1266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_qme_workspace!-Tuple{Any}"><a class="docstring-binding" href="#MacroModelling.ensure_qme_workspace!-Tuple{Any}"><code>MacroModelling.ensure_qme_workspace!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_qme_workspace!(ùìÇ)
ensure_qme_workspace!(workspaces, n)</code></pre><p>Ensure the QME (quadratic matrix equation) workspace is properly sized for the model. The workspace dimension is <code>n = nVars - nPresent_only</code> (the size of the QME matrices). If the workspace is the wrong size, it will be reallocated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1188-L1195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_sylvester_1st_order_workspace!-Tuple{Any}"><a class="docstring-binding" href="#MacroModelling.ensure_sylvester_1st_order_workspace!-Tuple{Any}"><code>MacroModelling.ensure_sylvester_1st_order_workspace!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_sylvester_1st_order_workspace!(ùìÇ)
ensure_sylvester_1st_order_workspace!(workspaces)</code></pre><p>Return the first-order sylvester workspace from the model or workspaces. The workspace is lazily sized by the sylvester solver when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L1212-L1218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_sylvester_doubling_buffers!-Union{Tuple{T}, Tuple{MacroModelling.sylvester_workspace{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_sylvester_doubling_buffers!-Union{Tuple{T}, Tuple{MacroModelling.sylvester_workspace{T}, Int64, Int64}} where T"><code>MacroModelling.ensure_sylvester_doubling_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_sylvester_doubling_buffers!(ws::sylvester_workspace{T}, n::Int, m::Int) where T</code></pre><p>Ensure the doubling algorithm buffers are allocated in the workspace. <code>n</code> is the row dimension (size of A), <code>m</code> is the column dimension (size of B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L343-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ensure_sylvester_krylov_buffers!-Union{Tuple{T}, Tuple{MacroModelling.sylvester_workspace{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroModelling.ensure_sylvester_krylov_buffers!-Union{Tuple{T}, Tuple{MacroModelling.sylvester_workspace{T}, Int64, Int64}} where T"><code>MacroModelling.ensure_sylvester_krylov_buffers!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_sylvester_krylov_buffers!(ws::sylvester_workspace{T}, n::Int, m::Int) where T</code></pre><p>Ensure the Krylov method buffers are allocated in the workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/options_and_caches.jl#L384-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.export_dynare"><a class="docstring-binding" href="#MacroModelling.export_dynare"><code>MacroModelling.export_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L221-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.export_mod_file"><a class="docstring-binding" href="#MacroModelling.export_mod_file"><code>MacroModelling.export_mod_file</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L231-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.export_model"><a class="docstring-binding" href="#MacroModelling.export_model"><code>MacroModelling.export_model</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L251-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.export_to_dynare"><a class="docstring-binding" href="#MacroModelling.export_to_dynare"><code>MacroModelling.export_to_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L226-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.expr_contains-Tuple{Any, Symbol, Any}"><a class="docstring-binding" href="#MacroModelling.expr_contains-Tuple{Any, Symbol, Any}"><code>MacroModelling.expr_contains</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expr_contains(expr, sym::Symbol, pattern) -&gt; Bool</code></pre><p>Check if <code>expr</code> contains <code>sym</code> matching <code>pattern</code> (nothing = any timing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L49-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.fevd"><a class="docstring-binding" href="#MacroModelling.fevd"><code>MacroModelling.fevd</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2239-L2241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.find_SS_solver_parameters!-Tuple{Val{:ESCH}, MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.find_SS_solver_parameters!-Tuple{Val{:ESCH}, MacroModelling.‚Ñ≥}"><code>MacroModelling.find_SS_solver_parameters!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_SS_solver_parameters!(::Val{:ESCH}, ùìÇ::‚Ñ≥; maxtime::Real = 120, maxiter::Int = 2500000, tol::Tolerances = Tolerances(), verbosity = 0)</code></pre><p>Find optimal steady state solver parameters using NLopt&#39;s ESCH algorithm.</p><p>This function optimizes solver parameters to minimize runtime while maintaining solver accuracy. It uses the ESCH global optimization algorithm from the NLopt package.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: Model structure</li><li><code>maxtime</code>: Maximum time in seconds for optimization</li><li><code>maxiter</code>: Maximum number of iterations</li><li><code>tol</code>: Tolerance structure</li><li><code>verbosity</code>: Verbosity level for output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L5932-L5946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.find_shocks-Tuple{Val{:LagrangeNewton}, Vector{Float64}, Vector{Float64}, AbstractMatrix{Float64}, LinearAlgebra.Diagonal{Bool, Vector{Bool}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#MacroModelling.find_shocks-Tuple{Val{:LagrangeNewton}, Vector{Float64}, Vector{Float64}, AbstractMatrix{Float64}, LinearAlgebra.Diagonal{Bool, Vector{Bool}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Vector{Float64}}"><code>MacroModelling.find_shocks</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Solve for minimum-norm shocks that satisfy linear and quadratic constraints using a Lagrange-Newton stepper. For higher-order solutions the global minimum-norm problem is NP-hard because the number of feasible roots grows exponentially; any gradient-based solver started at the origin (not just LagrangeNewton) will converge to the root whose basin contains the origin rather than guaranteeing the global optimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/filter/find_shocks.jl#L877-L883">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_IRF"><a class="docstring-binding" href="#MacroModelling.get_IRF"><code>MacroModelling.get_IRF</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1343-L1345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_SS"><a class="docstring-binding" href="#MacroModelling.get_SS"><code>MacroModelling.get_SS</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1671-L1673">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_SSS-Tuple"><a class="docstring-binding" href="#MacroModelling.get_SSS-Tuple"><code>MacroModelling.get_SSS</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1642-L1644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_autocorr"><a class="docstring-binding" href="#MacroModelling.get_autocorr"><code>MacroModelling.get_autocorr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>get_autocorrelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2632-L2634">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_autocorrelation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_autocorrelation(
    ùìÇ;
    autocorrelation_periods,
    parameters,
    steady_state_function,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the autocorrelations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>, Type: <code>UnitRange{Int}</code>]: periods for which to return the autocorrelation</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows and autocorrelation periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_autocorrelation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Autocorrelation_periods ‚àà 5-element UnitRange{Int64}
And data, 4√ó5 Matrix{Float64}:
        (1)         (2)         (3)         (4)         (5)
  (:c)    0.966974    0.927263    0.887643    0.849409    0.812761
  (:k)    0.971015    0.931937    0.892277    0.853876    0.817041
  (:q)    0.32237     0.181562    0.148347    0.136867    0.129944
  (:z)    0.2         0.04        0.008       0.0016      0.00032</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2510">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_calibrated_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibrated_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_calibrated_parameters(ùìÇ; values)
</code></pre><p>Returns the parameters (and optionally the values) which are determined by a calibration equation. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the calibrated parameters or <code>Vector{Pair{String, Float64}}</code> of the calibrated parameters and values if <code>values</code> is set to <code>true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibrated_parameters(RBC)
# output
1-element Vector{String}:
 &quot;Œ¥&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_calibration_equation_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibration_equation_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_calibration_equation_parameters(ùìÇ)
</code></pre><p>Returns the parameters used in calibration equations which are not used in the equations of the model (see <code>capital_to_output</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibration_equation_parameters(RBC)
# output
1-element Vector{String}:
 &quot;capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L717">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_calibration_equations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_calibration_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_calibration_equations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_calibration_equations(ùìÇ; filter)
</code></pre><p>Return the calibration equations declared in the <code>@parameters</code> block. Calibration equations are additional equations which are part of the non-stochastic steady state problem. The additional equation is matched with a calibated parameter which is part of the equations declared in the <code>@model</code> block and can be retrieved with: <code>get_calibrated_parameters</code></p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the output assumes the equations are equal to 0. As in, <code>k / (q * 4) - capital_to_output</code> implies <code>k / (q * 4) - capital_to_output = 0</code> and therefore: <code>k / (q * 4) = capital_to_output</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the calibration equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_calibration_equations(RBC)
# output
1-element Vector{String}:
 &quot;k / (q * 4) - capital_to_output&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_computational_constants-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_computational_constants-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_computational_constants</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_computational_constants(ùìÇ::‚Ñ≥)</code></pre><p>Return cached second-order computational constants (BitVectors and index patterns).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L3546-L3550">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><a class="docstring-binding" href="#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.get_conditional_forecast</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_conditional_forecast(
    ùìÇ,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    steady_state_function,
    variables,
    conditions_in_levels,
    algorithm,
    levels,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    conditional_forecast_solver
)
</code></pre><p>Return the conditional forecast given restrictions on endogenous variables and shocks (optional). By default, the values represent absolute deviations from the relevant steady state (see <code>levels</code> for details). The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. A constrained minimisation problem is solved to find the combination of shocks with the smallest squared magnitude fulfilling the conditions.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries, the first dimension corresponds to variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as conditions. Note that conditioning variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which conditions are specified can be included and all other variables are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing}</code>]: known values of shocks. This argument allows including certain shock values. By entering restrictions on the shocks in this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the respective period. The input can have multiple formats, but for all types of entries, the first dimension corresponds to shocks and the second dimension to the number of periods. <code>shocks</code> can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as certain shock values. Note that conditioning shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which values are specified can be included and all other shocks are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the relevant steady state subtracted (non-stochastic or stochastic steady state depending on the solution algorithm).</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables  and shocks in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling
using SparseArrays, AxisKeys

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 2
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)
conditions[1,1] = .01
conditions[2,2] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

get_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_shocks ‚àà 9-element Vector{Symbol}
‚Üí   Periods ‚àà 42-element UnitRange{Int64}
And data, 9√ó42 Matrix{Float64}:
                (1)            (2)           ‚Ä¶  (41)            (42)
  (:A)            0.0313639      0.0134792         0.000221372     0.000199235
  (:Pi)           0.000780257    0.00020929       -0.000146071    -0.000140137
  (:R)            0.00117156     0.00031425       -0.000219325    -0.000210417
  (:c)            0.01           0.00600605        0.00213278      0.00203751
  (:k)            0.034584       0.0477482   ‚Ä¶     0.0397631       0.0380482
  (:y)            0.0446375      0.02              0.00129544      0.001222
  (:z_delta)      0.00025        0.000225          3.69522e-6      3.3257e-6
  (:delta_eps)    0.05           0.0               0.0             0.0
  (:eps_z)        4.61234       -2.16887           0.0             0.0

# The same can be achieved with the other input formats:
# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# using SparseArrays
# conditions = spzeros(7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])
# shocks[1,1] = .05

# using SparseArrays
# shocks = spzeros(2,1)
# shocks[1,1] = .05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L620">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_conditional_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_conditional_variance_decomposition(
    ùìÇ;
    periods,
    parameters,
    steady_state_function,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the conditional variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>[1:20...,Inf]</code>, Type: <code>Union{Vector{Int},Vector{Float64},UnitRange{Int64}}</code>]: vector of periods for which to calculate the conditional variance decomposition. If the vector contains <code>Inf</code>, also the unconditional variance decomposition is calculated (same output as <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_variance_decomposition</code></a>).</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, shocks in columns, and periods as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_conditional_variance_decomposition(RBC_CME)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 7-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
‚ó™   Periods ‚àà 21-element Vector{Float64}
And data, 7√ó2√ó21 Array{Float64, 3}:
[showing 3 of 21 slices]
[:, :, 1] ~ (:, :, 1.0):
              (:delta_eps)  (:eps_z)
  (:A)         0.0           1.0
  (:Pi)        0.00158668    0.998413
  (:R)         0.00158668    0.998413
  (:c)         0.0277348     0.972265
  (:k)         0.00869568    0.991304
  (:y)         0.0           1.0
  (:z_delta)   1.0           0.0

[:, :, 11] ~ (:, :, 11.0):
              (:delta_eps)  (:eps_z)
  (:A)         5.88653e-32   1.0
  (:Pi)        0.0245641     0.975436
  (:R)         0.0245641     0.975436
  (:c)         0.0175249     0.982475
  (:k)         0.00869568    0.991304
  (:y)         7.63511e-5    0.999924
  (:z_delta)   1.0           0.0

[:, :, 21] ~ (:, :, Inf):
              (:delta_eps)  (:eps_z)
  (:A)         9.6461e-31    1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2051">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_corr"><a class="docstring-binding" href="#MacroModelling.get_corr"><code>MacroModelling.get_corr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>get_correlation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2496-L2498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_correlation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_correlation(
    ùìÇ;
    parameters,
    steady_state_function,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the correlations of endogenous variables using the first, pruned second, or pruned third order perturbation solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows and columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_correlation(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   ùëâùëéùëüùëñùëéùëèùëôùëíùë† ‚àà 4-element Vector{Symbol}
And data, 4√ó4 Matrix{Float64}:
        (:c)       (:k)       (:q)       (:z)
  (:c)   1.0        0.999812   0.550168   0.314562
  (:k)   0.999812   1.0        0.533879   0.296104
  (:q)   0.550168   0.533879   1.0        0.965726
  (:z)   0.314562   0.296104   0.965726   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_cov"><a class="docstring-binding" href="#MacroModelling.get_cov"><code>MacroModelling.get_cov</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3229-L3231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_covariance-Tuple"><a class="docstring-binding" href="#MacroModelling.get_covariance-Tuple"><code>MacroModelling.get_covariance</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>covariance = true</code> and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false, derivatives = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3223-L3225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_dynamic_auxiliary_variables-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_dynamic_auxiliary_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_dynamic_auxiliary_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dynamic_auxiliary_variables(ùìÇ)
</code></pre><p>Returns the auxiliary variables, without timing subscripts, part of the augmented system of equations describing the model dynamics. Augmented means that, in case of variables with leads or lags larger than 1, or exogenous shocks with leads or lags, the system is augemented by auxiliary variables containing variables or shocks in lead or lag. Because the original equations included variables with leads or lags certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxiliary variable is created for <code>c/q</code>).</p><p>See <code>get_dynamic_equations</code> for more details on the auxiliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the auxiliary parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_dynamic_auxiliary_variables(RBC)
# output
3-element Vector{String}:
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_dynamic_equations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_dynamic_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_dynamic_equations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dynamic_equations(ùìÇ; filter)
</code></pre><p>Return the augmented system of equations describing the model dynamics. Augmented means that, when variables have leads or lags with absolute value larger than 1, or exogenous shocks have leads or lags, auxiliary equations containing lead/lag variables are added. The augmented system contains only variables in the present <code>[0]</code>, future <code>[1]</code>, or past <code>[-1]</code>. For example, <code>Œîk_4q[0] = log(k[0]) - log(k[-3])</code> contains <code>k[-3]</code>. Introducing two auxiliary variables (<code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ</code> and <code>k·¥∏‚ÅΩ‚Åª¬≤‚Åæ</code>, where <code>·¥∏</code> denotes the lead/lag operator) and augmenting the system with <code>k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[0] = k·¥∏‚ÅΩ‚Åª¬π‚Åæ[-1]</code> and <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] = k[-1]</code> ensures that all timing indices have absolute value at most 1: <code>Œîk_4q[0] - (log(k[0]) - log(k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[-1]))</code>.</p><p>In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in example).</p><p>Note that the output assumes the equations are equal to 0. As in, <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1]</code> implies <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1] = 0</code> and therefore: <code>k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] = k[-1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the dynamic model equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_dynamic_equations(RBC)
# output
12-element Vector{String}:
 &quot;1 / c[0] - (Œ≤ / c[1]) * (Œ± * ex&quot; ‚ãØ 25 bytes ‚ãØ &quot; - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))&quot;
 &quot;(c[0] + k[0]) - ((1 - exp(z{Œ¥}[0]) * Œ¥) * k[-1] + q[0])&quot;
 &quot;q[0] - exp(z{TFP}[0]) * k[-1] ^ Œ±&quot;
 &quot;eps_news{TFP}[0] - eps_news{TFP}[x]&quot;
 &quot;z{TFP}[0] - (œÅ{TFP} * z{TFP}[-1] + œÉ{TFP} * (eps{TFP}[x] + eps_news{TFP}[-1]))&quot;
 &quot;eps_news{Œ¥}[0] - eps_news{Œ¥}[x]&quot;
 &quot;z{Œ¥}[0] - (œÅ{Œ¥} * z{Œ¥}[-1] + œÉ{Œ¥} * (eps{Œ¥}[x] + eps_news{Œ¥}[-1]))&quot;
 &quot;Œîc_share[0] - (log(c[0] / q[0]) - log(c[-1] / q[-1]))&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ[0] - k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[-1]&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ[0] - k·¥∏‚ÅΩ‚Åª¬π‚Åæ[-1]&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ[0] - k[-1]&quot;
 &quot;Œîk_4q[0] - (log(k[0]) - log(k·¥∏‚ÅΩ‚Åª¬≥‚Åæ[-1]))&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_equations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_equations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_equations(ùìÇ; filter)
</code></pre><p>Return the equations of the model. In case programmatic model writing was used this function returns the parsed equations (see loop over shocks in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parsed equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_equations(RBC)
# output
7-element Vector{String}:
 &quot;1 / c[0] = (Œ≤ / c[1]) * (Œ± * ex&quot; ‚ãØ 25 bytes ‚ãØ &quot; - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))&quot;
 &quot;c[0] + k[0] = (1 - exp(z{Œ¥}[0]) * Œ¥) * k[-1] + q[0]&quot;
 &quot;q[0] = exp(z{TFP}[0]) * k[-1] ^ Œ±&quot;
 &quot;z{TFP}[0] = œÅ{TFP} * z{TFP}[-1]&quot; ‚ãØ 18 bytes ‚ãØ &quot;TFP}[x] + eps_news{TFP}[x - 1])&quot;
 &quot;z{Œ¥}[0] = œÅ{Œ¥} * z{Œ¥}[-1] + œÉ{Œ¥} * (eps{Œ¥}[x] + eps_news{Œ¥}[x - 1])&quot;
 &quot;Œîc_share[0] = log(c[0] / q[0]) - log(c[-1] / q[-1])&quot;
 &quot;Œîk_4q[0] = log(k[0]) - log(k[-4])&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_estimated_shocks-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.get_estimated_shocks-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_shocks</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_estimated_shocks(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the estimated shocks based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. By default MacroModelling chooses the Kalman filter for first order solutions and the inversion filter for higher order ones, and only enables smoothing when the Kalman filter is used. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with shocks in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_shocks(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Shocks ‚àà 1-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 1√ó40 Matrix{Float64}:
               (1)          (2)         (3)         (4)         ‚Ä¶  (37)         (38)        (39)         (40)
  (:eps_z‚Çç‚Çì‚Çé)    0.0603617    0.614652   -0.519048    0.711454       -0.873774     1.27918    -0.929701    -0.2255</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.get_estimated_variable_standard_deviations-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variable_standard_deviations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_estimated_variable_standard_deviations(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    data_in_levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the standard deviations of the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) estimates of the model variables based on the provided data and first order solution of the model. For the default settings this function relies on the Kalman filter and therefore keeps smoothing enabled. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with standard deviations in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_variable_standard_deviations(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Standard_deviations ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó40 Matrix{Float64}:
        (1)           (2)            (3)            (4)            ‚Ä¶  (38)            (39)            (40)
  (:c)    1.23202e-9    1.84069e-10    8.23181e-11    8.23181e-11        8.23181e-11     8.23181e-11     0.0
  (:k)    0.00509299    0.000382934    2.87922e-5     2.16484e-6         1.6131e-9       9.31323e-10     1.47255e-9
  (:q)    0.0612887     0.0046082      0.000346483    2.60515e-5         1.31709e-9      1.31709e-9      9.31323e-10
  (:z)    0.00961766    0.000723136    5.43714e-5     4.0881e-6          3.08006e-10     3.29272e-10     2.32831e-10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L510">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_estimated_variables-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.get_estimated_variables-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_estimated_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_estimated_variables(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the estimated variables (in levels by default, see <code>levels</code> keyword argument) based on the inversion filter (depending on the <code>filter</code> keyword argument), or Kalman filter or smoother (depending on the <code>smooth</code> keyword argument) using the provided data and (non-)linear solution of the model. With the default options the Kalman filter is applied to first order solutions, while the inversion filter is used for higher order methods; smoothing is activated automatically only when the Kalman filter is available. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_estimated_variables(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó40 Matrix{Float64}:
        (1)           (2)           (3)           (4)          ‚Ä¶  (37)          (38)            (39)           (40)
  (:c)    5.92901       5.92797       5.92847       5.92048          5.95845       5.95697         5.95686        5.96173
  (:k)   47.3185       47.3087       47.3125       47.2392          47.6034       47.5969         47.5954        47.6402
  (:q)    6.87159       6.86452       6.87844       6.79352          7.00476       6.9026          6.90727        6.95841
  (:z)   -0.00109471   -0.00208056    4.43613e-5   -0.0123318        0.0162992     0.000445065     0.00119089     0.00863586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_fevd"><a class="docstring-binding" href="#MacroModelling.get_fevd"><code>MacroModelling.get_fevd</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2227-L2229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_first_order_solution-Tuple"><a class="docstring-binding" href="#MacroModelling.get_first_order_solution-Tuple"><code>MacroModelling.get_first_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :first_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1846-L1848">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_forecast_error_variance_decomposition"><a class="docstring-binding" href="#MacroModelling.get_forecast_error_variance_decomposition"><code>MacroModelling.get_forecast_error_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2233-L2235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_girf-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_girf-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_girf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a> with <code>generalised_irf = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1378-L1380">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><a class="docstring-binding" href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ;
    periods,
    algorithm,
    parameters,
    steady_state_function,
    variables,
    shocks,
    negative_shock,
    generalised_irf,
    generalised_irf_warmup_iterations,
    generalised_irf_draws,
    initial_state,
    levels,
    shock_size,
    ignore_obc,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return impulse response functions (IRFs) of the model. By default, the values represent absolute deviations from the relevant steady state (see <code>levels</code> for details). The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions.</p><p>If the model contains occasionally binding constraints and <code>ignore_obc = false</code> they are enforced using shocks.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: if true, calculates IRFs for a negative shock. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear (higher order perturbation) solutions only. Reference steady state for deviations is the stochastic steady state. <code>initial_state</code> has no effect on generalised IRFs. Occasionally binding constraint are not respected for generalised IRF.</li><li><code>generalised_irf_warmup_iterations</code> [Default: <code>100</code>, Type: <code>Int</code>]: number of warm-up iterations used to draw the baseline paths in the generalised IRF simulation. Only applied when <code>generalised_irf = true</code>.</li><li><code>generalised_irf_draws</code> [Default: <code>50</code>, Type: <code>Int</code>]: number of Monte Carlo draws used to compute the generalised IRF. Only applied when <code>generalised_irf = true</code>.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>shock_size</code> [Default: <code>1</code>, Type: <code>Real</code>]: size of the shocks in standard deviations. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>. A negative value will flip the sign of the shock.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, periods in columns, and shocks as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_irf(RBC)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
‚ó™   Shocks ‚àà 1-element Vector{Symbol}
And data, 4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :eps_z):
        (1)           (2)           ‚Ä¶  (39)            (40)
  (:c)    0.00674687    0.00729773        0.00146962      0.00140619
  (:k)    0.0620937     0.0718322         0.0146789       0.0140453
  (:q)    0.0688406     0.0182781         0.00111425      0.00106615
  (:z)    0.01          0.002             2.74878e-29     5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_irf-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, Vector{S}}} where S&lt;:Real"><a class="docstring-binding" href="#MacroModelling.get_irf-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, Vector{S}}} where S&lt;:Real"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ,
    parameters;
    steady_state_function,
    periods,
    variables,
    shocks,
    negative_shock,
    initial_state,
    levels,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm
)
</code></pre><p>Return impulse response functions (IRFs) of the model. Function to use when differentiating IRFs with respect to parameters.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameters</code> [Type: <code>Vector</code>]: Parameter values in alphabetical order (sorted by parameter name).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: if true, calculates IRFs for a negative shock. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: The initial state defines the starting point for the model (in levels, not deviations). The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1)</code> returns a <code>KeyedArray</code> with all variables. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{&lt;:AbstractFloat, 3}</code> with variables in rows, periods in columns, and shocks as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_irf(RBC, RBC.parameter_values)
# output
4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] =
 0.00674687  0.00729773  0.00715114  0.00687615  ‚Ä¶  0.00146962   0.00140619
 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453
 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615
 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1001">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_irfs"><a class="docstring-binding" href="#MacroModelling.get_irfs"><code>MacroModelling.get_irfs</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1338-L1340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_jump_variables-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_jump_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_jump_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jump_variables(ùìÇ)
</code></pre><p>Returns the jump variables of the model. Jump variables occur in the future and not in the past or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the jump variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_jump_variables(RBC)
# output
3-element Vector{String}:
 &quot;c&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L1028">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_loglikelihood-Union{Tuple{U}, Tuple{S}, Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}, Vector{S}}} where {S&lt;:Real, U&lt;:AbstractFloat}"><a class="docstring-binding" href="#MacroModelling.get_loglikelihood-Union{Tuple{U}, Tuple{S}, Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}, Vector{S}}} where {S&lt;:Real, U&lt;:AbstractFloat}"><code>MacroModelling.get_loglikelihood</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_loglikelihood(
    ùìÇ,
    data,
    parameter_values;
    steady_state_function,
    algorithm,
    filter,
    on_failure_loglikelihood,
    warmup_iterations,
    presample_periods,
    initial_covariance,
    filter_algorithm,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm,
    sylvester_algorithm,
    verbose
)
</code></pre><p>Return the loglikelihood of the model given the data and parameters provided. The loglikelihood is either calculated based on the inversion or the Kalman filter (depending on the <code>filter</code> keyword argument). By default the package selects the Kalman filter for first order solutions and the inversion filter for nonlinear (higher order) solution algorithms. The data must be provided as a <code>KeyedArray{Float64}</code> with the names of the variables to be matched in rows and the periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</p><p>This function is differentiable (so far for the Kalman filter only) and can be used in gradient based sampling or optimisation.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>presample_periods</code> [Default: <code>0</code>, Type: <code>Int</code>]: periods at the beginning of the data for which the loglikelihood is discarded.</li><li><code>initial_covariance</code> [Default: <code>:theoretical</code>, Type: <code>Symbol</code>]: defines the method to initialise the Kalman filters covariance matrix. It can be initialised with the theoretical long run values (option <code>:theoretical</code>) or large values (10.0) along the diagonal (option <code>:diagonal</code>).</li><li><code>on_failure_loglikelihood</code> [Default: <code>-Inf</code>, Type: <code>AbstractFloat</code>]: value to return if the loglikelihood calculation fails. Setting this to a finite value can avoid errors in codes that rely on finite loglikelihood values, such as e.g. slice samplers (in Pigeons.jl).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>&lt;:AbstractFloat</code> loglikelihood </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulated_data = simulate(RBC)

get_loglikelihood(RBC, simulated_data([:k], :, :simulate), RBC.parameter_values)
# output
58.24780188977981</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_mean-Tuple"><a class="docstring-binding" href="#MacroModelling.get_mean-Tuple"><code>MacroModelling.get_mean</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>mean = true</code>, and <code>non_stochastic_steady_state = false, variance = false, standard_deviation = false, covariance = false</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3241-L3243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_missing_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_missing_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_missing_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_missing_parameters(ùìÇ)
</code></pre><p>Returns the parameters which are required by the model but have not been assigned values in the <code>@parameters</code> block. These parameters must be provided via the <code>parameters</code> keyword argument in functions like <code>get_irf</code>, <code>get_SS</code>, <code>simulate</code>, etc. before the model can be solved.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the missing parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_incomplete begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC_incomplete begin
    std_z = 0.01
    œÅ = 0.2
    # Note: Œ±, Œ≤, Œ¥ are not defined
end

get_missing_parameters(RBC_incomplete)
# output
3-element Vector{String}:
 &quot;Œ±&quot;
 &quot;Œ≤&quot;
 &quot;Œ¥&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L495">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.get_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_model_estimates</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_model_estimates(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    warmup_iterations,
    data_in_levels,
    levels,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the vertical concatenation of <code>get_estimated_variables</code> and <code>get_estimated_shocks</code> as a single <code>KeyedArray</code> with a common first axis named <code>Estimates</code> and the second axis <code>Periods</code>. Variables appear first, followed by shocks.</p><p>All keyword arguments are forwarded to the respective functions. See the docstrings of <code>get_estimated_variables</code> and <code>get_estimated_shocks</code> for details.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: return levels or absolute deviations from the relevant steady state corresponding to the solution algorithm (e.g. stochastic steady state for higher order solution algorithms).</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables followed by shocks in rows, and periods in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_model_estimates(RBC,simulation([:c],:,:simulate))
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_shocks ‚àà 5-element Vector{Symbol}
‚Üí   Periods ‚àà 40-element UnitRange{Int64}
And data, 5√ó40 Matrix{Float64}:
               (1)          (2)           (3)           (4)          ‚Ä¶  (37)           (38)           (39)           (40)
  (:c)           5.94335      5.94676       5.94474       5.95135          5.93773        5.94333        5.94915        5.95473
  (:k)          47.4603      47.4922       47.476        47.5356          47.4079        47.4567        47.514         47.5696
  (:q)           6.89873      6.92782       6.87844       6.96043          6.85055        6.9403         6.95556        6.96064
  (:z)           0.0014586    0.00561728   -0.00189203    0.0101896       -0.00543334     0.00798437     0.00968602     0.00981981
  (:eps_z‚Çç‚Çì‚Çé)    0.12649      0.532556     -0.301549      1.0568     ‚Ä¶    -0.746981       0.907104       0.808914       0.788261</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_model_structure-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_model_structure-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_model_structure</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_model_structure(ùìÇ::‚Ñ≥)</code></pre><p>Return cached model structure information (SS<em>and</em>pars<em>names, all</em>variables, NSSS_labels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L3561-L3565">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_moments</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_moments(
    ùìÇ;
    parameters,
    steady_state_function,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    variables,
    derivatives,
    parameter_derivatives,
    algorithm,
    silent,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the first and second moments of endogenous variables using the first, pruned second, or pruned third order perturbation solution. By default returns: non-stochastic steady state (NSSS), and standard deviations, but can optionally return variances, and covariance matrix. Derivatives of the moments (except for covariance) can also be provided by setting <code>derivatives</code> to <code>true</code>.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>non_stochastic_steady_state</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return SS of endogenous variables</li><li><code>mean</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return mean of endogenous variables (the mean for the linearised solutoin is the NSSS)</li><li><code>standard_deviation</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return standard deviation of endogenous variables</li><li><code>variance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return variance of endogenous variables</li><li><code>covariance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return covariance matrix of endogenous variables</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Symbol,KeyedArray}</code> containing the selected moments. All moments have variables as rows and the moment as the first column followed by partial derivatives wrt parameters. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

moments = get_moments(RBC);

moments[:non_stochastic_steady_state]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre><pre><code class="language-julia hljs">moments[:standard_deviation]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Standard_deviation)  (:std_z)  ‚Ä¶  (:Œ¥)       (:Œ±)       (:Œ≤)
  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789
  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323
  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08
  (:z)   0.0102062              1.02062      0.0        0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2646">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_non_stochastic_steady_state-Tuple"><a class="docstring-binding" href="#MacroModelling.get_non_stochastic_steady_state-Tuple"><code>MacroModelling.get_non_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1630-L1632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.‚Ñ≥, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><a class="docstring-binding" href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.‚Ñ≥, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>MacroModelling.get_non_stochastic_steady_state_residuals</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_non_stochastic_steady_state_residuals(
    ùìÇ,
    values;
    parameters,
    steady_state_function,
    tol,
    verbose
)
</code></pre><p>Calculate the residuals of the non-stochastic steady state equations of the model for a given set of values. Values not provided, will be filled with the non-stochastic steady state values corresponding to the current parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>values</code> [Type: <code>Union{Vector{Float64}, Dict{Symbol, Float64}, Dict{String, Float64}, KeyedArray{Float64, 1}}</code>]: A Vector, Dict, or KeyedArray containing the values of the variables and calibrated parameters in the non-stochastic steady state equations (including calibration equations). The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) containing the absolute values of the residuals of the non-stochastic steady state equations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    k[ss] / q[ss] = 2.5 | Œ±
    Œ≤ = 0.95
end

steady_state = SS(RBC, derivatives = false)

get_non_stochastic_steady_state_residuals(RBC, steady_state)
# output
1-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Equation ‚àà 5-element Vector{Symbol}
And data, 5-element Vector{Float64}:
 (:Equation‚ÇÅ)             0.0
 (:Equation‚ÇÇ)             0.0
 (:Equation‚ÇÉ)             0.0
 (:Equation‚ÇÑ)             0.0
 (:CalibrationEquation‚ÇÅ)  0.0

get_non_stochastic_steady_state_residuals(RBC, [1.1641597, 3.0635781, 1.2254312, 0.0, 0.18157895])
# output
1-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Equation ‚àà 5-element Vector{Symbol}
And data, 5-element Vector{Float64}:
 (:Equation‚ÇÅ)             2.7360991250446887e-10
 (:Equation‚ÇÇ)             6.199999980083248e-8
 (:Equation‚ÇÉ)             2.7897102183871425e-8
 (:Equation‚ÇÑ)             0.0
 (:CalibrationEquation‚ÇÅ)  8.160392850342646e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3677">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_nonnegativity_auxiliary_variables-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_nonnegativity_auxiliary_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_nonnegativity_auxiliary_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nonnegativity_auxiliary_variables(ùìÇ)
</code></pre><p>Returns the auxiliary variables, without timing subscripts, added to the non-stochastic steady state problem because certain expression cannot be negative (e.g. given <code>log(c/q)</code> an auxiliary variable is created for <code>c/q</code>).</p><p>See <code>get_steady_state_equations</code> for more details on the auxiliary variables and equations.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the auxiliary parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_nonnegativity_auxiliary_variables(RBC)
# output
2-element Vector{String}:
 &quot;‚ûï‚ÇÅ&quot;
 &quot;‚ûï‚ÇÇ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_parameters(ùìÇ; values)
</code></pre><p>Returns the parameters (and optionally the values) which have an impact on the model dynamics but do not depend on other parameters and are not determined by calibration equations. </p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>œÉ</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>values</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return the values together with the parameter names.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters or <code>Vector{Pair{String, Float64}}</code> of parameters and values if <code>values</code> is set to <code>true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters(RBC)
# output
7-element Vector{String}:
 &quot;œÉ{TFP}&quot;
 &quot;œÉ{Œ¥}&quot;
 &quot;œÅ{TFP}&quot;
 &quot;œÅ{Œ¥}&quot;
 &quot;capital_to_output&quot;
 &quot;alpha&quot;
 &quot;Œ≤&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_parameters_defined_by_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_defined_by_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_parameters_defined_by_parameters(ùìÇ)
</code></pre><p>Returns the parameters which are defined by other parameters which are not necessarily used in the equations of the model (see <code>Œ±</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_defined_by_parameters(RBC)
# output
1-element Vector{String}:
 &quot;Œ±&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L625">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_parameters_defining_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_defining_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_parameters_defining_parameters(ùìÇ)
</code></pre><p>Returns the parameters which define other parameters in the <code>@parameters</code> block which are not necessarily used in the equations of the model (see <code>alpha</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_defining_parameters(RBC)
# output
1-element Vector{String}:
 &quot;alpha&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L671">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_parameters_in_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_parameters_in_equations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_parameters_in_equations(ùìÇ)
</code></pre><p>Returns the parameters contained in the model equations. Note that these parameters might be determined by other parameters or calibration equations defined in the <code>@parameters</code> block.</p><p>In case programmatic model writing was used this function returns the parsed parameters (see <code>œÉ</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_parameters_in_equations(RBC)
# output
7-element Vector{String}:
 &quot;Œ±&quot;
 &quot;Œ≤&quot;
 &quot;Œ¥&quot;
 &quot;œÅ{TFP}&quot;
 &quot;œÅ{Œ¥}&quot;
 &quot;œÉ{TFP}&quot;
 &quot;œÉ{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L571">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_perturbation_solution-Tuple"><a class="docstring-binding" href="#MacroModelling.get_perturbation_solution-Tuple"><code>MacroModelling.get_perturbation_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1861-L1863">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_residuals"><a class="docstring-binding" href="#MacroModelling.get_residuals"><code>MacroModelling.get_residuals</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_non_stochastic_steady_state_residuals-Tuple{MacroModelling.‚Ñ≥, Union{Dict{String, Float64}, Dict{Symbol, Float64}, KeyedArray{Float64, 1}, Vector{Float64}}}"><code>get_non_stochastic_steady_state_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3795-L3797">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_second_order_solution-Tuple"><a class="docstring-binding" href="#MacroModelling.get_second_order_solution-Tuple"><code>MacroModelling.get_second_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :second_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1851-L1853">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_shock_decomposition-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.get_shock_decomposition-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.get_shock_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_shock_decomposition(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    data_in_levels,
    warmup_iterations,
    smooth,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the shock decomposition in absolute deviations from the relevant steady state. The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. The deviations are based on the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) or inversion filter using the provided data and solution of the model. When the defaults are used, the filter is selected automatically‚ÄîKalman for first order solutions and inversion otherwise‚Äîand smoothing is only enabled when the Kalman filter is active. Data is by default assumed to be in levels unless <code>data_in_levels</code> is set to <code>false</code>.</p><p>In case of pruned second and pruned third order perturbation algorithms the decomposition additionally contains a term <code>Nonlinearities</code>. This term represents the nonlinear interaction between the states in the periods after the shocks arrived and in the case of pruned third order, the interaction between (pruned second order) states and contemporaneous shocks.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, shocks in columns, and periods as the third dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

simulation = simulate(RBC)

get_shock_decomposition(RBC,simulation([:c],:,:simulate))
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
‚ó™   Periods ‚àà 40-element UnitRange{Int64}
And data, 4√ó2√ó40 Array{Float64, 3}:
[showing 3 of 40 slices]
[:, :, 1] ~ (:, :, 1):
        (:eps_z‚Çç‚Çì‚Çé)   (:Initial_values)
  (:c)   0.000407252  -0.00104779
  (:k)   0.00374808   -0.0104645
  (:q)   0.00415533   -0.000807161
  (:z)   0.000603617  -1.99957e-6

[:, :, 21] ~ (:, :, 21):
        (:eps_z‚Çç‚Çì‚Çé)  (:Initial_values)
  (:c)   0.026511    -0.000433619
  (:k)   0.25684     -0.00433108
  (:q)   0.115858    -0.000328764
  (:z)   0.0150266    0.0

[:, :, 40] ~ (:, :, 40):
        (:eps_z‚Çç‚Çì‚Çé)  (:Initial_values)
  (:c)   0.0437976   -0.000187505
  (:k)   0.4394      -0.00187284
  (:q)   0.00985518  -0.000142164
  (:z)  -0.00366442   8.67362e-19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_shocks-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_shocks-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_shocks</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_shocks(ùìÇ)
</code></pre><p>Returns the exogenous shocks.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>eps</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the exogenous shocks.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_shocks(RBC)
# output
4-element Vector{String}:
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{Œ¥}&quot;
 &quot;eps{TFP}&quot;
 &quot;eps{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_simulation-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_simulation-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_simulation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1368-L1370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_simulations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_simulations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_simulations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1373-L1375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_solution(
    ùìÇ;
    parameters,
    steady_state_function,
    algorithm,
    silent,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the solution of the model. In the linear case it returns the non-stochastic steady state (NSSS) followed by the linearised solution of the model. In the nonlinear case (higher order perturbation) the function returns a multidimensional array with the endogenous variables as the second dimension and the state variables, shocks, and perturbation parameter (:Volatility) as the other dimensions.</p><p>The values of the output represent the NSSS in the case of a linear solution and below it the effect that deviations from the NSSS of the respective past states, shocks, and perturbation parameter have (perturbation parameter = 1) on the present value (NSSS deviation) of the model variables.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with the endogenous variables including the auxiliary endogenous and exogenous variables (due to leads and lags &gt; 1) as columns. The rows and other dimensions (depending on the chosen perturbation order) include the NSSS for the linear case only, followed by the states, and exogenous shocks. Subscripts following variable names indicate the timing (e.g. <code>variable‚Çç‚Çã‚ÇÅ‚Çé</code>  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. <code>variable·¥∏‚ÅΩ¬≤‚Åæ</code> indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_solution(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Steady_state__States__Shocks ‚àà 4-element Vector{Symbol}
‚Üí   Variables ‚àà 4-element Vector{Symbol}
And data, 4√ó4 adjoint(::Matrix{Float64}) with eltype Float64:
                   (:c)         (:k)        (:q)        (:z)
  (:Steady_state)   5.93625     47.3903      6.88406     0.0
  (:k‚Çç‚Çã‚ÇÅ‚Çé)          0.0957964    0.956835    0.0726316  -0.0
  (:z‚Çç‚Çã‚ÇÅ‚Çé)          0.134937     1.24187     1.37681     0.2
  (:eps_z‚Çç‚Çì‚Çé)       0.00674687   0.0620937   0.0688406   0.01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1689">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_solution-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, Vector{S}}} where S&lt;:Real"><a class="docstring-binding" href="#MacroModelling.get_solution-Union{Tuple{S}, Tuple{MacroModelling.‚Ñ≥, Vector{S}}} where S&lt;:Real"><code>MacroModelling.get_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_solution(
    ùìÇ,
    parameters;
    steady_state_function,
    algorithm,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the components of the solution of the model: non-stochastic steady state (NSSS), and solution martrices corresponding to the order of the solution. Note that all returned objects have the variables in rows and the solution matrices have as columns the state variables followed by the perturbation/volatility parameter for higher order solution matrices and lastly the exogenous shocks. Higher order perturbation matrices are sparse and have the Kronecker product of the forementioned elements as columns. The last element, a Boolean indicates whether the solution is numerically accurate. Function to use when differentiating IRFs with respect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code> consisting of a <code>Vector</code> containing the NSSS, followed by a <code>Matrix</code> containing the first order solution matrix. In case of higher order solutions, <code>SparseMatrixCSC</code> represent the higher order solution matrices. The last element is a <code>Bool</code> indicating the correctness of the solution provided.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_solution(RBC, RBC.parameter_values)
# output
([5.936252888048724, 47.39025414828808, 6.884057971014486, 0.0], 
 [0.09579643002421227 0.1349373930517757 0.006746869652588215; 
  0.9568351489231555 1.241874201151121 0.06209371005755664; 
  0.07263157894736819 1.376811594202897 0.06884057971014486; 
  0.0 0.19999999999999998 0.01], true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1869">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_solution_counts-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_solution_counts-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_solution_counts</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_solution_counts(ùìÇ)
</code></pre><p>Return the solve counters struct for the model.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_ss"><a class="docstring-binding" href="#MacroModelling.get_ss"><code>MacroModelling.get_ss</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1676-L1678">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_standard_deviation-Tuple"><a class="docstring-binding" href="#MacroModelling.get_standard_deviation-Tuple"><code>MacroModelling.get_standard_deviation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3195-L3197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_state_variables-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_state_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_state_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_state_variables(ùìÇ)
</code></pre><p>Returns the state variables of the model. State variables occur in the past and not in the future or occur in all three: past, present, and future.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in example).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the state variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_state_variables(RBC)
# output
10-element Vector{String}:
 &quot;c&quot;
 &quot;eps_news{TFP}&quot;
 &quot;eps_news{Œ¥}&quot;
 &quot;k&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≤‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬≥‚Åæ&quot;
 &quot;k·¥∏‚ÅΩ‚Åª¬π‚Åæ&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L970">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_statistics-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><a class="docstring-binding" href="#MacroModelling.get_statistics-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MacroModelling.get_statistics</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_statistics(
    ùìÇ,
    parameter_values;
    parameters,
    steady_state_function,
    non_stochastic_steady_state,
    mean,
    standard_deviation,
    variance,
    covariance,
    autocorrelation,
    autocorrelation_periods,
    algorithm,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm,
    verbose,
    tol
)
</code></pre><p>Return the first and second moments of endogenous variables using either the linearised solution or the pruned second or pruned third order perturbation solution. By default returns a <code>Dict</code> with: non-stochastic steady state (NSSS), and standard deviations, but can also return variances, and covariance matrix. Values are returned in the order given for the specific moment. Function to use when differentiating model moments with respect to parameters.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>parameter_values</code> [Type: <code>Vector</code>]: Parameter values. If <code>parameter_names</code> is not explicitly defined, <code>parameter_values</code> are assumed to correspond to the parameters and the order of the parameters declared in the <code>@parameters</code> block.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Type: <code>Vector{Symbol}</code>]: Corresponding names in the same order as <code>parameter_values</code>.</li><li><code>non_stochastic_steady_state</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the NSSS of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>mean</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the mean of selected variables (the mean for the linearised solution is the NSSS). Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>standard_deviation</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the standard deviation of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>variance</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the variance of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>covariance</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the covariance of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. For grouped covariance computation, pass a <code>Vector</code> of <code>Vector</code>s (e.g. <code>[[:y, :c], [:k, :i]]</code>) to compute covariances only within each group, returning a single covariance matrix where cross-group covariances are set to zero. This allows more granular control over which covariances to compute. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all variables less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all variables less those related to occasionally binding constraints. <code>:all</code> will contain all variables.</li><li><code>autocorrelation</code> [Default: <code>Symbol[]</code>, Type: <code>Union{Symbol_input,String_input}</code>]: variables for which to show the autocorrelation of selected variables. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>:all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>:all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>:all</code> will contain all variables.</li><li><code>autocorrelation_periods</code> [Default: <code>1:5</code>, Type = <code>UnitRange{Int}</code>]: periods for which to return the autocorrelation of selected variables</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code> with the name of the statistics and the corresponding vectors (NSSS, mean, standard deviation, variance) or matrices (covariance, autocorrelation).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_statistics(RBC, RBC.parameter_values, parameters = get_parameters(RBC), standard_deviation = RBC.var)
# output
Dict{Symbol, AbstractArray{Float64}} with 1 entry:
  :standard_deviation =&gt; [0.0266642, 0.264677, 0.0739325, 0.0102062]

# For grouped covariance (computing covariances only within specified groups):
get_statistics(RBC, RBC.parameter_values, covariance = [[:c, :k], [:y, :i]])
# output
Dict{Symbol, AbstractArray{Float64}} with 1 entry:
  :covariance =&gt; [...4x4 matrix with c-k covariances filled, y-i covariances filled, and cross-group elements set to zero...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_std"><a class="docstring-binding" href="#MacroModelling.get_std"><code>MacroModelling.get_std</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3201-L3203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_stdev"><a class="docstring-binding" href="#MacroModelling.get_stdev"><code>MacroModelling.get_stdev</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3206-L3208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_steady_state(
    ùìÇ;
    parameters,
    steady_state_function,
    derivatives,
    stochastic,
    algorithm,
    parameter_derivatives,
    return_variables_only,
    verbose,
    silent,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Return the (non-stochastic) steady state, calibrated parameters, and derivatives with respect to model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives with respect to the parameters.</li><li><code>parameter_derivatives</code> [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be a parameter name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:alpha</code>, or &quot;alpha&quot;), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> will include all parameters.</li><li><code>stochastic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return stochastic steady state using second order perturbation if no other higher order perturbation algorithm is provided in <code>algorithm</code>.</li><li><code>return_variables_only</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return only variables and not calibrated parameters.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows. The columns show the (non-stochastic) steady state and parameters for which derivatives are taken. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

get_steady_state(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_calibrated_parameters ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_steady_state_equations-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_steady_state_equations-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_steady_state_equations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_steady_state_equations(ùìÇ; filter)
</code></pre><p>Return the non-stochastic steady state (NSSS) equations of the model. The difference to the equations as they were written in the <code>@model</code> block is that exogenous shocks are set to <code>0</code>, time subscripts are eliminated (e.g. <code>c[-1]</code> becomes <code>c</code>), trivial simplifications are carried out (e.g. <code>log(k) - log(k) = 0</code>), and auxiliary variables are added for expressions that cannot become negative. </p><p>Auxiliary variables facilitate the solution of the NSSS problem. The package substitutes expressions which cannot become negative with auxiliary variables and adds another equation to the system of equations determining the NSSS. For example, <code>log(c/q)</code> cannot be negative and <code>c/q</code> is substituted by an auxiliary variable <code>‚ûï‚ÇÅ</code> and an additional equation is added: <code>‚ûï‚ÇÅ = c / q</code>.</p><p>Note that the output assumes the equations are equal to 0. As in, <code>-z{Œ¥} * œÅ{Œ¥} + z{Œ¥}</code> implies <code>-z{Œ¥} * œÅ{Œ¥} + z{Œ¥} = 0</code> and therefore: <code>z{Œ¥} * œÅ{Œ¥} = z{Œ¥}</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the NSSS equations. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_steady_state_equations(RBC)
# output
9-element Vector{String}:
 &quot;(-Œ≤ * ((k ^ (Œ± - 1) * Œ± * exp(z{TFP}) - Œ¥ * exp(z{Œ¥})) + 1)) / c + 1 / c&quot;
 &quot;((c - k * (-Œ¥ * exp(z{Œ¥}) + 1)) + k) - q&quot;
 &quot;-(k ^ Œ±) * exp(z{TFP}) + q&quot;
 &quot;-z{TFP} * œÅ{TFP} + z{TFP}&quot;
 &quot;-z{Œ¥} * œÅ{Œ¥} + z{Œ¥}&quot;
 &quot;‚ûï‚ÇÅ - c / q&quot;
 &quot;‚ûï‚ÇÇ - c / q&quot;
 &quot;(Œîc_share - log(‚ûï‚ÇÅ)) + log(‚ûï‚ÇÇ)&quot;
 &quot;Œîk_4q - 0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_stochastic_steady_state-Tuple"><a class="docstring-binding" href="#MacroModelling.get_stochastic_steady_state-Tuple"><code>MacroModelling.get_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1636-L1638">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_third_order_solution-Tuple"><a class="docstring-binding" href="#MacroModelling.get_third_order_solution-Tuple"><code>MacroModelling.get_third_order_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a> with <code>algorithm = :third_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1856-L1858">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_var"><a class="docstring-binding" href="#MacroModelling.get_var"><code>MacroModelling.get_var</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3183-L3185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_var_decomp"><a class="docstring-binding" href="#MacroModelling.get_var_decomp"><code>MacroModelling.get_var_decomp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>get_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2386-L2388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_variables-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_variables-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_variables</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_variables(ùìÇ)
</code></pre><p>Returns the variables of the model without timing subscripts and not including auxiliary variables.</p><p>In case programmatic model writing was used this function returns the parsed variables (see <code>z</code> in <code>Examples</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code> of the variables.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z{TFP}[1]) * k[0]^(Œ± - 1) + (1 - exp(z{Œ¥}[1]) * Œ¥))
    c[0] + k[0] = (1 - exp(z{Œ¥}[0])Œ¥) * k[-1] + q[0]
    q[0] = exp(z{TFP}[0]) * k[-1]^Œ±
    for shock in [TFP, Œ¥]
        z{shock}[0] = œÅ{shock} * z{shock}[-1] + œÉ{shock} * (eps{shock}[x] + eps_news{shock}[x-1])
    end
    Œîc_share[0] = log(c[0]/q[0]) - log(c[-1]/q[-1])
    Œîk_4q[0] = log(k[0]) - log(k[-4])
end

@parameters RBC begin
    œÉ = 0.01
    œÅ = 0.2
    capital_to_output = 1.5
    k[ss] / (4 * q[ss]) = capital_to_output | Œ¥
    alpha = .5
    Œ± = alpha
    Œ≤ = 0.95
end

get_variables(RBC)
# output
7-element Vector{String}:
 &quot;c&quot;
 &quot;k&quot;
 &quot;q&quot;
 &quot;z{TFP}&quot;
 &quot;z{Œ¥}&quot;
 &quot;Œîc_share&quot;
 &quot;Œîk_4q&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L763">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_variance-Tuple"><a class="docstring-binding" href="#MacroModelling.get_variance-Tuple"><code>MacroModelling.get_variance</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3177-L3179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_variance_decomposition(
    ùìÇ;
    parameters,
    steady_state_function,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Return the variance decomposition of endogenous variables with regards to the shocks using the linearised solution. </p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>KeyedArray</code> (from the <code>AxisKeys</code> package) with variables in rows, and shocks in columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

get_variance_decomposition(RBC_CME)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 7-element Vector{Symbol}
‚Üí   Shocks ‚àà 2-element Vector{Symbol}
And data, 7√ó2 Matrix{Float64}:
              (:delta_eps)  (:eps_z)
  (:A)         9.78485e-31   1.0
  (:Pi)        0.0156771     0.984323
  (:R)         0.0156771     0.984323
  (:c)         0.0134672     0.986533
  (:k)         0.00869568    0.991304
  (:y)         0.000313462   0.999687
  (:z_delta)   1.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L2247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.has_missing_parameters-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.has_missing_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.has_missing_parameters</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_missing_parameters(ùìÇ)
</code></pre><p>Returns whether the model has missing parameters that need to be provided before solving.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> indicating whether the model has missing parameters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
end

has_missing_parameters(RBC)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.import_dynare"><a class="docstring-binding" href="#MacroModelling.import_dynare"><code>MacroModelling.import_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L131-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.import_model"><a class="docstring-binding" href="#MacroModelling.import_model"><code>MacroModelling.import_model</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L126-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.infer_step-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Number"><a class="docstring-binding" href="#MacroModelling.infer_step-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Number"><code>MacroModelling.infer_step</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">infer_step(x_axis)</code></pre><p>Infer the step for an axis.</p><p>For dates, if the last two points share the same day-of-month, the step is inferred in whole months (e.g. Month(1), Month(3), ‚Ä¶). Otherwise the raw difference is used. For non time types, uses the plain difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L1146-L1154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.parse_filter_term-Tuple{Union{String, Symbol}}"><a class="docstring-binding" href="#MacroModelling.parse_filter_term-Tuple{Union{String, Symbol}}"><code>MacroModelling.parse_filter_term</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_filter_term(term::Union{Symbol, String}) -&gt; (Symbol, Union{Expr, Nothing})</code></pre><p>Parse a filter term into (base<em>symbol, pattern</em>expr).</p><ul><li><code>:k</code> or <code>&quot;k&quot;</code> ‚Üí <code>(:k, nothing)</code> matches variable at any timing</li><li><code>&quot;k[-1]&quot;</code> ‚Üí <code>(:k, :(k[-1]))</code> matches exact timing</li><li><code>&quot;eps[x]&quot;</code> ‚Üí <code>(:eps, :(eps[x]))</code> matches shock at exact timing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L32-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.print_solution_counts-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.print_solution_counts-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.print_solution_counts</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_solution_counts(ùìÇ)
</code></pre><p>Print the solve counters for the model in a human-readable format.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/inspect.jl#L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.set_custom_steady_state_function!-Tuple{MacroModelling.‚Ñ≥, Union{Missing, Nothing, Function}}"><a class="docstring-binding" href="#MacroModelling.set_custom_steady_state_function!-Tuple{MacroModelling.‚Ñ≥, Union{Missing, Nothing, Function}}"><code>MacroModelling.set_custom_steady_state_function!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_custom_steady_state_function!(ùìÇ::‚Ñ≥, f::SteadyStateFunctionType)</code></pre><p><em>Internal function</em> - Set a custom function to calculate the steady state of the model.</p><p>This function is not exported. Users should instead pass the <code>steady_state_function</code> argument to functions like:</p><ul><li><code>get_irf(ùìÇ, steady_state_function = f)</code></li><li><code>get_steady_state(ùìÇ, steady_state_function = f)</code></li><li><code>simulate(ùìÇ, steady_state_function = f)</code></li></ul><p>This function allows users to provide their own steady state solver, which can be useful when:</p><ul><li>The default numerical solver has difficulty finding the steady state</li><li>An analytical solution for the steady state is known</li><li>A more efficient custom solver is available</li></ul><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: Model object</li><li><code>f</code>: A function that accepts either <code>(parameters)</code> or <code>(out, parameters)</code> and provides steady state values in the same order as <code>get_NSSS_and_parameters</code>: variables first, then calibrated parameters (if any).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: Print information about the variable and parameter ordering.</li></ul><p><strong>Details</strong></p><p>The custom function <code>f</code> can have either signature:</p><pre><code class="language-julia hljs">f(parameters::AbstractVector{&lt;:Real}) -&gt; AbstractVector{&lt;:Real}
f!(out::AbstractVector{&lt;:Real}, parameters::AbstractVector{&lt;:Real}) -&gt; Union{Nothing, AbstractVector{&lt;:Real}}</code></pre><p>When both signatures are applicable, the in-place signature is used.</p><p>Where:</p><ul><li>Input: Parameter values in the declaration order (as defined in <code>@parameters</code>). Parameter order is available from <code>get_parameters(ùìÇ)</code>.</li><li>Output: Steady state values in the same order as <code>get_NSSS_and_parameters</code>: variables in <code>sort(union(ùìÇ.constants.post_model_macro.var, ùìÇ.constants.post_model_macro.exo_past, ùìÇ.constants.post_model_macro.exo_future))</code>, followed by calibrated parameters in <code>ùìÇ.equations.calibration_parameters</code> (if any). For in-place functions, <code>out</code> is filled in this order.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

# Define a custom steady state function
# get_variables(RBC) returns [:c, :k, :q, :z] (sorted alphabetically)
# get_parameters(RBC) returns [:std_z, :œÅ, :Œ¥, :Œ±, :Œ≤] (in declaration order)
# Return values must match the order used by get_NSSS_and_parameters:
# variables in sort(union(RBC.var, RBC.exo_past, RBC.exo_future)), then any calibrated parameters.
function my_steady_state(params)
    std_z, œÅ, Œ¥, Œ±, Œ≤ = params
    
    # Analytical steady state
    k_ss = ((1/Œ≤ - 1 + Œ¥) / Œ±)^(1/(Œ± - 1))
    q_ss = k_ss^Œ±
    c_ss = q_ss - Œ¥ * k_ss
    z_ss = 0.0
    
    return [c_ss, k_ss, q_ss, z_ss]  # Order matches get_NSSS_and_parameters(RBC)
end

# Use with get_irf, get_steady_state, or simulate
get_irf(RBC, steady_state_function = my_steady_state)</code></pre><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p>See also: <a href="#MacroModelling.get_variables-Tuple{MacroModelling.‚Ñ≥}"><code>get_variables</code></a>, <a href="#MacroModelling.get_parameters-Tuple{MacroModelling.‚Ñ≥}"><code>get_parameters</code></a>, <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a>, <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a>, <a href="#MacroModelling.simulate-Tuple{MacroModelling.‚Ñ≥}"><code>simulate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L1030-L1108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.simulate-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.simulate-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.simulate</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a> with <code>shocks = :simulate</code>. Function returns values in levels by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1363-L1365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.ss-Tuple"><a class="docstring-binding" href="#MacroModelling.ss-Tuple"><code>MacroModelling.ss</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1681-L1683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.sss-Tuple"><a class="docstring-binding" href="#MacroModelling.sss-Tuple"><code>MacroModelling.sss</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1654-L1656">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.std"><a class="docstring-binding" href="#MacroModelling.std"><code>MacroModelling.std</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3218-L3220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.stdev"><a class="docstring-binding" href="#MacroModelling.stdev"><code>MacroModelling.stdev</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>standard_deviation = true</code> and <code>non_stochastic_steady_state = false, variance = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3212-L3214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.steady_state"><a class="docstring-binding" href="#MacroModelling.steady_state"><code>MacroModelling.steady_state</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L1666-L1668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.translate_dynare_file"><a class="docstring-binding" href="#MacroModelling.translate_dynare_file"><code>MacroModelling.translate_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>translate_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L121-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.translate_mod_file-Tuple{AbstractString}"><a class="docstring-binding" href="#MacroModelling.translate_mod_file-Tuple{AbstractString}"><code>MacroModelling.translate_mod_file</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">translate_mod_file(path_to_mod_file)
</code></pre><p>Reads in a <code>dynare</code> .mod-file, adapts the syntax, tries to capture parameter definitions, and writes a julia file in the same folder containing the model equations and parameters in <code>MacroModelling.jl</code> syntax. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>dynare</code> to <code>MacroModelling.jl</code>. </p><p>The recommended workflow is to use this function to translate a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p>Note that this function copies the .mod-file to a temporary folder and executes it there. All references within that .mod-file are therefore not valid (because those filesare not copied) and must be made copied into the .mod-file.</p><p><strong>Arguments</strong></p><ul><li><code>path_to_mod_file</code> [Type: <code>AbstractString</code>]: path including filename of the .mod-file to be translated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.update_perturbation_counter!-Tuple{MacroModelling.SolveCounters, Bool}"><a class="docstring-binding" href="#MacroModelling.update_perturbation_counter!-Tuple{MacroModelling.SolveCounters, Bool}"><code>MacroModelling.update_perturbation_counter!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_perturbation_counter!(counters::SolveCounters, solved::Bool; estimation::Bool = false, order::Int = 1)</code></pre><p>Updates the perturbation solve counters based on whether the solve was successful and the perturbation order. Always increments the total counter, and increments the failed counter if the solve failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L9702-L9707">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.update_ss_counter!-Tuple{MacroModelling.SolveCounters, Bool}"><a class="docstring-binding" href="#MacroModelling.update_ss_counter!-Tuple{MacroModelling.SolveCounters, Bool}"><code>MacroModelling.update_ss_counter!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_ss_counter!(counters::SolveCounters, solved::Bool; estimation::Bool = false)</code></pre><p>Updates the steady state solve counters based on whether the solve was successful. Always increments the total counter, and increments the failed counter if the solve failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/MacroModelling.jl#L9748-L9753">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.var"><a class="docstring-binding" href="#MacroModelling.var"><code>MacroModelling.var</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>get_moments</code></a> with <code>variance = true</code> and <code>non_stochastic_steady_state = false, standard_deviation = false, covariance = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/get_functions.jl#L3189-L3191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.write_dynare_file"><a class="docstring-binding" href="#MacroModelling.write_dynare_file"><code>MacroModelling.write_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L236-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.write_mod_file</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_mod_file(ùìÇ)
</code></pre><p>Writes a <code>dynare</code> .mod-file in the current working directory. This function is not guaranteed to produce working code. It&#39;s purpose is to make it easier to port a model from <code>MacroModelling.jl</code> to <code>dynare</code>. </p><p>The recommended workflow is to use this function to write a .mod-file, and then adapt the output so that it runs and corresponds to the input.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.write_to_dynare"><a class="docstring-binding" href="#MacroModelling.write_to_dynare"><code>MacroModelling.write_to_dynare</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L246-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.write_to_dynare_file"><a class="docstring-binding" href="#MacroModelling.write_to_dynare_file"><code>MacroModelling.write_to_dynare_file</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>See <a href="#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}"><code>write_mod_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/dynare.jl#L241-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.@model-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@model</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><p>Parses the model equations and assigns them to an object.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object to be created containing the model information.</li><li><code>ex</code>: equations</li></ul><p><strong>Optional arguments to be placed between <code>ùìÇ</code> and <code>ex</code></strong></p><ul><li><code>max_obc_horizon</code> [Default: <code>40</code>, Type: <code>Int</code>]: maximum length of anticipated shocks and corresponding unconditional forecast horizon over which the occasionally binding constraint is to be enforced. Increase this number if no solution is found to enforce the constraint.</li></ul><p>Variables must be defined with their time subscript in square brackets. Endogenous variables can have the following:</p><ul><li>present: <code>c[0]</code></li><li>non-stochastic steady state: <code>c[ss]</code> instead of <code>ss</code> any of the following is also a valid flag for the non-stochastic steady state: <code>ss</code>, <code>stst</code>, <code>steady</code>, <code>steadystate</code>, <code>steady_state</code>, and the parser is case-insensitive (<code>SS</code> or <code>sTst</code> will work as well).</li><li>past: <code>c[-1]</code> or any negative Integer: e.g. <code>c[-12]</code></li><li>future: <code>c[1]</code> or any positive Integer: e.g. <code>c[16]</code> or <code>c[+16]</code></li></ul><p>Signed integers are recognised and parsed as such.</p><p>Exogenous variables (shocks) can have the following:</p><ul><li>present: <code>eps_z[x]</code> instead of <code>x</code> any of the following is also a valid flag for exogenous variables: <code>ex</code>, <code>exo</code>, <code>exogenous</code>, and the parser is case-insensitive (<code>Ex</code> or <code>exoGenous</code> will work as well).</li><li>past: <code>eps_z[x-1]</code></li><li>future: <code>eps_z[x+1]</code></li></ul><p>Parameters enter the equations without square brackets.</p><p>If an equation contains a <code>max</code> or <code>min</code> operator, the default dynamic (first order) solution of the model will enforce the occasionally binding constraint. This enforcement can be disabled by setting <code>ignore_obc = true</code> in the relevant function calls.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Parameters and variables can be indexed using curly braces: e.g. <code>c{H}[0]</code>, <code>eps_z{F}[x]</code>, or <code>Œ±{H}</code>.</p><p><code>for</code> loops can be used to write models programmatically. They can either be used to generate expressions where the time index or the index in curly braces is iterated over:</p><ul><li>generate equation with different indices in curly braces: <code>for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end</code></li><li>generate multiple equations with different indices in curly braces: <code>for co in [H, F] K{co}[0] = (1-delta{co}) * K{co}[-1] + S{co}[0] end</code></li><li>generate equation with different time indices: <code>Y_annual[0] = for lag in -3:0 Y[lag] end</code> or <code>R_annual[0] = for operator = :*, lag in -3:0 R[lag] end</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>. The macro creates the model <code>ùìÇ</code> in the calling scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/macros.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>MacroModelling.@parameters</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><p>Adds parameter values and calibration equations to the previously defined model. Allows to provide an initial guess for the non-stochastic steady state (NSSS).</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object previously created containing the model information.</li><li><code>ex</code>: parameter, parameters values, and calibration equations</li></ul><p>Parameters can be defined in either of the following ways:</p><ul><li>plain number: <code>Œ¥ = 0.02</code></li><li>expression containing numbers: <code>Œ¥ = 1/50</code></li><li>expression containing other parameters: <code>Œ¥ = 2 * std_z</code> in this case it is irrelevant if <code>std_z</code> is defined before or after. The definitions including other parameters are treated as a system of equations and solved accordingly.</li><li>expressions containing a target parameter and an equations with endogenous variables in the non-stochastic steady state, and other parameters, or numbers: <code>k[ss] / (4 * q[ss]) = 1.5 | Œ¥</code> or <code>Œ± | 4 * q[ss] = Œ¥ * k[ss]</code> in this case the target parameter will be solved simultaneously with the non-stochastic steady state using the equation defined with it.</li></ul><p><strong>Optional arguments to be placed between <code>ùìÇ</code> and <code>ex</code></strong></p><ul><li><code>guess</code> [Type: <code>Dict{Symbol, &lt;:Real}, Dict{String, &lt;:Real}}</code>]: Guess for the non-stochastic steady state. The keys must be the variable (and calibrated parameters) names and the values the guesses. Missing values are filled with standard starting values.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print more information about how the non-stochastic steady state is solved</li><li><code>silent</code> [Default: <code>false</code>, Type: <code>Bool</code>]: do not print any information</li><li><code>symbolic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: try to solve the non-stochastic steady state symbolically and fall back to a numerical solution if not possible</li><li><code>perturbation_order</code> [Default: <code>1</code>, Type: <code>Int</code>]: take derivatives only up to the specified order at this stage. When working with higher order perturbation later on, respective derivatives will be taken at that stage.</li><li><code>simplify</code> [Default: <code>true</code>, Type: <code>Bool</code>]: whether to eliminate redundant variables and simplify the non-stochastic steady state (NSSS) problem. Setting this to <code>false</code> can speed up the process, but might make it harder to find the NSSS. If the model does not parse at all (at step 1 or 2), setting this option to <code>false</code> might solve it.</li><li><code>ss_solver_parameters_algorithm</code> [Default: <code>:ESCH</code>, Type: <code>Symbol</code>]: global optimization routine used when searching for steady-state solver parameters after an initial failure; choose <code>:ESCH</code> (evolutionary) or <code>:SAMIN</code> (simulated annealing). <code>:SAMIN</code> is available only when Optim.jl is loaded.</li><li><code>ss_solver_parameters_maxtime</code> [Default: <code>120.0</code>, Type: <code>Real</code>]: time budget in seconds for the steady-state solver parameter search when <code>ss_solver_parameters_algorithm</code> is invoked</li></ul><p><strong>Delayed parameter definition</strong></p><p>Not all parameters need to be defined in the <code>@parameters</code> macro. Calibration equations using the <code>|</code> syntax and parameters defined as functions of other parameters must be declared here, but simple parameter value assignments (e.g., <code>Œ± = 0.5</code>) can be deferred and provided later by passing them to any function that accepts the <code>parameters</code> argument (e.g., <a href="#MacroModelling.get_irf-Union{Tuple{MacroModelling.‚Ñ≥}, Tuple{R}} where R&lt;:Real"><code>get_irf</code></a>, <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a>, <a href="#MacroModelling.simulate-Tuple{MacroModelling.‚Ñ≥}"><code>simulate</code></a>). </p><p><strong>Parameter ordering:</strong> When some parameters are not defined in <code>@parameters</code>, the final parameter vector follows a specific order: first come the parameters defined in <code>@parameters</code> (in their declaration order), followed by any missing parameters (in alphabetical order). This ordering is important when passing parameter values by position rather than by name in subsequent function calls.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC verbose = true begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end

@model RBC_calibrated begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC_calibrated verbose = true guess = Dict(:k =&gt; 3) begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    k[ss] / q[ss] = 2.5 | Œ±
    Œ≤ = 0.95
end</code></pre><p><strong>Programmatic model writing</strong></p><p>Variables and parameters indexed with curly braces can be either referenced specifically (e.g. <code>c{H}[ss]</code>) or generally (e.g. <code>alpha</code>). If they are referenced generally the parse assumes all instances (indices) are meant. For example, in a model where <code>alpha</code> has two indices <code>H</code> and <code>F</code>, the expression <code>alpha = 0.3</code> is interpreted as two expressions: <code>alpha{H} = 0.3</code> and <code>alpha{F} = 0.3</code>. The same goes for calibration equations.</p><p><strong>Returns</strong></p><ul><li><code>Nothing</code>. The macro assigns parameter values and calibration equations to <code>ùìÇ</code> in the calling scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/src/macros.jl#L959">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.find_SS_solver_parameters!-Tuple{Val{:SAMIN}, MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.find_SS_solver_parameters!-Tuple{Val{:SAMIN}, MacroModelling.‚Ñ≥}"><code>MacroModelling.find_SS_solver_parameters!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_SS_solver_parameters!(::Val{:SAMIN}, ùíÇ::‚Ñ≥; maxtime::Real = 120, maxiter::Int = 2500000, tol::Tolerances = Tolerances(), verbosity = 0)</code></pre><p>Find optimal steady state solver parameters using Optim&#39;s SAMIN algorithm.</p><p>This function optimizes solver parameters to minimize runtime while maintaining solver accuracy. It uses Simulated Annealing with Metropolis acceptance (SAMIN) from Optim.jl.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: Model structure</li><li><code>maxtime</code>: Maximum time in seconds for optimization</li><li><code>maxiter</code>: Maximum number of iterations</li><li><code>tol</code>: Tolerance structure</li><li><code>verbosity</code>: Verbosity level for output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/OptimExt.jl#L99-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.find_shocks_conditional_forecast-Tuple{Val{:LBFGS}, Union{Vector{Vector{Float64}}, Vector{Float64}}, Vector{Float64}, Vector{Float64}, Vector{Int64}, Vector{Int64}, Function, Any, Any, Any, Any, MacroModelling.find_shocks_workspace{Float64}}"><a class="docstring-binding" href="#MacroModelling.find_shocks_conditional_forecast-Tuple{Val{:LBFGS}, Union{Vector{Vector{Float64}}, Vector{Float64}}, Vector{Float64}, Vector{Float64}, Vector{Int64}, Vector{Int64}, Function, Any, Any, Any, Any, MacroModelling.find_shocks_workspace{Float64}}"><code>MacroModelling.find_shocks_conditional_forecast</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_shocks_conditional_forecast(::Val{:LBFGS}, 
                                initial_state::Union{Vector{Float64}, Vector{Vector{Float64}}},
                                shocks::Vector{Float64},
                                conditions::Vector{Float64},
                                cond_var_idx::Vector{Int},
                                free_shock_idx::Vector{Int},
                                state_update::Function,
                                S‚ÇÅ, S‚ÇÇ, S‚ÇÉ, constants, ws; verbose::Bool = false)</code></pre><p>Find shocks that satisfy conditional forecast constraints using LBFGS optimizer.</p><p>Note: This is the Optim-based implementation. It requires the Optim.jl extension.</p><p><strong>Arguments</strong></p><ul><li><code>initial_state</code>: Initial state vector (or vector of vectors for pruning)</li><li><code>shocks</code>: Initial shock vector</li><li><code>conditions</code>: Target values for conditioned variables</li><li><code>cond_var_idx</code>: Indices of conditioned variables</li><li><code>free_shock_idx</code>: Indices of free shocks to be determined</li><li><code>state_update</code>: State update function for the selected algorithm</li><li><code>S‚ÇÅ</code>: First-order solution matrix</li><li><code>S‚ÇÇ</code>, <code>S‚ÇÉ</code>: Higher-order perturbation matrices (not used in LBFGS, for compatibility only)</li><li><code>constants</code>: Model constants (unused for LBFGS)</li><li><code>ws</code>: Find shocks workspace (unused for LBFGS)</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code>: Vector of optimal shock values</li><li><code>matched</code>: Boolean indicating if optimization converged successfully</li><li>Set <code>verbose = true</code> to show optimizer traces and fallback attempts</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/OptimExt.jl#L20-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.gr_backend-Tuple"><a class="docstring-binding" href="#MacroModelling.gr_backend-Tuple"><code>MacroModelling.gr_backend</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gr_backend()</code></pre><p>Renaming and reexport of StatsPlots function <code>gr()</code> to define GR.jl as backend.</p><p><strong>Returns</strong></p><ul><li><code>StatsPlots.GRBackend</code>: backend instance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L28-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_IRF!-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_IRF!-Tuple"><code>MacroModelling.plot_IRF!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3127-L3129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_IRF-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_IRF-Tuple"><code>MacroModelling.plot_IRF</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3395-L3397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_conditional_forecast!-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><a class="docstring-binding" href="#MacroModelling.plot_conditional_forecast!-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.plot_conditional_forecast!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_conditional_forecast!(
    ùìÇ,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    steady_state_function,
    variables,
    conditions_in_levels,
    algorithm,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    plot_attributes,
    plot_type,
    transparency,
    rename_dictionary,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>This function allows comparison or stacking of conditional forecasts for any combination of inputs.</p><p>This function shares most of the signature and functionality of <a href="#MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>plot_conditional_forecast</code></a>. Its main purpose is to append plots based on the inputs to previous calls of this function and the last call of <a href="#MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>plot_conditional_forecast</code></a>. In the background it keeps a registry of the inputs and outputs and then plots the comparison or stacks the output.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries, the first dimension corresponds to variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as conditions. Note that conditioning variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which conditions are specified can be included and all other variables are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing}</code>]: known values of shocks. This argument allows including certain shock values. By entering restrictions on the shocks in this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the respective period. The input can have multiple formats, but for all types of entries, the first dimension corresponds to shocks and the second dimension to the number of periods. <code>shocks</code> can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as certain shock values. Note that conditioning shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which values are specified can be included and all other shocks are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the relevant steady state subtracted (non-stochastic or stochastic steady state depending on the solution algorithm).</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>label</code> [Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots. The default is the number of previous function calls since the last call to the function version with ! + 1.</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>conditional_forecast</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>plot_type</code> [Default: <code>:compare</code>, Type: <code>Symbol</code>]: plot type used to represent results. <code>:compare</code> means results are shown as separate lines. <code>:stack</code> means results are stacked.</li><li><code>transparency</code> [Default: <code>1.0</code>, Type: <code>Float64</code>]: transparency of stacked bars. Only relevant if <code>plot_type</code> is <code>:stack</code>.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,3),Variables = [:c,:y], Periods = 1:3)
conditions[1,1] = .01
conditions[2,3] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

plot_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)

conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
conditions[4,2] = .01
conditions[6,1] = .03

plot_conditional_forecast!(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)

plot_conditional_forecast!(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false, plot_type = :stack)


plot_conditional_forecast(RBC_CME, conditions, conditions_in_levels = false)

plot_conditional_forecast!(RBC_CME, conditions, conditions_in_levels = false, algorithm = :second_order)


plot_conditional_forecast(RBC_CME, conditions, conditions_in_levels = false)

plot_conditional_forecast!(RBC_CME, conditions, conditions_in_levels = false, parameters = :beta =&gt; 0.99)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L5131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><a class="docstring-binding" href="#MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{KeyedArray{Union{Nothing, Float64}}, KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>MacroModelling.plot_conditional_forecast</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_conditional_forecast(
    ùìÇ,
    conditions;
    shocks,
    initial_state,
    periods,
    parameters,
    steady_state_function,
    variables,
    conditions_in_levels,
    algorithm,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Plot the conditional forecast given restrictions on endogenous variables and shocks (optional). By default, the values represent absolute deviations from the relevant steady state (see <code>levels</code> for details). The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. A constrained minimisation problem is solved to find the combination of shocks with the smallest squared magnitude fulfilling the conditions.</p><p>The left axis shows the level, and the right axis the deviation from the relevant steady state. The horizontal black line indicates the relevant steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>conditions</code> [Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}</code>]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries, the first dimension corresponds to variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the conditions are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as conditions. Note that conditioning variables to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input conditions is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as conditions and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of variables (of type <code>Symbol</code> or <code>String</code>) for which conditions are specified can be included and all other variables are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the conditions for the specified variables bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>shocks</code> [Default: <code>nothing</code>, Type: <code>Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing}</code>]: known values of shocks. This argument allows including certain shock values. By entering restrictions on the shocks in this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the respective period. The input can have multiple formats, but for all types of entries, the first dimension corresponds to shocks and the second dimension to the number of periods. <code>shocks</code> can be specified using a matrix of type <code>Matrix{Union{Nothing,Float64}}</code>. In this case the shocks are matrix elements of type <code>Float64</code> and all remaining (free) entries are <code>nothing</code>. A <code>SparseMatrixCSC{Float64}</code> can also be used as input. In this case only non-zero elements are taken as certain shock values. Note that conditioning shocks to be zero using a <code>SparseMatrixCSC{Float64}</code> as input is not possible (use other input formats to do so). Another possibility to input known shocks is by using a <code>KeyedArray</code>. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. A <code>KeyedArray{Union{Nothing,Float64}}</code> can be used where, similar to <code>Matrix{Union{Nothing,Float64}}</code>, all entries of type <code>Float64</code> are recognised as known shocks and all other entries have to be <code>nothing</code>. Furthermore, in the primary axis a subset of shocks (of type <code>Symbol</code> or <code>String</code>) for which values are specified can be included and all other shocks are considered free. The same goes for the case when using <code>KeyedArray{Float64}}</code> as input, whereas in this case the values for the specified shocks bind for all periods specified in the <code>KeyedArray</code>, because there are no <code>nothing</code> entries permitted with this type.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>conditions_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the conditions are provided in levels. If <code>true</code> the input to the conditions argument will have the relevant steady state subtracted (non-stochastic or stochastic steady state depending on the solution algorithm).</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>label</code> [Default: <code>1</code>, Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>conditional_forecast</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>label</code> [Default: <code>1</code>, Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3
conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,3),Variables = [:c,:y], Periods = 1:3)
conditions[1,1] = .01
conditions[2,3] = .02

# in period 2 second shock (eps_z) is conditioned to take a value of 0.05
shocks = Matrix{Union{Nothing,Float64}}(undef,2,1)
shocks[1,1] = .05

plot_conditional_forecast(RBC_CME, conditions, shocks = shocks, conditions_in_levels = false)

# The same can be achieved with the other input formats:
# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# using SparseArrays
# conditions = spzeros(7,2)
# conditions[4,1] = .01
# conditions[6,2] = .02

# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])
# shocks[1,1] = .05

# using SparseArrays
# shocks = spzeros(2,1)
# shocks[1,1] = .05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L4672">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot_conditional_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_conditional_variance_decomposition(
    ùìÇ;
    periods,
    variables,
    parameters,
    steady_state_function,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    rename_dictionary,
    plot_attributes,
    max_elements_per_legend_row,
    extra_legend_space,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm
)
</code></pre><p>Plot conditional variance decomposition of the model.</p><p>The vertical axis shows the share of the shocks variance contribution, and horizontal axis the period of the variance decomposition. The stacked bars represent each shocks variance contribution at a specific time horizon.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here. </p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>variables</code> [Default: <code>all</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>fevd</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>max_elements_per_legend_row</code> [Default: <code>4</code>, Type: <code>Int</code>]: maximum number of elements per legend row. In other words, number of columns in legend.</li><li><code>extra_legend_space</code> [Default: <code>0.0</code>, Type: <code>Float64</code>]: space between the plots and the legend (useful if the plots overlap the legend).</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .075
end

plot_conditional_variance_decomposition(RBC_CME)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3426">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_fevd-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_fevd-Tuple"><code>MacroModelling.plot_fevd</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>plot_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3673-L3675">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_forecast_error_variance_decomposition-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_forecast_error_variance_decomposition-Tuple"><code>MacroModelling.plot_forecast_error_variance_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}"><code>plot_conditional_variance_decomposition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3678-L3680">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_girf!-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_girf!-Tuple"><code>MacroModelling.plot_girf!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf!</code></a> with <code>generalised_irf = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3148-L3150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_girf-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_girf-Tuple"><code>MacroModelling.plot_girf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>generalised_irf = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3417-L3419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot_irf!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_irf!(
    ùìÇ;
    periods,
    shocks,
    variables,
    parameters,
    steady_state_function,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    algorithm,
    shock_size,
    negative_shock,
    generalised_irf,
    generalised_irf_warmup_iterations,
    generalised_irf_draws,
    initial_state,
    ignore_obc,
    plot_type,
    rename_dictionary,
    plot_attributes,
    transparency,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>This function allows comparison or stacking of impulse repsonse functions for any combination of inputs.</p><p>This function shares most of the signature and functionality of <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a>. Its main purpose is to append plots based on the inputs to previous calls of this function and the last call of <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a>. In the background it keeps a registry of the inputs and outputs and then plots the comparison or stacks the output.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>shocks</code> [Default: <code>all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>variables</code> [Default: <code>all_excluding_auxiliary_and_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>shock_size</code> [Default: <code>1</code>, Type: <code>Real</code>]: size of the shocks in standard deviations. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>. A negative value will flip the sign of the shock.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: if true, calculates IRFs for a negative shock. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear (higher order perturbation) solutions only. Reference steady state for deviations is the stochastic steady state. <code>initial_state</code> has no effect on generalised IRFs. Occasionally binding constraint are not respected for generalised IRF.</li><li><code>generalised_irf_warmup_iterations</code> [Default: <code>100</code>, Type: <code>Int</code>]: number of warm-up iterations used to draw the baseline paths in the generalised IRF simulation. Only applied when <code>generalised_irf = true</code>.</li><li><code>generalised_irf_draws</code> [Default: <code>50</code>, Type: <code>Int</code>]: number of Monte Carlo draws used to compute the generalised IRF. Only applied when <code>generalised_irf = true</code>.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>label</code> [Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots. The default is the number of previous function calls since the last call to the function version with ! + 1.</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>irf</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>plot_type</code> [Default: <code>:compare</code>, Type: <code>Symbol</code>]: plot type used to represent results. <code>:compare</code> means results are shown as separate lines. <code>:stack</code> means results are stacked.</li><li><code>transparency</code> [Default: <code>1.0</code>, Type: <code>Float64</code>]: transparency of stacked bars. Only relevant if <code>plot_type</code> is <code>:stack</code>.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;


plot_irf(RBC)

plot_irf!(RBC, algorithm = :pruned_second_order)

plot_irf!(RBC, algorithm = :pruned_second_order, generalised_irf = true)


plot_irf(RBC)

plot_irf!(RBC, parameters = :Œ≤ =&gt; 0.955)

plot_irf!(RBC, parameters = :Œ± =&gt; 0.485)


plot_irf(RBC)

plot_irf!(RBC, negative_shock = true)


plot_irf(RBC, algorithm = :pruned_second_order)

plot_irf!(RBC, algorithm = :pruned_second_order, shock_size = 2)


plot_irf(RBC)

plot_irf!(RBC, shock_size = 2, plot_type = :stack)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L2342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><a class="docstring-binding" href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot_irf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_irf(
    ùìÇ;
    periods,
    shocks,
    variables,
    parameters,
    steady_state_function,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    algorithm,
    shock_size,
    negative_shock,
    generalised_irf,
    generalised_irf_warmup_iterations,
    generalised_irf_draws,
    initial_state,
    ignore_obc,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm
)
</code></pre><p>Plot impulse response functions (IRFs) of the model.</p><p>The left axis shows the level, and the right axis the deviation from the relevant steady state. The non-stochastic steady state is relevant for first order solutions and the stochastic steady state for higher order solutions. The horizontal black line indicates the relevant steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.</p><p>If the model contains occasionally binding constraints and <code>ignore_obc = false</code> they are enforced using shocks.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the output. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the output continues.</li><li><code>shocks</code> [Default: <code>all_excluding_obc</code>]: shocks for which to calculate the IRFs. Inputs can be a shock name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code>, or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:simulate</code> triggers random draws of all shocks (excluding occasionally binding constraints (obc) related shocks). <code>all_excluding_obc</code> will contain all shocks but not the obc related ones. <code>all</code> will contain also the obc related shocks. A series of shocks can be passed on using either a <code>Matrix{Float64}</code>, or a <code>KeyedArray{Float64}</code> as input with shocks (<code>Symbol</code> or <code>String</code>) in rows and periods in columns. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in <code>periods</code>. If the series of shocks is input as a <code>KeyedArray{Float64}</code> make sure to name the rows with valid shock names of type <code>Symbol</code>. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>variables</code> [Default: <code>all_excluding_auxiliary_and_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>shock_size</code> [Default: <code>1</code>, Type: <code>Real</code>]: size of the shocks in standard deviations. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>. A negative value will flip the sign of the shock.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: if true, calculates IRFs for a negative shock. Only affects shocks that are not passed on as a <code>Matrix</code> or <code>KeyedArray</code> or set to <code>:none</code>.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear (higher order perturbation) solutions only. Reference steady state for deviations is the stochastic steady state. <code>initial_state</code> has no effect on generalised IRFs. Occasionally binding constraint are not respected for generalised IRF.</li><li><code>generalised_irf_warmup_iterations</code> [Default: <code>100</code>, Type: <code>Int</code>]: number of warm-up iterations used to draw the baseline paths in the generalised IRF simulation. Only applied when <code>generalised_irf = true</code>.</li><li><code>generalised_irf_draws</code> [Default: <code>50</code>, Type: <code>Int</code>]: number of Monte Carlo draws used to compute the generalised IRF. Only applied when <code>generalised_irf = true</code>.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Union{Vector{Vector{Float64}},Vector{Float64}}</code>]: The initial state defines the starting point for the model. In the case of pruned solution algorithms the initial state can be given as multiple state vectors (<code>Vector{Vector{Float64}}</code>). For multiple state vectors the initial state vectors must be given in deviations from the non-stochastic steady state. In all other cases (incl. for pruned solutions) the initial state must be given in levels. If a pruned solution algorithm is selected and <code>initial_state</code> is a <code>Vector{Float64}</code> then it impacts the first order initial state vector only. The state includes all variables as well as exogenous variables in leads or lags if present. <code>get_irf(ùìÇ, shocks = :none, variables = :all, periods = 1, levels = true)</code> returns a <code>KeyedArray</code> with all variables in levels. The <code>KeyedArray</code> type is provided by the <code>AxisKeys</code> package.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>label</code> [Default: <code>1</code>, Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>irf</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>label</code> [Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots. The default is the number of previous function calls since the last call to the function version with ! + 1.</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

plot_irf(RBC)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L1678">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_irfs!-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_irfs!-Tuple"><code>MacroModelling.plot_irfs!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3132-L3134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_irfs-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_irfs-Tuple"><code>MacroModelling.plot_irfs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>See <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3401-L3403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_model_estimates!-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.plot_model_estimates!-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.plot_model_estimates!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_model_estimates!(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    warmup_iterations,
    variables,
    shocks,
    presample_periods,
    forecast_periods,
    data_in_levels,
    smooth,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    max_elements_per_legend_row,
    extra_legend_space,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>This function allows comparison of the estimated variables, shocks, the data underlying the estimates, and unconditional forecasts for any combination of inputs. The unconditional forecast (shown as a dashed line) displays the model&#39;s expected path absent any exongeos shocks starting from the final filtered state. In case the relevant steady state differs for a variable across the different calls, the plot shows the absolute deviations from the respective steady state for each call. The only exception being if the variable is observed in the data, in which case the data is always shown in levels, and the relevant steady states are indicated by black lines and mentioned in the table below the plot.</p><p>This function shares most of the signature and functionality of <a href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>plot_model_estimates</code></a>. Its main purpose is to append plots based on the inputs to previous calls of this function and the last call of <a href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>plot_model_estimates</code></a>. In the background it keeps a registry of the inputs and outputs and then plots the comparison.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to plot the estimates in the respective subplots. Inputs can be either a <code>Symbol</code> or <code>String</code> (e.g. <code>:eps_a</code>, <code>&quot;eps_a&quot;</code>, or <code>:all</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> selects all shocks in the model. <code>:none</code> selects no shocks in the model.</li><li><code>presample_periods</code> [Default: <code>0</code>, Type: <code>Int</code>]: number of initial periods in the data omitted from the plot. Useful when filtering the full sample while focusing on a later subperiod.</li><li><code>forecast_periods</code> [Default: <code>12</code>, Type: <code>Int</code>]: number of periods of unconditional forecast to add after the last period of data. The forecast is shown as a dotted line to distinguish it from the model estimates.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>label</code> [Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots. The default is the number of previous function calls since the last call to the function version with ! + 1.</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>estimation</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>max_elements_per_legend_row</code> [Default: <code>4</code>, Type: <code>Int</code>]: maximum number of elements per legend row. In other words, number of columns in legend.</li><li><code>extra_legend_space</code> [Default: <code>0.0</code>, Type: <code>Float64</code>]: space between the plots and the legend (useful if the plots overlap the legend).</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots


@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

simulation = simulate(RBC_CME)


plot_model_estimates(RBC_CME, simulation([:k],:,:simulate))

plot_model_estimates!(RBC_CME, simulation([:k,:c],:,:simulate))


plot_model_estimates(RBC_CME, simulation([:k],:,:simulate))

plot_model_estimates!(RBC_CME, simulation([:k],:,:simulate), smooth = false)

plot_model_estimates!(RBC_CME, simulation([:k],:,:simulate), filter = :inversion)


plot_model_estimates(RBC_CME, simulation([:c],:,:simulate))

plot_model_estimates!(RBC_CME, simulation([:c],:,:simulate), algorithm = :second_order)


plot_model_estimates(RBC_CME, simulation([:k],:,:simulate))

plot_model_estimates!(RBC_CME, simulation([:k],:,:simulate), parameters = :beta =&gt; .99)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L692">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><a class="docstring-binding" href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>MacroModelling.plot_model_estimates</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_model_estimates(
    ùìÇ,
    data;
    parameters,
    steady_state_function,
    algorithm,
    filter,
    warmup_iterations,
    variables,
    shocks,
    presample_periods,
    forecast_periods,
    data_in_levels,
    shock_decomposition,
    smooth,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    transparency,
    max_elements_per_legend_row,
    extra_legend_space,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Plot model estimates of the variables given the data. The default plot shows the estimated variables, shocks, the data underlying the estimates, and an unconditional forecast extending beyond the last data period. The estimates are based on the Kalman smoother or filter (depending on the <code>smooth</code> keyword argument) or inversion filter using the provided data and solution of the model. The unconditional forecast (shown as a dashed line) displays the model&#39;s expected path absent any exongeos shocks starting from the final filtered state.</p><p>The left axis shows the level, and the right the deviation from the relevant steady state. The non-stochastic steady state (NSSS) is relevant for first order solutions and the stochastic steady state for higher order solutions. The horizontal black line indicates the relevant steady state. Variable names are above the subplots and the title provides information about the model, shocks, and number of pages per shock. In case <code>shock_decomposition = true</code>, the plot shows the variables, shocks, and data in absolute deviations from the relevant steady state as a stacked bar chart per period.</p><p>For higher order perturbation solutions the decomposition additionally contains a term <code>Nonlinearities</code>. This term represents the nonlinear interaction between the states in the periods after the shocks arrived and in the case of pruned third order, the interaction between (pruned second order) states and contemporaneous shocks.</p><p>If occasionally binding constraints are present in the model, they are not taken into account here.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>data</code> [Type: <code>KeyedArray</code>]: data matrix with variables (<code>String</code> or <code>Symbol</code>) in rows and periods in columns. Periods can have any format and will be used for the output. <code>KeyedArray</code> is provided by the <code>AxisKeys</code> package.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>filter</code> [Default: selector that chooses <code>kalman</code> in case <code>algorithm = first_order</code> and <code>:inversion</code> otherwise, Type: <code>Symbol</code>]: filter used to compute the variables and shocks given the data, model, and parameters. The Kalman filter only works for linear problems, whereas the inversion filter (<code>:inversion</code>) works for linear and nonlinear models. If a nonlinear solution algorithm is selected and the default is used, the inversion filter is applied automatically.</li><li><code>variables</code> [Default: <code>all_excluding_obc</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to plot the estimates in the respective subplots and in the shock decompositions. Inputs can be either a <code>Symbol</code> or <code>String</code> (e.g. <code>:eps_a</code>, <code>&quot;eps_a&quot;</code>, or <code>:all</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. <code>:all</code> selects all shocks in the model. <code>:none</code> selects no shocks in the model. If not all shocks are shown, the ommitted shocks will be summarised and netted under the label <code>Other shocks (net)</code> in the shock decomposition.</li><li><code>presample_periods</code> [Default: <code>0</code>, Type: <code>Int</code>]: number of initial periods in the data omitted from the plot. Useful when filtering the full sample while focusing on a later subperiod.</li><li><code>forecast_periods</code> [Default: <code>12</code>, Type: <code>Int</code>]: number of periods of unconditional forecast to add after the last period of data. The forecast is shown as a dotted line to distinguish it from the model estimates.</li><li><code>data_in_levels</code> [Default: <code>true</code>, Type: <code>Bool</code>]: indicator whether the data is provided in levels. If <code>true</code> the input to the data argument will have the non-stochastic steady state subtracted.</li><li><code>shock_decomposition</code> [Default: <code>true</code> for algorithms supporting shock decompositions (<code>:first_order</code>, <code>:pruned_second_order</code>, <code>:pruned_third_order</code>), otherwise <code>false</code>, Type: <code>Bool</code>]: whether to show the contribution of the shocks to the deviations from NSSS for each variable. If <code>false</code>, the plot shows the values of the selected variables, data, and shocks. When an unsupported algorithm is chosen the argument automatically falls back to <code>false</code>.</li><li><code>smooth</code> [Default: selector that enables smoothing when <code>filter = kalman</code> and disables it otherwise, Type: <code>Bool</code>]: whether to return smoothed (<code>true</code>) or filtered (<code>false</code>) shocks/variables. Smoothing is only available for the Kalman filter. The inversion filter only returns filtered shocks/variables, so the default turns smoothing off in that case.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>estimation</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>transparency</code> [Default: <code>1.0</code>, Type: <code>Float64</code>]: transparency of stacked bars. Only relevant if <code>shock_decomposition</code> is <code>true</code>.</li><li><code>max_elements_per_legend_row</code> [Default: <code>4</code>, Type: <code>Int</code>]: maximum number of elements per legend row. In other words, number of columns in legend.</li><li><code>extra_legend_space</code> [Default: <code>0.0</code>, Type: <code>Float64</code>]: space between the plots and the legend (useful if the plots overlap the legend).</li><li><code>label</code> [Default: <code>1</code>, Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots.</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots


@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

simulation = simulate(RBC_CME)

plot_model_estimates(RBC_CME, simulation([:k],:,:simulate))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_shock_decomposition-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_shock_decomposition-Tuple"><code>MacroModelling.plot_shock_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_model_estimates-Tuple{MacroModelling.‚Ñ≥, KeyedArray{Float64}}"><code>plot_model_estimates</code></a> with <code>shock_decomposition = true</code>.</p><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L683-L688">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_simulation!-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_simulation!-Tuple"><code>MacroModelling.plot_simulation!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf!</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3143-L3145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_simulation-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_simulation-Tuple"><code>MacroModelling.plot_simulation</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3412-L3414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_simulations!-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_simulations!-Tuple"><code>MacroModelling.plot_simulations!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf!-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf!</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3138-L3140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_simulations-Tuple"><a class="docstring-binding" href="#MacroModelling.plot_simulations-Tuple"><code>MacroModelling.plot_simulations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Wrapper for <a href="#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}"><code>plot_irf</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3407-L3409">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_solution!-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}"><a class="docstring-binding" href="#MacroModelling.plot_solution!-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}"><code>MacroModelling.plot_solution!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_solution!(
    ùìÇ,
    state;
    variables,
    algorithm,
    œÉ,
    parameters,
    steady_state_function,
    ignore_obc,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Add another model variant to the previous plot of the solution. </p><p>Each plot shows the relationship between the chosen state (defined in <code>state</code>) and one of the chosen variables (defined in <code>variables</code>).</p><p>The relevant steady state is plotted along with the mapping from the chosen past state to one present variable per plot. All other (non-chosen) states remain in the relevant steady state.</p><p>In the case of pruned higher order solutions there are as many (latent) state vectors as the perturbation order. The first and third order baseline state vectors are the non-stochastic steady state and the second order baseline state vector is the stochastic steady state. Deviations for the chosen state are only added to the first order baseline state. The plot shows the mapping from <code>œÉ</code> standard deviations (first order) added to the first order non-stochastic steady state and the present variables. Note that there is no unique mapping from the &quot;pruned&quot; states and the &quot;actual&quot; reported state. Hence, the plots shown are just one realisation of infinitely many possible mappings.</p><p>If the model contains occasionally binding constraints and <code>ignore_obc = false</code> they are enforced using shocks.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>state</code> [Type: <code>Union{Symbol,String}</code>]: state variable to be shown on x-axis.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>variables</code> [Default: <code>all</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>œÉ</code> [Default: <code>2</code>, Type: <code>Union{Int64,Float64}</code>]: defines the range of the state variable around the (non) stochastic steady state in standard deviations. E.g. a value of 2 means that the state variable is plotted for values of the (non) stochastic steady state in standard deviations +/- 2 standard deviations.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>solution</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>label</code> [Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots. The default is the number of previous function calls since the last call to the function version with ! + 1.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

plot_solution(RBC_CME, :k)

plot_solution!(RBC_CME, :k, algorithm = :pruned_second_order)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L4408-L4479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plot_solution-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}"><a class="docstring-binding" href="#MacroModelling.plot_solution-Tuple{MacroModelling.‚Ñ≥, Union{String, Symbol}}"><code>MacroModelling.plot_solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_solution(
    ùìÇ,
    state;
    variables,
    algorithm,
    œÉ,
    parameters,
    steady_state_function,
    ignore_obc,
    label,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_name,
    save_plots_path,
    plots_per_page,
    rename_dictionary,
    plot_attributes,
    verbose,
    tol,
    quadratic_matrix_equation_algorithm,
    sylvester_algorithm,
    lyapunov_algorithm
)
</code></pre><p>Plot the solution of the model (mapping of past states to present variables) around the relevant steady state (e.g. higher order perturbation algorithms are centred around the stochastic steady state). Each plot shows the relationship between the chosen state (defined in <code>state</code>) and one of the chosen variables (defined in <code>variables</code>). </p><p>The relevant steady state is plotted along with the mapping from the chosen past state to one present variable per plot. All other (non-chosen) states remain in the relevant steady state.</p><p>In the case of pruned higher order solutions there are as many (latent) state vectors as the perturbation order. The first and third order baseline state vectors are the non-stochastic steady state and the second order baseline state vector is the stochastic steady state. Deviations for the chosen state are only added to the first order baseline state. The plot shows the mapping from <code>œÉ</code> standard deviations (first order) added to the first order non-stochastic steady state and the present variables. Note that there is no unique mapping from the &quot;pruned&quot; states and the &quot;actual&quot; reported state. Hence, the plots shown are just one realisation of infinitely many possible mappings.</p><p>If the model contains occasionally binding constraints and <code>ignore_obc = false</code> they are enforced using shocks.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: object created by <a href="#MacroModelling.@model-Tuple{Any, Vararg{Any}}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a>.</li><li><code>state</code> [Type: <code>Union{Symbol,String}</code>]: state variable to be shown on x-axis.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>variables</code> [Default: <code>all</code>]: variables for which to show the results. Inputs can be a variable name passed on as either a <code>Symbol</code> or <code>String</code> (e.g. <code>:y</code> or <code>&quot;y&quot;</code>), or <code>Tuple</code>, <code>Matrix</code> or <code>Vector</code> of <code>String</code> or <code>Symbol</code>. Any variables not part of the model will trigger a warning. <code>all_excluding_auxiliary_and_obc</code> contains all shocks less those related to auxiliary variables and related to occasionally binding constraints (obc). <code>all_excluding_obc</code> contains all shocks less those related to auxiliary variables. <code>all</code> will contain all variables.</li><li><code>algorithm</code> [Default: <code>first_order</code>, Type: <code>Symbol</code>]: algorithm to solve for the dynamics of the model. Available algorithms: <code>:first_order</code>, <code>:second_order</code>, <code>:pruned_second_order</code>, <code>:third_order</code>, <code>:pruned_third_order</code></li><li><code>œÉ</code> [Default: <code>2</code>, Type: <code>Union{Int64,Float64}</code>]: defines the range of the state variable around the (non) stochastic steady state in standard deviations. E.g. a value of 2 means that the state variable is plotted for values of the (non) stochastic steady state in standard deviations +/- 2 standard deviations.</li><li><code>parameters</code> [Default: <code>nothing</code>]: If <code>nothing</code> is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a <code>Vector</code> of parameter values, a <code>Vector</code> or <code>Tuple</code> of <code>Pair</code>s of the parameter <code>Symbol</code> or <code>String</code> and value. If the new parameter values differ from the previously defined the solution will be recalculated.</li><li><code>steady_state_function</code> [Default: <code>missing</code>, Type: <code>Union{Function, Symbol, Nothing, Missing}</code>]: Custom steady state routine applied instead of the internal solver when provided; accepts either <code>f(parameters)</code> returning <code>[variables; calibrated parameters]</code> or <code>f!(out, parameters)</code> filling an output vector in the same order. Use <code>nothing</code> to clear any previously set function and rely on the internal solver; <code>missing</code> keeps the current setting.</li><li><code>ignore_obc</code> [Default: <code>false</code>, Type: <code>Bool</code>]: solve the model ignoring the occasionally binding constraints.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and variables depending on number of variables and <code>plots_per_page</code>.</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Each plot is saved as a separate file with a name that indicates the model name, shocks, and a running number per shock.</li><li><code>save_plots_format</code> [Default: <code>pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>save_plots_path</code> [Default: <code>.</code>, Type: <code>String</code>]: path where to save plots. If the path does not exist it will be created automatically.</li><li><code>save_plots_name</code> [Default: <code>solution</code>, Type: <code>Union{String, Symbol}</code>]: prefix used when saving plots to disk.</li><li><code>plots_per_page</code> [Default: <code>6</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>plot_attributes</code> [Default: <code>Dict{Symbol, Any}(:titlefont =&gt; 8, :guidefont =&gt; 8, :palette =&gt; :auto, :legend_title_font_pointsize =&gt; 8, :size =&gt; (700, 500), :plot_titlefont =&gt; 10, :legendfontsize =&gt; 8, :annotationfontsize =&gt; 8, :tickfontsize =&gt; 8, :framestyle =&gt; :semi)</code>, Type: <code>Dict</code>]: pass on plot attributes for the top-level plot (see https://docs.juliaplots.org/latest/generated/attributes<em>plot/). E.g. Dict(:plot</em>titlefontcolor =&gt; :red).</li><li><code>rename_dictionary</code> [Default: <code>Dict()</code>, Type: <code>Dict{Symbol, String}</code>]: dictionary mapping variable or shock symbols to custom display names in plots. For example: <code>Dict(:dinve =&gt; &quot;Investment growth&quot;, :c =&gt; &quot;Consumption&quot;)</code>. Variables/shocks not in the dictionary will use their default names.</li><li><code>label</code> [Default: <code>1</code>, Type: <code>Union{Real, String, Symbol}</code>]: label to attribute to this function call in the plots.</li><li><code>quadratic_matrix_equation_algorithm</code> [Default: <code>schur</code>, Type: <code>Symbol</code>]: algorithm to solve quadratic matrix equation (<code>A * X ^ 2 + B * X + C = 0</code>). Available algorithms: <code>:schur</code>, <code>:doubling</code></li><li><code>sylvester_algorithm</code> [Default: selector that uses <code>doubling</code> for smaller problems and switches to <code>bicgstab</code> for larger problems, Type: <code>Union{Symbol,Vector{Symbol},Tuple{Symbol,Vararg{Symbol}}}</code>]: algorithm to solve the Sylvester equation (<code>A * X * B + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:dqgmres</code>, <code>:gmres</code>. Input argument can contain up to two elements in a <code>Vector</code> or <code>Tuple</code>. The first (second) element corresponds to the second (third) order perturbation solutions&#39; Sylvester equation. If only one element is provided it corresponds to the second order perturbation solutions&#39; Sylvester equation.</li><li><code>lyapunov_algorithm</code> [Default: <code>doubling</code>, Type: <code>Symbol</code>]: algorithm to solve Lyapunov equation (<code>A * X * A&#39; + C = X</code>). Available algorithms: <code>:doubling</code>, <code>:bartels_stewart</code>, <code>:bicgstab</code>, <code>:gmres</code></li><li><code>tol</code> [Default: <code>Tolerances()</code>, Type: <code>Tolerances</code>]: define various tolerances for the algorithm used to solve the model. See documentation of <a href="@ref"><code>Tolerances</code></a> for more details: <code>?Tolerances</code>.</li><li><code>verbose</code> [Default: <code>false</code>, Type: <code>Bool</code>]: print information about results of the different solvers used to solve the model (non-stochastic steady state solver, Sylvester equations, Lyapunov equation, and quadratic matrix equation).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Plot}</code> of individual plots</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling, StatsPlots

@model RBC_CME begin
    y[0]=A[0]*k[-1]^alpha
    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))
    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])
    R[0] * beta =(Pi[0]/Pibar)^phi_pi
    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]
    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]
    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]
end

@parameters RBC_CME begin
    alpha = .157
    beta = .999
    delta = .0226
    Pibar = 1.0008
    phi_pi = 1.5
    rhoz = .9
    std_eps = .0068
    rho_z_delta = .9
    std_z_delta = .005
end

plot_solution(RBC_CME, :k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L3687">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.plotlyjs_backend-Tuple"><a class="docstring-binding" href="#MacroModelling.plotlyjs_backend-Tuple"><code>MacroModelling.plotlyjs_backend</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotlyjs_backend()</code></pre><p>Renaming and reexport of StatsPlots function <code>plotlyjs()</code> to define PlotlyJS.jl as backend.</p><p><strong>Returns</strong></p><ul><li><code>StatsPlots.PlotlyJSBackend</code>: backend instance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/StatsPlotsExt.jl#L39-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Beta-NTuple{4, Real}"><a class="docstring-binding" href="#MacroModelling.Beta-NTuple{4, Real}"><code>MacroModelling.Beta</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Beta(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Constructs a truncated <code>Beta</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The first parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The second parameter (Œ≤) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li><li><code>lower_bound</code> [Type: <code>Real</code>]: The truncation lower bound of the distribution.</li><li><code>upper_bound</code> [Type: <code>Real</code>]: The truncation upper bound of the distribution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the <code>Œ±</code> and <code>Œ≤</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Beta-Tuple{Real, Real}"><a class="docstring-binding" href="#MacroModelling.Beta-Tuple{Real, Real}"><code>MacroModelling.Beta</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Beta(Œº, œÉ; ŒºœÉ)
</code></pre><p>Constructs a <code>Beta</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The first parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The second parameter (Œ≤) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the <code>Œ±</code> and <code>Œ≤</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Cauchy-NTuple{4, Real}"><a class="docstring-binding" href="#MacroModelling.Cauchy-NTuple{4, Real}"><code>MacroModelling.Cauchy</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Cauchy(Œº, œÉ, lower_bound, upper_bound)
</code></pre><p>Convenience wrapper for the truncated <code>Cauchy</code> distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The location parameter.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The scale parameter.</li><li><code>lower_bound</code> [Type: <code>Real</code>]: The truncation lower bound of the distribution.</li><li><code>upper_bound</code> [Type: <code>Real</code>]: The truncation upper bound of the distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Gamma-NTuple{4, Real}"><a class="docstring-binding" href="#MacroModelling.Gamma-NTuple{4, Real}"><code>MacroModelling.Gamma</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Gamma(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Constructs a truncated <code>Gamma</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The shape parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The rate parameter (Œ∏) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li><li><code>lower_bound</code> [Type: <code>Real</code>]: The truncation lower bound of the distribution.</li><li><code>upper_bound</code> [Type: <code>Real</code>]: The truncation upper bound of the distribution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the shape <code>Œ±</code> and scale <code>Œ∏</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Gamma-Tuple{Real, Real}"><a class="docstring-binding" href="#MacroModelling.Gamma-Tuple{Real, Real}"><code>MacroModelling.Gamma</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Gamma(Œº, œÉ; ŒºœÉ)
</code></pre><p>Constructs a <code>Gamma</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The shape parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The rate parameter (Œ∏) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the shape <code>Œ±</code> and scale <code>Œ∏</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.InverseGamma-NTuple{4, Real}"><a class="docstring-binding" href="#MacroModelling.InverseGamma-NTuple{4, Real}"><code>MacroModelling.InverseGamma</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InverseGamma(Œº, œÉ, lower_bound, upper_bound; ŒºœÉ)
</code></pre><p>Constructs a truncated <code>InverseGamma</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The shape parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The scale parameter (Œ≤) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li><li><code>lower_bound</code> [Type: <code>Real</code>]: The truncation lower bound of the distribution.</li><li><code>upper_bound</code> [Type: <code>Real</code>]: The truncation upper bound of the distribution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the shape <code>Œ±</code> and scale <code>Œ≤</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.InverseGamma-Tuple{Real, Real}"><a class="docstring-binding" href="#MacroModelling.InverseGamma-Tuple{Real, Real}"><code>MacroModelling.InverseGamma</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InverseGamma(Œº, œÉ; ŒºœÉ)
</code></pre><p>Constructs an <code>InverseGamma</code> distribution, optionally parameterized by its mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The shape parameter (Œ±) of the distribution, or the mean when <code>ŒºœÉ=true</code>.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The scale parameter (Œ≤) of the distribution, or the standard deviation when <code>ŒºœÉ=true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ŒºœÉ</code> [Type: <code>Bool</code>, Default: <code>false</code>]: If <code>true</code>, <code>Œº</code> and <code>œÉ</code> are interpreted as the mean and standard deviation to calculate the shape <code>Œ±</code> and scale <code>Œ≤</code> parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroModelling.Normal-NTuple{4, Real}"><a class="docstring-binding" href="#MacroModelling.Normal-NTuple{4, Real}"><code>MacroModelling.Normal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Normal(Œº, œÉ, lower_bound, upper_bound)
</code></pre><p>Convenience wrapper for the truncated <code>Normal</code> distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Œº</code> [Type: <code>Real</code>]: The mean of the distribution.</li><li><code>œÉ</code> [Type: <code>Real</code>]: The standard deviation of the distribution.</li><li><code>lower_bound</code> [Type: <code>Real</code>]: The truncation lower bound of the distribution.</li><li><code>upper_bound</code> [Type: <code>Real</code>]: The truncation upper bound of the distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/9300348e7b43d920ee0e28ccafde606e3633f311/ext/TuringExt.jl#L157">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how-to/obc/">¬´ Occasionally binding constraints</a><a class="docs-footer-nextpage" href="../call_index/">Index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 19:43">Friday 30 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
